# def get_code_mode():
#     print("Getting code mode...")
#     ### All of this code is just trying to find the right menu item for the "Use C Version" check box:
#     code_mode = 'python'
#     menubar = alignem.main_window.menu
#     menubar_items = [menubar.children()[x].title() for x in range(len(menubar.children())) if
#                      'title' in dir(menubar.children()[x])]
#     submenus = [menubar.children()[x] for x in range(len(menubar.children())) if
#                 'title' in dir(menubar.children()[x])]
#     alignem.print_debug(40, "Menubar contains: " + str(menubar_items))
#     setmenu_index = -1
#     for m in menubar_items:
#         if "Set" in m:
#             setmenu_index = menubar_items.index(m)
#     alignem.print_debug(40, "Set menu is item " + str(setmenu_index))
#     if setmenu_index >= 0:
#         set_menu = submenus[setmenu_index]
#         set_menu_actions = set_menu.actions()
#         use_c_version = None
#         for action in set_menu_actions:
#             if "Use C Version" in action.text():
#                 use_c_version = action
#                 break
#         if use_c_version != None:
#             if use_c_version.isChecked():
#                 code_mode = "c"
#     print("get_code_mode is returning: ", code_mode)
#     return (code_mode)


# @Slot()
# def set_current_scale(self, checked):
#     print("@Slot Setting current scale | MainWindow.set_current_scale...")
#     local_cur_scale = get_cur_scale()
#     print_debug ( 30, "Set current Scale to " + str(self.sender().text()) )
#     old_scale = local_cur_scale
#     new_scale = get_scale_key ( str ( self.sender().text() ) )
#     if self.view_change_callback != None:
#       leaving_layer = project_data['data']['current_layer']
#       entering_layer = project_data['data']['current_layer']
#       try:
#         # This guards against errors in "user code"
#         main_window.view_change_callback ( old_scale, new_scale, leaving_layer, entering_layer )
#       except:
#         print_debug ( 0, "Exception in set_current_scale: " + str(sys.exc_info()) )
#     local_cur_scale = new_scale
#     project_data['data']['current_scale'] = local_cur_scale
#     print_debug ( 30, "Set current_scale key to " + str(project_data['data']['current_scale']) )
#
#     image_library.update()
#
#     for p in self.panel_list:
#         p.update_zpa_self()
#     self.update_win_self()
#
#     self.reload_scales_combobox()
#
#     self.center_all_images() #center
#     self.update_win_self()


# @Slot()
# def generate_scales_callback(self):
#     print("@Slot Generating scales callback | MainWindow.generate_scales_callback...")
#     print_debug ( 5, "Generating scales is now handled via control panel buttons in subclass alignem_swift." )



# def set_selected_scale ( self, scale_str ):
#     print("!!! Setting selected scale | MainWindow.set_selected_scale...")
#     print("  scale_str = ", str(scale_str))
#     # Set the Scales menu from this scales_list
#     mb = self.menuBar()
#     if not (mb is None):
#       for m in mb.children():
#         if type(m) == QMenu:
#           text_label = ''.join(m.title().split('&'))
#           if 'Scale' in text_label:
#             print_debug ( 30, "Found Scale Menu" )
#             scale_to_match = int(str(project_data['data']['current_scale'].split('_')[1]))
#             print("  scale_to_match = ", scale_to_match)
#             for a in m.actions():
#               if int(a.text()) == scale_to_match:
#                 a.setChecked ( True )
#                 project_data['data']['current_scale'] = 'scale_' + str(scale_to_match)
#               else:
#                 a.setChecked ( False )
#
#     self.center_all_images() #center
#     self.update_win_self()
#
#     self.update_panels()
#     self.refresh_all()


# def null_bias_changed_callback(state):
#     global ignore_changes
#     print_debug(50, 100 * '+')
#     print_debug(50, "Null Bias changed to " + str(state))
#     print_debug(50, "ignore_changes = " + str(ignore_changes))
#     print_debug(50, 100 * '+')
#     if not ignore_changes:
#         if state:
#             project_data['data']['scales'][project_data['data']['current_scale']]['null_cafm_trends'] = True
#         else:
#             project_data['data']['scales'][project_data['data']['current_scale']]['null_cafm_trends'] = False
#         print_debug(50, "null_bias_changed_callback (" + str(state) + " saved as " + str(
#             project_data['data']['scales'][project_data['data']['current_scale']]['null_cafm_trends']) + ")")


# def bool_changed_callback ( state ):
#     global ignore_changes
#     print_debug ( 50, 100*'+' )
#     print_debug ( 2, "Bool changed to " + str(state) )
#     print_debug ( 2, "ignore_changes = " + str(ignore_changes))
#     print_debug ( 50, 100*'+' )
#     if not ignore_changes:
#         if main_window != None:
#             if main_window.view_change_callback != None:
#                 layer_num = 0
#                 if project_data != None:
#                     if 'data' in project_data:
#                         if 'current_layer' in project_data['data']:
#                             layer_num = project_data['data']['current_layer']
#                 ignore_changes = True
#                 main_window.view_change_callback ( None, None, layer_num, layer_num )
#                 ignore_changes = False


# class ControlPanelWidget(QWidget):
#     """A widget to hold all of the application data for an alignment method."""
#     def __init__(self, control_model=None):
#         super(ControlPanelWidget, self).__init__()
#         self.cm = control_model
#         #self.control_panel = QWidget()
#         self.control_panel_layout = QVBoxLayout()
#         self.setLayout(self.control_panel_layout)
#         #self.control_panel_layout.setContentsMargin(0) #pyside6
#         #self.control_panel_layout.setMargin(0) #pyside2
#         self.control_panel_layout.setSpacing(0)
#
#         if self.cm != None:
#             # Only show the first pane for now
#             rows = control_model[0]
#             print_debug ( 30, "Pane contains " + str(len(rows)) + " rows" )
#
#             for row in rows:
#               row_box = QWidget()
#               row_box_layout = QHBoxLayout()
#               #row_box_layout.setContentsMargin(2) #pyside6
#               #row_box_layout.setMargin(2) #pyside2
#               row_box_layout.setSpacing(2)
#               row_box.setLayout ( row_box_layout )
#               print_debug ( 30, "Row contains " + str(len(row)) + " items" )
#               for item in row:
#                   print_debug ( 30, "  Item is " + str(item) )
#                   if type(item) == type('a'):
#                       item_widget = QLabel ( str(item) )
#                       item_widget.setAlignment(Qt.AlignHCenter)
#                       row_box_layout.addWidget ( item_widget )
#                   elif type(item) == type([]):
#                       item_widget = QPushButton ( str(item[0]) )
#                       row_box_layout.addWidget ( item_widget )
#                   elif isinstance(item, BoolField):
#                       val_widget = ( QCheckBox ( str(item.text) ) )
#                       row_box_layout.addWidget ( val_widget )
#                       # Hard code a few special callbacks ...
#                       if item.text == "Null Bias":
#                           #val_widget.stateChanged.connect(null_bias_changed_callback)
#                           val_widget.clicked.connect(null_bias_changed_callback)
#                       elif item.text == "Bounding Rect":
#                           #val_widget.stateChanged.connect(bounding_rect_changed_callback)
#                           val_widget.clicked.connect(bounding_rect_changed_callback)
#                       elif item.text == "Skip":
#                           #val_widget.stateChanged.connect(skip_changed_callback)
#                           val_widget.clicked.connect(skip_changed_callback)
#                       else:
#                           #val_widget.stateChanged.connect(bool_changed_callback)
#                           val_widget.clicked.connect(bool_changed_callback)
#                       item.widget = val_widget
#                   elif isinstance(item, TextField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, IntField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, FloatField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, CallbackButton):
#                       item_widget = QPushButton ( str(item.text) )
#                       item_widget.clicked.connect ( item.callback )
#                       item.widget = item_widget
#                       row_box_layout.addWidget ( item_widget )
#                   elif isinstance (item, ComboBoxControl):
#                       item_widget = QComboBox()
#                       item_widget.addItems (item.choices)
#                       #item_widget.clicked.connect ( item.callback )
#                       item.widget = item_widget
#                       row_box_layout.addWidget ( item_widget )
#                   else:
#                       item_widget = QLineEdit ( str(item) )
#                       item_widget.setAlignment(Qt.AlignHCenter)
#                       row_box_layout.addWidget ( item_widget )
#               self.control_panel_layout.addWidget ( row_box )
#
#     def dump ( self ):
#         print_debug ( 1, "Control Panel:" )
#         for p in self.cm:
#           print_debug ( 1, "  Panel:" )
#           for r in p:
#             print_debug ( 1, "    Row:" )
#             for i in r:
#               print_debug ( 1, "      Item: " + str(i) )
#               print_debug ( 1, "          Subclass of GenericWidget: " + str(isinstance(i,GenericWidget)) )
#
#     def copy_self_to_data ( self ):
#         data = []
#         for p in self.cm:
#           new_panel = []
#           for r in p:
#             new_row = []
#             for i in r:
#               if isinstance(i,GenericWidget):
#                 # Store as a list to identify as a widget
#                 new_row.append ( [ i.get_value() ] )
#               else:
#                 # Store as static raw data
#                 # new_row.append ( i )  # This data is useless since it's set by the application
#                 new_row.append ( '' )   # Save an empty string as a place holder for static data
#             new_panel.append ( new_row )
#           data.append ( new_panel )
#         return data
#
#     def copy_data_to_self ( self, data ):
#         ip = 0
#         for p in self.cm:
#           panel = data[ip]
#           ip += 1
#           ir = 0
#           for r in p:
#             row = panel[ir]
#             ir += 1
#             ii = 0
#             for i in r:
#               item = row[ii]
#               ii += 1
#               if type(item) == type([]):
#                 # This was a widget
#                 i.set_value ( item[0] )
#               else:
#                 # Ignore static raw data
#                 pass
#
#     def distribute_all_layer_data ( self, control_panel_layer_list ):
#         # First make a copy of this widget's data
#         this_layers_data = self.copy_self_to_data()
#
#         # Search the widgets for those that should be identical across all layers
#         page_index = 0
#         for p in self.cm:
#           row_index = 0
#           for r in p:
#             item_index = 0
#             for i in r:
#               if isinstance(i,GenericWidget):
#                 if 'all_layers' in dir(i):
#                   if i.all_layers:
#                     # Store this value in all layers
#                     for l in control_panel_layer_list:
#                       if l is None:
#                         # There is no data stored for this layer yet.
#                         # Maybe copy the entire nested list to a new layer?
#                         # But the Widget fields might take care of this anyway.
#                         # Pass for now.
#                         pass
#                       else:
#                         # Just set the values that should be identical
#                         l[page_index][row_index][item_index] = this_layers_data[page_index][row_index][item_index]
#               else:
#                 pass
#               item_index += 1
#             row_index += 1
#           page_index += 1


# class GenericWidget:
#     def __init__ ( self, text ):
#         self.text = text
#         self.widget = None
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class GenericField(GenericWidget):
#     def __init__ ( self, text, value, all_layers=0 ):
#         #super(None,self).__init__(text)
#         #super(GenericField,self).__init__(text)
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class TextField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return str(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class BoolField(GenericField):
#     """
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#         self.callback = callback
#         print_debug ( 20, "BoolField created with callback = " + str(self.callback) )
#     '''
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         super(BoolField,self).__init__( text, value, all_layers )
#         self.callback = callback
#     '''
#     """
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#         self.callback = callback
#         print_debug ( 20, "BoolField created with callback = " + str(self.callback) )
#
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return bool(self.widget.isChecked())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setChecked(value)
#         except:
#           pass


# class IntField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return int(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class FloatField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return float(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class CallbackButton(GenericWidget):
#     def __init__ ( self, text, callback ):
#         #super(CallbackButton,self).__init__(text)
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.callback = callback
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class ComboBoxControl(GenericWidget):
#     def __init__ ( self, choices ):
#         #super(CallbackButton,self).__init__(text)
#         self.choices = choices
#         self.widget = None
#     def get_value ( self ):
#         return self.widget.currentText()
#         # AttributeError: 'ComboBoxControl' object has no attribute 'widget'
#     def set_value ( self, value ):
#         print("ComboBoxControl.set_value ( " + str(value) + ")")
#         self.widget.setCurrentText(value)
#         #print ( "Setting value")
#         #__import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
#         pass


# def closeEvent(self, event):
#
#     quit_msg = "Are you sure you want to exit the program?"
#     reply = QMessageBox.question(self, 'Message',
#                      quit_msg, QMessageBox.Yes, QMessageBox.No)
#
#     if reply == QMessageBox.Yes:
#         event.accept()
#     else:
#         event.ignore()


# def define_scales_menu(self, scales_list):
#     print("Defining scales menu | MainWindow.define_scales_menu...")
#
#     # Set the Scales menu from this scales_list
#     mb = self.menuBar()
#     if not (mb is None):
#         for m in mb.children():
#             if type(m) == QMenu:
#                 text_label = ''.join(m.title().split('&'))
#                 if 'Scale' in text_label:
#                     print_debug(30, "Found Scale Menu")
#                     # Remove all the old actions:
#                     while len(m.actions()) > 0:
#                         m.removeAction(m.actions()[-1])
#                     # Add the new actions
#                     first = True
#                     for scale in sorted([get_scale_val(s) for s in scales_list]):
#                         item = QAction(str(scale), self)
#                         item.setCheckable(True)
#                         item.setChecked(first)
#                         self.action_groups['Scales'].addAction(item)
#                         item.triggered.connect(self.set_current_scale)
#                         m.addAction(item)
#                         first = False



# @Slot()
# def define_scales_callback(self):
#     print("Displaying define scales dialog...")
#
#     default_scales = ['1']
#
#     cur_scales = [ str(v) for v in sorted ( [ get_scale_val(s) for s in project_data['data']['scales'].keys() ] ) ]
#     if len(cur_s
#         default_scales = cur_scales
#
#     input_val, ok = QInputDialog().getText ( None, "Define Scales", "Current: "+str(' '.join(default_scales)), echo=QLineEdit.Normal, text=' '.join(default_scales) )
#     if ok:
#         self.set_scales_from_string ( input_val ) #scales
#
#     else:
#         print("Cancel: Scales not changed" )
#         return # Want to exit function if no scales are defined



# def generate_scales():
#     print('Generating scales | generate_scales...')
#
#     alignem.print_debug(10, "generate_scales inside alignem_swift called")
#     # main_win.status.showMessage("Generating Scales ...")
#
#     image_scales_to_run = [alignem.get_scale_val(s) for s in sorted(alignem.project_data['data']['scales'].keys())]
#
#     alignem.print_debug(40, "Create images at all scales: " + str(image_scales_to_run))
#
#     if (alignem.project_data['data']['destination_path'] == None) or (
#             len(alignem.project_data['data']['destination_path']) <= 0):
#
#         alignem.show_warning("Note", "Scales can not be generated without a destination (use File/Set Destination)")
#
#     else:
#
#         for scale in sorted(image_scales_to_run):
#
#             alignem.print_debug(70, "Creating images for scale " + str(scale))
#             # main_win.status.showMessage("Generating Scale " + str(scale) + " ...")
#
#             scale_key = str(scale)
#             if not 'scale_' in scale_key:
#                 scale_key = 'scale_' + scale_key
#
#             subdir_path = os.path.join(alignem.project_data['data']['destination_path'], scale_key)
#             scale_1_path = os.path.join(alignem.project_data['data']['destination_path'], 'scale_1')
#
#             create_project_structure_directories(subdir_path)
#
#             alignem.print_debug(70, "Begin creating images at each layer for key: " + str(scale_key))
#
#             for layer in alignem.project_data['data']['scales'][scale_key]['alignment_stack']:
#                 alignem.print_debug(40, "Generating images for layer: \"" + str(
#                     alignem.project_data['data']['scales'][scale_key]['alignment_stack'].index(layer)) + "\"")
#                 # Remove previously aligned images from panel ??
#
#                 # Copy (or link) the source images to the expected scale_key"/img_src" directory
#                 for role in layer['images'].keys():
#
#                     # Only copy files for roles "ref" and "base"
#
#                     if role in ['ref', 'base']:
#                         alignem.print_debug(40, "Generating images for role: \"" + role + "\"")
#                         base_file_name = layer['images'][role]['filename']
#                         if base_file_name != None:
#                             if len(base_file_name) > 0:
#                                 abs_file_name = os.path.abspath(base_file_name)
#                                 bare_file_name = os.path.split(abs_file_name)[1]
#                                 destination_path = os.path.abspath(alignem.project_data['data']['destination_path'])
#                                 outfile_name = os.path.join(destination_path, scale_key, 'img_src', bare_file_name)
#                                 if scale == 1:
#                                     if get_best_path(abs_file_name) != get_best_path(outfile_name):
#                                         # The paths are different so make the link
#                                         try:
#                                             alignem.print_debug(70, "UnLinking " + outfile_name)
#                                             os.unlink(outfile_name)
#                                         except:
#                                             alignem.print_debug(70, "Error UnLinking " + outfile_name)
#                                         try:
#                                             alignem.print_debug(70,
#                                                                 "Linking from " + abs_file_name + " to " + outfile_name)
#                                             os.symlink(abs_file_name, outfile_name)
#                                         except:
#                                             alignem.print_debug(5,
#                                                                 "Unable to link from " + abs_file_name + " to " + outfile_name)
#                                             alignem.print_debug(5, "Copying file instead")
#                                             # Not all operating systems allow linking for all users (Windows 10, for example, requires admin rights)
#                                             try:
#                                                 shutil.copy(abs_file_name, outfile_name)
#                                             except:
#                                                 alignem.print_debug(1,
#                                                                     "Unable to link or copy from " + abs_file_name + " to " + outfile_name)
#                                                 print_exception()
#                                 else:
#                                     try:
#                                         # Do the scaling
#                                         alignem.print_debug(70,
#                                                             "Copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#
#                                         if os.path.split(os.path.split(os.path.split(abs_file_name)[0])[0])[
#                                             1].startswith('scale_'):
#                                             # Convert the source from whatever scale is currently processed to scale_1
#                                             p, f = os.path.split(abs_file_name)
#                                             p, r = os.path.split(p)
#                                             p, s = os.path.split(p)
#                                             abs_file_name = os.path.join(p, 'scale_1', r, f)
#
#                                         img = align_swiftir.swiftir.scaleImage(
#                                             align_swiftir.swiftir.loadImage(abs_file_name), fac=scale)
#                                         align_swiftir.swiftir.saveImage(img, outfile_name)
#                                         # Change the base image for this scale to the new file
#                                         layer['images'][role]['filename'] = outfile_name
#                                     except:
#                                         alignem.print_debug(1,
#                                                             "Error copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#                                         print_exception()
#
#                                 # Update the Data Model with the new absolute file name. This replaces the originally opened file names
#                                 alignem.print_debug(40, "Original File Name: " + str(layer['images'][role]['filename']))
#                                 layer['images'][role]['filename'] = outfile_name
#                                 alignem.print_debug(40, "Updated  File Name: " + str(layer['images'][role]['filename']))
#     # main_win.status.showMessage("Done Generating Scales ...")


# # callbackbuttons
# # demo_bool = BoolField("Multiview Demo", False)
# # export_zarr_cb = CallbackButton("Export to Zarr", export_zarr)
# # neuroglancer_view_cb = CallbackButton("Neuroglancer View", neuroglancer_view)
# # #cname_type  = ComboBoxControl(['zstd  ', 'zlib  ', 'blosclz  ', 'lz4hc  ','gzip  '])
# # cname_type  = ComboBoxControl(['zstd  ', 'zlib  ', 'gzip  ',  'none' ])
# # # note - check for string comparison of 'none' later, do not add whitespace fill
# # clevel_val   = IntField("clevel (1-9):",5)
# # n_scales_val = IntField("scales:",4)
#
# link_stack_cb = CallbackButton('Link Stack', link_stack)
# # gen_scales_cb = CallbackButton('Gen Scales Ser', generate_scales)
# gen_scalesq_cb = CallbackButton('Gen Scales', generate_scales_queue)
# # gen_scales_opt_cb = CallbackButton('Gen Scales Opt', generate_scales_optimized)
# align_all_cb = CallbackButton('Align All', align_all_or_some)
# center_cb = CallbackButton('Center', center_all)
# align_fwd_cb = CallbackButton('Align Forward', align_forward)
# init_ref_app = ComboBoxControl(['Init Affine', 'Refine Affine', 'Apply Affine']) #affine
# #view_match_crop = ComboBoxControl(['View', 'Match', 'Crop'])
# #view_match_crop.set_value('View')
#
# # poly_order = IntField("Poly Order:", 0, 1)
#
# regen_aligned_cb = CallbackButton('Regenerate Aligned', regenerate_aligned)
# # num_fwd = IntField("#", 1, 1)
# jump_to_cb = CallbackButton('Jump To:', jump_to_layer)
# # jump_to_val = IntField("#", 0, 1)
# rem_algn_cb = CallbackButton('Remove Aligned', remove_aligned)
# # skip = BoolField("Skip", False) #skip
# # match_pt_mode = BoolField("Match",False)
# clear_match = CallbackButton("Clear Match", clear_match_points)
# progress_cb = CallbackButton('Prog Bar', run_progress)
# gen_scales_thread_cb = CallbackButton('Gen Scales (thread)', gen_scales_with_thread)
# link_stacks_cb = CallbackButton("Link All Stacks", link_all_stacks)
# debug_cb = CallbackButton('Debug', method_debug)
#
# clear_skips_cb = CallbackButton("Clear all Skips", clear_all_skips)
# skips_to_all_cb = CallbackButton('Skips -> All Scales', copy_skips_to_all_scales)
#
# refine_aff_cb = CallbackButton('Refine Affine', notyet) #affine
# apply_aff_cb = CallbackButton('Apply Affine', notyet) #affine
# # whitening_factor = FloatField('Whitening', -0.68)
# # win_scale_factor = FloatField('Initial SWIM Window', 0.8125)  # This was named "Window Scale Factor"
#
# # null_cafm_trends = BoolField("Null Bias", False)
# # use_bounding_rect = BoolField("Bounding Rect", False)


# control_model = [""]
# control_model = [
#     # Panes
#     [  # Begin first pane of rows
#         [
#             " ", gen_scalesq_cb,
#             " ", align_all_cb,
#             " ", poly_order,
#             " ", null_cafm_trends,
#             " ", use_bounding_rect,
#             " ", align_fwd_cb, num_fwd,
#             " ", jump_to_cb, jump_to_val,
#             " ", center_cb,
#             "    ", skip,
#             # "  ", match_pt_mode,
#             " ", view_match_crop,
#             " ", clear_match,
#             " "
#         ],
#         [
#             # "Test: ",
#             # gen_scales_thread_cb,
#             # " ", link_stack_cb,
#             " ", init_ref_app,
#             # " ", do_thing_cb,
#             # " ", refine_aff_cb,
#             # " ", apply_aff_cb,
#             " ", regen_aligned_cb,
#             " ", rem_algn_cb,
#             " ", whitening_factor,
#             " ", win_scale_factor,
#             " ", clear_skips_cb,
#             " ", skips_to_all_cb,
#             # " ", progress_cb,
#             # " ", debug_cb
#             " "
#         ],
#     ]
#


# class OldImageLibrary:
#     """A class containing multiple images keyed by their file name."""
#     def __init__ ( self ):
#         self._images = {}  # { image_key: { "task": task, "loading": bool, "loaded": bool, "image": image }
#         self.threaded_loading_enabled = True
#
#     def pathkey ( self, file_path ):
#         if file_path == None:
#             return None
#         return os.path.abspath(os.path.normpath(file_path))
#
#     def __str__ (self):
#         s = "ImageLibrary contains %d images\n" % len(self._images)
#         for k,v in self._images.items():
#             s += "  " + k + "\n"
#             s += "    loaded:  " + str(v['loaded']) + "\n"
#             s += "    loading: " + str(v['loading']) + "\n"
#             s += "    task:    " + str(v['task']) + "\n"
#             s += "    image:   " + str(v['image']) + "\n"
#
#         print_debug(4, s)
#         __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#         return ( "ImageLibrary contains ...")
#
#     def get_image_reference ( self, file_path ):
#         image_ref = None
#         real_norm_path = self.pathkey(file_path)
#         if real_norm_path != None:
#             # This is an actual path
#             if real_norm_path in self._images:
#                 # This file is already in the library ... it may be complete or still loading
#                 if self._images[real_norm_path]['loaded']:
#                     # The image is already loaded, so return it
#                     image_ref = self._images[real_norm_path]['image']
#                 elif self._images[real_norm_path]['loading']:
#                     # The image is still loading, so wait for it to complete
#                     self._images[real_norm_path]['task'].join()
#                     self._images[real_norm_path]['task'] = None
#                     self._images[real_norm_path]['loaded'] = True
#                     self._images[real_norm_path]['loading'] = False
#                     image_ref = self._images[real_norm_path]['image']
#                 else:
#                     print_debug ( 5, "  Load Warning for: \"" + str(real_norm_path) + "\"" )
#                     image_ref = self._images[real_norm_path]['image']
#             else:
#                 # The image is not in the library at all, so force a load now (and wait)
#                 print_debug ( 25, "  Forced load of image: \"" + str(real_norm_path) + "\"" )
#                 self._images[real_norm_path] = { 'image': QPixmap(real_norm_path), 'loaded': True, 'loading': False, 'task':None }
#                 image_ref = self._images[real_norm_path]['image']
#         return image_ref
#
#     def get_image_reference_if_loaded ( self, file_path ):
#         image_ref = None
#         real_norm_path = self.pathkey(file_path)
#         if real_norm_path != None:
#             # This is an actual path
#             if real_norm_path in self._images:
#                 # This file is already in the library ... it may be complete or still loading
#                 if self._images[real_norm_path]['loaded']:
#                     # The image is already loaded, so return it
#                     image_ref = self._images[real_norm_path]['image']
#                 elif self._images[real_norm_path]['loading']:
#                     # The image is still loading, so wait for it to complete
#                     self._images[real_norm_path]['task'].join()
#                     self._images[real_norm_path]['task'] = None
#                     self._images[real_norm_path]['loaded'] = True
#                     self._images[real_norm_path]['loading'] = False
#                     image_ref = self._images[real_norm_path]['image']
#                 else:
#                     print_debug ( 5, "  Load Warning for: \"" + str(real_norm_path) + "\"" )
#                     image_ref = self._images[real_norm_path]['image']
#         return image_ref
#
#
#     def remove_image_reference ( self, file_path ):
#         image_ref = None
#         if not (file_path is None):
#             real_norm_path = self.pathkey(file_path)
#             if real_norm_path in self._images:
#                 print_debug ( 50, "Unloading image: \"" + real_norm_path + "\"" )
#                 image_ref = self._images.pop(real_norm_path)['image']
#         # This returned value may not be valid when multi-threading is implemented
#         return image_ref
#
#     def queue_image_read ( self, file_path ):
#         real_norm_path = self.pathkey(file_path)
#         self._images[real_norm_path] = { 'image': None, 'loaded': False, 'loading': True, 'task':None }
#         t = threading.Thread ( target = load_image_worker, args = (real_norm_path,self._images[real_norm_path]) )
#         t.start()
#         self._images[real_norm_path]['task'] = t
#
#     def make_available ( self, requested ):
#         """
#         SOMETHING TO LOOK AT:
#
#         Note that the threaded loading sometimes loads the same image multiple
#         times. This may be due to an uncertainty about whether an image has been
#         scheduled for loading or not.
#
#         Right now, the current check is whether it is actually loaded before
#         scheduling it to be loaded. However, a load may be in progress from an
#         earlier request. This may cause images to be loaded multiple times.
#         """
#
#         print_debug ( 25, "make_available: " + str(sorted([str(s[-7:]) for s in requested])) )
#         already_loaded = set(self._images.keys())
#         normalized_requested = set ( [self.pathkey(f) for f in requested] )
#         need_to_load = normalized_requested - already_loaded
#         need_to_unload = already_loaded - normalized_requested
#         for f in need_to_unload:
#             self.remove_image_reference ( f )
#         for f in need_to_load:
#             if self.threaded_loading_enabled:
#                 self.queue_image_read ( f )   # Using this will enable threaded reading behavior
#             else:
#                 self.get_image_reference ( f )   # Using this will force sequential reading behavior
#
#         print_debug ( 25, "Library has " + str(len(self._images.keys())) + " images" )
#         # __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#
#     def remove_all_images ( self ):
#         keys = list(self._images.keys())
#         for k in keys:
#           self.remove_image_reference ( k )
#         self._images = {}
#
#     #tag What is OldImageLibrary?
#     def update ( self ):
#         print("Doing nothing | OldImageLibrary.update...")
#         # Do nothing - needed to be plug replacable with SmartImageLibrary
#         pass


# Using the Python version does not work because the Python 3 code can't
# # even be parsed by Python2. It could be dynamically compiled, or use the
# # alternate syntax, but that's more work than it's worth for now.
# if sys.version_info >= (3, 0):
#     if debug_level > 10: print ( "Python 3: Supports arbitrary arguments via print")
#     #def print_debug ( level, *ds ):
#     #  global debug_level
#     #  if level <= debug_level:
#     #    print ( *ds )
# else:
#     if debug_level > 10: print ("Python 2: Use default parameters for limited support of arbitrary arguments via print")


# def old_load_image_worker ( real_norm_path, image_dict ):
#     # Load the image
#     print_debug ( 50, "  load_image_worker started with: \"" + str(real_norm_path) + "\"" )
#     m = psutil.virtual_memory()
#     print_debug ( 50, "    memory available before loading = " + str(m.available) )
#     image_dict['image'] = QPixmap(real_norm_path)
#     image_dict['loaded'] = True
#     print_debug ( 50, "  load_image_worker finished for: \"" + str(real_norm_path) + "\"" )
#     print_debug ( 50, "    memory available after loading = " + str(m.available) )


    # @Slot()
    # def set_bg_color(self):
    #     c = QColorDialog.getColor()
    #     # print_debug ( 30, " Color = " + str(c) )
    #     self.image_panel.bg_color = c
    #     self.image_panel.update_multi_self()
    #     self.image_panel.repaint()
    #
    #     for p in self.panel_list:
    #         p.update_zpa_self()
    #         p.repaint()


    # @Slot()
    # def set_border_color(self):
    #     c = QColorDialog.getColor()
    #     self.image_panel.border_color = c
    #     self.image_panel.update_multi_self()
    #     self.image_panel.repaint()
    #     for p in self.panel_list:
    #         p.border_color = c
    #         p.update_zpa_self()
    #         p.repaint()