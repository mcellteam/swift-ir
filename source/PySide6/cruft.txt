# def get_code_mode():
#     print("Getting code mode...")
#     ### All of this code is just trying to find the right menu item for the "Use C Version" check box:
#     code_mode = 'python'
#     menubar = alignem.main_window.menu
#     menubar_items = [menubar.children()[x].title() for x in range(len(menubar.children())) if
#                      'title' in dir(menubar.children()[x])]
#     submenus = [menubar.children()[x] for x in range(len(menubar.children())) if
#                 'title' in dir(menubar.children()[x])]
#     alignem.print_debug(40, "Menubar contains: " + str(menubar_items))
#     setmenu_index = -1
#     for m in menubar_items:
#         if "Set" in m:
#             setmenu_index = menubar_items.index(m)
#     alignem.print_debug(40, "Set menu is item " + str(setmenu_index))
#     if setmenu_index >= 0:
#         set_menu = submenus[setmenu_index]
#         set_menu_actions = set_menu.actions()
#         use_c_version = None
#         for action in set_menu_actions:
#             if "Use C Version" in action.text():
#                 use_c_version = action
#                 break
#         if use_c_version != None:
#             if use_c_version.isChecked():
#                 code_mode = "c"
#     print("get_code_mode is returning: ", code_mode)
#     return (code_mode)


# @Slot()
# def set_current_scale(self, checked):
#     print("@Slot Setting current scale | MainWindow.set_current_scale...")
#     local_cur_scale = get_cur_scale()
#     print_debug ( 30, "Set current Scale to " + str(self.sender().text()) )
#     old_scale = local_cur_scale
#     new_scale = get_scale_key ( str ( self.sender().text() ) )
#     if self.view_change_callback != None:
#       leaving_layer = project_data['data']['current_layer']
#       entering_layer = project_data['data']['current_layer']
#       try:
#         # This guards against errors in "user code"
#         main_window.view_change_callback ( old_scale, new_scale, leaving_layer, entering_layer )
#       except:
#         print_debug ( 0, "Exception in set_current_scale: " + str(sys.exc_info()) )
#     local_cur_scale = new_scale
#     project_data['data']['current_scale'] = local_cur_scale
#     print_debug ( 30, "Set current_scale key to " + str(project_data['data']['current_scale']) )
#
#     image_library.update()
#
#     for p in self.panel_list:
#         p.update_zpa_self()
#     self.update_win_self()
#
#     self.reload_scales_combobox()
#
#     self.center_all_images() #center
#     self.update_win_self()


# @Slot()
# def generate_scales_callback(self):
#     print("@Slot Generating scales callback | MainWindow.generate_scales_callback...")
#     print_debug ( 5, "Generating scales is now handled via control panel buttons in subclass alignem_swift." )



# def set_selected_scale ( self, scale_str ):
#     print("!!! Setting selected scale | MainWindow.set_selected_scale...")
#     print("  scale_str = ", str(scale_str))
#     # Set the Scales menu from this scales_list
#     mb = self.menuBar()
#     if not (mb is None):
#       for m in mb.children():
#         if type(m) == QMenu:
#           text_label = ''.join(m.title().split('&'))
#           if 'Scale' in text_label:
#             print_debug ( 30, "Found Scale Menu" )
#             scale_to_match = int(str(project_data['data']['current_scale'].split('_')[1]))
#             print("  scale_to_match = ", scale_to_match)
#             for a in m.actions():
#               if int(a.text()) == scale_to_match:
#                 a.setChecked ( True )
#                 project_data['data']['current_scale'] = 'scale_' + str(scale_to_match)
#               else:
#                 a.setChecked ( False )
#
#     self.center_all_images() #center
#     self.update_win_self()
#
#     self.update_panels()
#     self.refresh_all()


# def bool_changed_callback ( state ):
#     global ignore_changes
#     print_debug ( 50, 100*'+' )
#     print_debug ( 2, "Bool changed to " + str(state) )
#     print_debug ( 2, "ignore_changes = " + str(ignore_changes))
#     print_debug ( 50, 100*'+' )
#     if not ignore_changes:
#         if main_window != None:
#             if main_window.view_change_callback != None:
#                 layer_num = 0
#                 if project_data != None:
#                     if 'data' in project_data:
#                         if 'current_layer' in project_data['data']:
#                             layer_num = project_data['data']['current_layer']
#                 ignore_changes = True
#                 main_window.view_change_callback ( None, None, layer_num, layer_num )
#                 ignore_changes = False


# class ControlPanelWidget(QWidget):
#     """A widget to hold all of the application data for an alignment method."""
#     def __init__(self, control_model=None):
#         super(ControlPanelWidget, self).__init__()
#         self.cm = control_model
#         #self.control_panel = QWidget()
#         self.control_panel_layout = QVBoxLayout()
#         self.setLayout(self.control_panel_layout)
#         #self.control_panel_layout.setContentsMargin(0) #pyside6
#         #self.control_panel_layout.setMargin(0) #pyside2
#         self.control_panel_layout.setSpacing(0)
#
#         if self.cm != None:
#             # Only show the first pane for now
#             rows = control_model[0]
#             print_debug ( 30, "Pane contains " + str(len(rows)) + " rows" )
#
#             for row in rows:
#               row_box = QWidget()
#               row_box_layout = QHBoxLayout()
#               #row_box_layout.setContentsMargin(2) #pyside6
#               #row_box_layout.setMargin(2) #pyside2
#               row_box_layout.setSpacing(2)
#               row_box.setLayout ( row_box_layout )
#               print_debug ( 30, "Row contains " + str(len(row)) + " items" )
#               for item in row:
#                   print_debug ( 30, "  Item is " + str(item) )
#                   if type(item) == type('a'):
#                       item_widget = QLabel ( str(item) )
#                       item_widget.setAlignment(Qt.AlignHCenter)
#                       row_box_layout.addWidget ( item_widget )
#                   elif type(item) == type([]):
#                       item_widget = QPushButton ( str(item[0]) )
#                       row_box_layout.addWidget ( item_widget )
#                   elif isinstance(item, BoolField):
#                       val_widget = ( QCheckBox ( str(item.text) ) )
#                       row_box_layout.addWidget ( val_widget )
#                       # Hard code a few special callbacks ...
#                       if item.text == "Null Bias":
#                           #val_widget.stateChanged.connect(null_bias_changed_callback)
#                           val_widget.clicked.connect(null_bias_changed_callback)
#                       elif item.text == "Bounding Rect":
#                           #val_widget.stateChanged.connect(bounding_rect_changed_callback)
#                           val_widget.clicked.connect(bounding_rect_changed_callback)
#                       elif item.text == "Skip":
#                           #val_widget.stateChanged.connect(skip_changed_callback)
#                           val_widget.clicked.connect(skip_changed_callback)
#                       else:
#                           #val_widget.stateChanged.connect(bool_changed_callback)
#                           val_widget.clicked.connect(bool_changed_callback)
#                       item.widget = val_widget
#                   elif isinstance(item, TextField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, IntField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, FloatField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, CallbackButton):
#                       item_widget = QPushButton ( str(item.text) )
#                       item_widget.clicked.connect ( item.callback )
#                       item.widget = item_widget
#                       row_box_layout.addWidget ( item_widget )
#                   elif isinstance (item, ComboBoxControl):
#                       item_widget = QComboBox()
#                       item_widget.addItems (item.choices)
#                       #item_widget.clicked.connect ( item.callback )
#                       item.widget = item_widget
#                       row_box_layout.addWidget ( item_widget )
#                   else:
#                       item_widget = QLineEdit ( str(item) )
#                       item_widget.setAlignment(Qt.AlignHCenter)
#                       row_box_layout.addWidget ( item_widget )
#               self.control_panel_layout.addWidget ( row_box )
#
#     def dump ( self ):
#         print_debug ( 1, "Control Panel:" )
#         for p in self.cm:
#           print_debug ( 1, "  Panel:" )
#           for r in p:
#             print_debug ( 1, "    Row:" )
#             for i in r:
#               print_debug ( 1, "      Item: " + str(i) )
#               print_debug ( 1, "          Subclass of GenericWidget: " + str(isinstance(i,GenericWidget)) )
#
#     def copy_self_to_data ( self ):
#         data = []
#         for p in self.cm:
#           new_panel = []
#           for r in p:
#             new_row = []
#             for i in r:
#               if isinstance(i,GenericWidget):
#                 # Store as a list to identify as a widget
#                 new_row.append ( [ i.get_value() ] )
#               else:
#                 # Store as static raw data
#                 # new_row.append ( i )  # This data is useless since it's set by the application
#                 new_row.append ( '' )   # Save an empty string as a place holder for static data
#             new_panel.append ( new_row )
#           data.append ( new_panel )
#         return data
#
#     def copy_data_to_self ( self, data ):
#         ip = 0
#         for p in self.cm:
#           panel = data[ip]
#           ip += 1
#           ir = 0
#           for r in p:
#             row = panel[ir]
#             ir += 1
#             ii = 0
#             for i in r:
#               item = row[ii]
#               ii += 1
#               if type(item) == type([]):
#                 # This was a widget
#                 i.set_value ( item[0] )
#               else:
#                 # Ignore static raw data
#                 pass
#
#     def distribute_all_layer_data ( self, control_panel_layer_list ):
#         # First make a copy of this widget's data
#         this_layers_data = self.copy_self_to_data()
#
#         # Search the widgets for those that should be identical across all layers
#         page_index = 0
#         for p in self.cm:
#           row_index = 0
#           for r in p:
#             item_index = 0
#             for i in r:
#               if isinstance(i,GenericWidget):
#                 if 'all_layers' in dir(i):
#                   if i.all_layers:
#                     # Store this value in all layers
#                     for l in control_panel_layer_list:
#                       if l is None:
#                         # There is no data stored for this layer yet.
#                         # Maybe copy the entire nested list to a new layer?
#                         # But the Widget fields might take care of this anyway.
#                         # Pass for now.
#                         pass
#                       else:
#                         # Just set the values that should be identical
#                         l[page_index][row_index][item_index] = this_layers_data[page_index][row_index][item_index]
#               else:
#                 pass
#               item_index += 1
#             row_index += 1
#           page_index += 1


# class GenericWidget:
#     def __init__ ( self, text ):
#         self.text = text
#         self.widget = None
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class GenericField(GenericWidget):
#     def __init__ ( self, text, value, all_layers=0 ):
#         #super(None,self).__init__(text)
#         #super(GenericField,self).__init__(text)
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class TextField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return str(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class BoolField(GenericField):
#     """
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#         self.callback = callback
#         print_debug ( 20, "BoolField created with callback = " + str(self.callback) )
#     '''
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         super(BoolField,self).__init__( text, value, all_layers )
#         self.callback = callback
#     '''
#     """
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#         self.callback = callback
#         print_debug ( 20, "BoolField created with callback = " + str(self.callback) )
#
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return bool(self.widget.isChecked())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setChecked(value)
#         except:
#           pass


# class IntField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return int(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class FloatField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return float(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class CallbackButton(GenericWidget):
#     def __init__ ( self, text, callback ):
#         #super(CallbackButton,self).__init__(text)
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.callback = callback
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class ComboBoxControl(GenericWidget):
#     def __init__ ( self, choices ):
#         #super(CallbackButton,self).__init__(text)
#         self.choices = choices
#         self.widget = None
#     def get_value ( self ):
#         return self.widget.currentText()
#         # AttributeError: 'ComboBoxControl' object has no attribute 'widget'
#     def set_value ( self, value ):
#         print("ComboBoxControl.set_value ( " + str(value) + ")")
#         self.widget.setCurrentText(value)
#         #print ( "Setting value")
#         #__import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
#         pass


# def closeEvent(self, event):
#
#     quit_msg = "Are you sure you want to exit the program?"
#     reply = QMessageBox.question(self, 'Message',
#                      quit_msg, QMessageBox.Yes, QMessageBox.No)
#
#     if reply == QMessageBox.Yes:
#         event.accept()
#     else:
#         event.ignore()


# def define_scales_menu(self, scales_list):
#     print("Defining scales menu | MainWindow.define_scales_menu...")
#
#     # Set the Scales menu from this scales_list
#     mb = self.menuBar()
#     if not (mb is None):
#         for m in mb.children():
#             if type(m) == QMenu:
#                 text_label = ''.join(m.title().split('&'))
#                 if 'Scale' in text_label:
#                     print_debug(30, "Found Scale Menu")
#                     # Remove all the old actions:
#                     while len(m.actions()) > 0:
#                         m.removeAction(m.actions()[-1])
#                     # Add the new actions
#                     first = True
#                     for scale in sorted([get_scale_val(s) for s in scales_list]):
#                         item = QAction(str(scale), self)
#                         item.setCheckable(True)
#                         item.setChecked(first)
#                         self.action_groups['Scales'].addAction(item)
#                         item.triggered.connect(self.set_current_scale)
#                         m.addAction(item)
#                         first = False



# @Slot()
# def define_scales_callback(self):
#     print("Displaying define scales dialog...")
#
#     default_scales = ['1']
#
#     cur_scales = [ str(v) for v in sorted ( [ get_scale_val(s) for s in project_data['data']['scales'].keys() ] ) ]
#     if len(cur_s
#         default_scales = cur_scales
#
#     input_val, ok = QInputDialog().getText ( None, "Define Scales", "Current: "+str(' '.join(default_scales)), echo=QLineEdit.Normal, text=' '.join(default_scales) )
#     if ok:
#         self.set_scales_from_string ( input_val ) #scales
#
#     else:
#         print("Cancel: Scales not changed" )
#         return # Want to exit function if no scales are defined



# def generate_scales():
#     print('Generating scales | generate_scales...')
#
#     alignem.print_debug(10, "generate_scales inside alignem_swift called")
#     # main_win.status.showMessage("Generating Scales ...")
#
#     image_scales_to_run = [alignem.get_scale_val(s) for s in sorted(alignem.project_data['data']['scales'].keys())]
#
#     alignem.print_debug(40, "Create images at all scales: " + str(image_scales_to_run))
#
#     if (alignem.project_data['data']['destination_path'] == None) or (
#             len(alignem.project_data['data']['destination_path']) <= 0):
#
#         alignem.show_warning("Note", "Scales can not be generated without a destination (use File/Set Destination)")
#
#     else:
#
#         for scale in sorted(image_scales_to_run):
#
#             alignem.print_debug(70, "Creating images for scale " + str(scale))
#             # main_win.status.showMessage("Generating Scale " + str(scale) + " ...")
#
#             scale_key = str(scale)
#             if not 'scale_' in scale_key:
#                 scale_key = 'scale_' + scale_key
#
#             subdir_path = os.path.join(alignem.project_data['data']['destination_path'], scale_key)
#             scale_1_path = os.path.join(alignem.project_data['data']['destination_path'], 'scale_1')
#
#             create_project_structure_directories(subdir_path)
#
#             alignem.print_debug(70, "Begin creating images at each layer for key: " + str(scale_key))
#
#             for layer in alignem.project_data['data']['scales'][scale_key]['alignment_stack']:
#                 alignem.print_debug(40, "Generating images for layer: \"" + str(
#                     alignem.project_data['data']['scales'][scale_key]['alignment_stack'].index(layer)) + "\"")
#                 # Remove previously aligned images from panel ??
#
#                 # Copy (or link) the source images to the expected scale_key"/img_src" directory
#                 for role in layer['images'].keys():
#
#                     # Only copy files for roles "ref" and "base"
#
#                     if role in ['ref', 'base']:
#                         alignem.print_debug(40, "Generating images for role: \"" + role + "\"")
#                         base_file_name = layer['images'][role]['filename']
#                         if base_file_name != None:
#                             if len(base_file_name) > 0:
#                                 abs_file_name = os.path.abspath(base_file_name)
#                                 bare_file_name = os.path.split(abs_file_name)[1]
#                                 destination_path = os.path.abspath(alignem.project_data['data']['destination_path'])
#                                 outfile_name = os.path.join(destination_path, scale_key, 'img_src', bare_file_name)
#                                 if scale == 1:
#                                     if get_best_path(abs_file_name) != get_best_path(outfile_name):
#                                         # The paths are different so make the link
#                                         try:
#                                             alignem.print_debug(70, "UnLinking " + outfile_name)
#                                             os.unlink(outfile_name)
#                                         except:
#                                             alignem.print_debug(70, "Error UnLinking " + outfile_name)
#                                         try:
#                                             alignem.print_debug(70,
#                                                                 "Linking from " + abs_file_name + " to " + outfile_name)
#                                             os.symlink(abs_file_name, outfile_name)
#                                         except:
#                                             alignem.print_debug(5,
#                                                                 "Unable to link from " + abs_file_name + " to " + outfile_name)
#                                             alignem.print_debug(5, "Copying file instead")
#                                             # Not all operating systems allow linking for all users (Windows 10, for example, requires admin rights)
#                                             try:
#                                                 shutil.copy(abs_file_name, outfile_name)
#                                             except:
#                                                 alignem.print_debug(1,
#                                                                     "Unable to link or copy from " + abs_file_name + " to " + outfile_name)
#                                                 print_exception()
#                                 else:
#                                     try:
#                                         # Do the scaling
#                                         alignem.print_debug(70,
#                                                             "Copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#
#                                         if os.path.split(os.path.split(os.path.split(abs_file_name)[0])[0])[
#                                             1].startswith('scale_'):
#                                             # Convert the source from whatever scale is currently processed to scale_1
#                                             p, f = os.path.split(abs_file_name)
#                                             p, r = os.path.split(p)
#                                             p, s = os.path.split(p)
#                                             abs_file_name = os.path.join(p, 'scale_1', r, f)
#
#                                         img = align_swiftir.swiftir.scaleImage(
#                                             align_swiftir.swiftir.loadImage(abs_file_name), fac=scale)
#                                         align_swiftir.swiftir.saveImage(img, outfile_name)
#                                         # Change the base image for this scale to the new file
#                                         layer['images'][role]['filename'] = outfile_name
#                                     except:
#                                         alignem.print_debug(1,
#                                                             "Error copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#                                         print_exception()
#
#                                 # Update the Data Model with the new absolute file name. This replaces the originally opened file names
#                                 alignem.print_debug(40, "Original File Name: " + str(layer['images'][role]['filename']))
#                                 layer['images'][role]['filename'] = outfile_name
#                                 alignem.print_debug(40, "Updated  File Name: " + str(layer['images'][role]['filename']))
#     # main_win.status.showMessage("Done Generating Scales ...")


# # callbackbuttons
# # demo_bool = BoolField("Multiview Demo", False)
# # export_zarr_cb = CallbackButton("Export to Zarr", export_zarr)
# # neuroglancer_view_cb = CallbackButton("Neuroglancer View", neuroglancer_view)
# # #cname_type  = ComboBoxControl(['zstd  ', 'zlib  ', 'blosclz  ', 'lz4hc  ','gzip  '])
# # cname_type  = ComboBoxControl(['zstd  ', 'zlib  ', 'gzip  ',  'none' ])
# # # note - check for string comparison of 'none' later, do not add whitespace fill
# # clevel_val   = IntField("clevel (1-9):",5)
# # n_scales_val = IntField("scales:",4)
#
# link_stack_cb = CallbackButton('Link Stack', link_stack)
# # gen_scales_cb = CallbackButton('Gen Scales Ser', generate_scales)
# gen_scalesq_cb = CallbackButton('Gen Scales', generate_scales_queue)
# # gen_scales_opt_cb = CallbackButton('Gen Scales Opt', generate_scales_optimized)
# align_all_cb = CallbackButton('Align All', align_all_or_some)
# center_cb = CallbackButton('Center', center_all)
# align_fwd_cb = CallbackButton('Align Forward', align_forward)
# init_ref_app = ComboBoxControl(['Init Affine', 'Refine Affine', 'Apply Affine']) #affine
# #view_match_crop = ComboBoxControl(['View', 'Match', 'Crop'])
# #view_match_crop.set_value('View')
#
# # poly_order = IntField("Poly Order:", 0, 1)
#
# regen_aligned_cb = CallbackButton('Regenerate Aligned', regenerate_aligned)
# # num_fwd = IntField("#", 1, 1)
# jump_to_cb = CallbackButton('Jump To:', jump_to_layer)
# # jump_to_val = IntField("#", 0, 1)
# rem_algn_cb = CallbackButton('Remove Aligned', remove_aligned)
# # skip = BoolField("Skip", False) #skip
# # match_pt_mode = BoolField("Match",False)
# clear_match = CallbackButton("Clear Match", clear_match_points)
# progress_cb = CallbackButton('Prog Bar', run_progress)
# gen_scales_thread_cb = CallbackButton('Gen Scales (thread)', gen_scales_with_thread)
# link_stacks_cb = CallbackButton("Link All Stacks", link_all_stacks)
# debug_cb = CallbackButton('Debug', method_debug)
#
# clear_skips_cb = CallbackButton("Clear all Skips", clear_all_skips)
# skips_to_all_cb = CallbackButton('Skips -> All Scales', copy_skips_to_all_scales)
#
# refine_aff_cb = CallbackButton('Refine Affine', notyet) #affine
# apply_aff_cb = CallbackButton('Apply Affine', notyet) #affine
# # whitening_factor = FloatField('Whitening', -0.68)
# # win_scale_factor = FloatField('Initial SWIM Window', 0.8125)  # This was named "Window Scale Factor"
#
# # null_cafm_trends = BoolField("Null Bias", False)
# # use_bounding_rect = BoolField("Bounding Rect", False)


# control_model = [""]
# control_model = [
#     # Panes
#     [  # Begin first pane of rows
#         [
#             " ", gen_scalesq_cb,
#             " ", align_all_cb,
#             " ", poly_order,
#             " ", null_cafm_trends,
#             " ", use_bounding_rect,
#             " ", align_fwd_cb, num_fwd,
#             " ", jump_to_cb, jump_to_val,
#             " ", center_cb,
#             "    ", skip,
#             # "  ", match_pt_mode,
#             " ", view_match_crop,
#             " ", clear_match,
#             " "
#         ],
#         [
#             # "Test: ",
#             # gen_scales_thread_cb,
#             # " ", link_stack_cb,
#             " ", init_ref_app,
#             # " ", do_thing_cb,
#             # " ", refine_aff_cb,
#             # " ", apply_aff_cb,
#             " ", regen_aligned_cb,
#             " ", rem_algn_cb,
#             " ", whitening_factor,
#             " ", win_scale_factor,
#             " ", clear_skips_cb,
#             " ", skips_to_all_cb,
#             # " ", progress_cb,
#             # " ", debug_cb
#             " "
#         ],
#     ]
#


# class OldImageLibrary:
#     """A class containing multiple images keyed by their file name."""
#     def __init__ ( self ):
#         self._images = {}  # { image_key: { "task": task, "loading": bool, "loaded": bool, "image": image }
#         self.threaded_loading_enabled = True
#
#     def pathkey ( self, file_path ):
#         if file_path == None:
#             return None
#         return os.path.abspath(os.path.normpath(file_path))
#
#     def __str__ (self):
#         s = "ImageLibrary contains %d images\n" % len(self._images)
#         for k,v in self._images.items():
#             s += "  " + k + "\n"
#             s += "    loaded:  " + str(v['loaded']) + "\n"
#             s += "    loading: " + str(v['loading']) + "\n"
#             s += "    task:    " + str(v['task']) + "\n"
#             s += "    image:   " + str(v['image']) + "\n"
#
#         print_debug(4, s)
#         __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#         return ( "ImageLibrary contains ...")
#
#     def get_image_reference ( self, file_path ):
#         image_ref = None
#         real_norm_path = self.pathkey(file_path)
#         if real_norm_path != None:
#             # This is an actual path
#             if real_norm_path in self._images:
#                 # This file is already in the library ... it may be complete or still loading
#                 if self._images[real_norm_path]['loaded']:
#                     # The image is already loaded, so return it
#                     image_ref = self._images[real_norm_path]['image']
#                 elif self._images[real_norm_path]['loading']:
#                     # The image is still loading, so wait for it to complete
#                     self._images[real_norm_path]['task'].join()
#                     self._images[real_norm_path]['task'] = None
#                     self._images[real_norm_path]['loaded'] = True
#                     self._images[real_norm_path]['loading'] = False
#                     image_ref = self._images[real_norm_path]['image']
#                 else:
#                     print_debug ( 5, "  Load Warning for: \"" + str(real_norm_path) + "\"" )
#                     image_ref = self._images[real_norm_path]['image']
#             else:
#                 # The image is not in the library at all, so force a load now (and wait)
#                 print_debug ( 25, "  Forced load of image: \"" + str(real_norm_path) + "\"" )
#                 self._images[real_norm_path] = { 'image': QPixmap(real_norm_path), 'loaded': True, 'loading': False, 'task':None }
#                 image_ref = self._images[real_norm_path]['image']
#         return image_ref
#
#     def get_image_reference_if_loaded ( self, file_path ):
#         image_ref = None
#         real_norm_path = self.pathkey(file_path)
#         if real_norm_path != None:
#             # This is an actual path
#             if real_norm_path in self._images:
#                 # This file is already in the library ... it may be complete or still loading
#                 if self._images[real_norm_path]['loaded']:
#                     # The image is already loaded, so return it
#                     image_ref = self._images[real_norm_path]['image']
#                 elif self._images[real_norm_path]['loading']:
#                     # The image is still loading, so wait for it to complete
#                     self._images[real_norm_path]['task'].join()
#                     self._images[real_norm_path]['task'] = None
#                     self._images[real_norm_path]['loaded'] = True
#                     self._images[real_norm_path]['loading'] = False
#                     image_ref = self._images[real_norm_path]['image']
#                 else:
#                     print_debug ( 5, "  Load Warning for: \"" + str(real_norm_path) + "\"" )
#                     image_ref = self._images[real_norm_path]['image']
#         return image_ref
#
#
#     def remove_image_reference ( self, file_path ):
#         image_ref = None
#         if not (file_path is None):
#             real_norm_path = self.pathkey(file_path)
#             if real_norm_path in self._images:
#                 print_debug ( 50, "Unloading image: \"" + real_norm_path + "\"" )
#                 image_ref = self._images.pop(real_norm_path)['image']
#         # This returned value may not be valid when multi-threading is implemented
#         return image_ref
#
#     def queue_image_read ( self, file_path ):
#         real_norm_path = self.pathkey(file_path)
#         self._images[real_norm_path] = { 'image': None, 'loaded': False, 'loading': True, 'task':None }
#         t = threading.Thread ( target = load_image_worker, args = (real_norm_path,self._images[real_norm_path]) )
#         t.start()
#         self._images[real_norm_path]['task'] = t
#
#     def make_available ( self, requested ):
#         """
#         SOMETHING TO LOOK AT:
#
#         Note that the threaded loading sometimes loads the same image multiple
#         times. This may be due to an uncertainty about whether an image has been
#         scheduled for loading or not.
#
#         Right now, the current check is whether it is actually loaded before
#         scheduling it to be loaded. However, a load may be in progress from an
#         earlier request. This may cause images to be loaded multiple times.
#         """
#
#         print_debug ( 25, "make_available: " + str(sorted([str(s[-7:]) for s in requested])) )
#         already_loaded = set(self._images.keys())
#         normalized_requested = set ( [self.pathkey(f) for f in requested] )
#         need_to_load = normalized_requested - already_loaded
#         need_to_unload = already_loaded - normalized_requested
#         for f in need_to_unload:
#             self.remove_image_reference ( f )
#         for f in need_to_load:
#             if self.threaded_loading_enabled:
#                 self.queue_image_read ( f )   # Using this will enable threaded reading behavior
#             else:
#                 self.get_image_reference ( f )   # Using this will force sequential reading behavior
#
#         print_debug ( 25, "Library has " + str(len(self._images.keys())) + " images" )
#         # __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#
#     def remove_all_images ( self ):
#         keys = list(self._images.keys())
#         for k in keys:
#           self.remove_image_reference ( k )
#         self._images = {}
#
#     #tag What is OldImageLibrary?
#     def update ( self ):
#         print("Doing nothing | OldImageLibrary.update...")
#         # Do nothing - needed to be plug replacable with SmartImageLibrary
#         pass


# Using the Python version does not work because the Python 3 code can't
# # even be parsed by Python2. It could be dynamically compiled, or use the
# # alternate syntax, but that's more work than it's worth for now.
# if sys.version_info >= (3, 0):
#     if debug_level > 10: print ( "Python 3: Supports arbitrary arguments via print")
#     #def print_debug ( level, *ds ):
#     #  global debug_level
#     #  if level <= debug_level:
#     #    print ( *ds )
# else:
#     if debug_level > 10: print ("Python 2: Use default parameters for limited support of arbitrary arguments via print")


# def old_load_image_worker ( real_norm_path, image_dict ):
#     # Load the image
#     print_debug ( 50, "  load_image_worker started with: \"" + str(real_norm_path) + "\"" )
#     m = psutil.virtual_memory()
#     print_debug ( 50, "    memory available before loading = " + str(m.available) )
#     image_dict['image'] = QPixmap(real_norm_path)
#     image_dict['loaded'] = True
#     print_debug ( 50, "  load_image_worker finished for: \"" + str(real_norm_path) + "\"" )
#     print_debug ( 50, "    memory available after loading = " + str(m.available) )



        # splash_button_size = QSize(200, 60)
        #
        # self.splash_documentation_button = QPushButton("Documentation")
        # self.splash_documentation_button.clicked.connect(documentation_view)
        # self.splash_documentation_button.setFixedSize(splash_button_size)
        #
        # self.splash_remote_viewer_button = QPushButton("Remote Viewer")
        # self.splash_remote_viewer_button.clicked.connect(remote_view)
        # self.splash_remote_viewer_button.setFixedSize(splash_button_size)
        #
        #
        # self.splash_open_project_button = QPushButton("Open Project")
        # self.splash_open_project_button.clicked.connect(self.open_project)
        # self.splash_open_project_button.setFixedSize(splash_button_size)
        #
        # self.splash_new_project_button = QPushButton("New Project")
        # self.splash_new_project_button.clicked.connect(self.new_project)
        # self.splash_new_project_button.setFixedSize(splash_button_size)
        #
        # self.splash_save_project_button = QPushButton("Save")
        # self.splash_save_project_button.clicked.connect(self.save_project)
        # self.splash_save_project_button.setFixedSize(splash_button_size)
        #
        # self.splash_save_project_as_button = QPushButton("Save As...")
        # self.splash_save_project_as_button.clicked.connect(self.save_project_as)
        # self.splash_save_project_as_button.setFixedSize(splash_button_size)
        #
        # self.splash_quit_app_button = QPushButton("Exit")
        # self.splash_quit_app_button.clicked.connect(self.close)
        # self.splash_quit_app_button.setFixedSize(splash_button_size)
        #
        # self.splash_debug_layer_button = QPushButton("Debug Layer")
        # self.splash_debug_layer_button.clicked.connect(debug_layer)
        # self.splash_debug_layer_button.setFixedSize(splash_button_size)
        #
        # self.splash_import_images_button = QPushButton("Import Images")
        # self.splash_import_images_button.clicked.connect(self.import_base_images)
        # self.splash_import_images_button.setFixedSize(splash_button_size)
        #
        # self.splash_functions_layout = QGridLayout()
        # self.splash_functions_layout.setContentsMargins(0, 0, 0, 0)
        # self.splash_functions_layout.addWidget(self.splash_documentation_button, 0, 0)
        # self.splash_functions_layout.addWidget(self.splash_remote_viewer_button, 0, 1)
        # self.splash_functions_layout.addWidget(self.splash_new_project_button, 1, 0)
        # self.splash_functions_layout.addWidget(self.splash_open_project_button, 1, 1)
        # self.splash_functions_layout.addWidget(self.splash_save_project_as_button, 2, 0)
        # self.splash_functions_layout.addWidget(self.splash_save_project_button, 2, 1)
        # self.splash_functions_layout.addWidget(self.splash_quit_app_button, 3, 0)
        # self.splash_functions_layout.addWidget(self.splash_import_images_button, 3, 1)
        # self.splash_panel = QWidget()
        # self.splash_panel.setLayout(self.splash_functions_layout)



# def align_forward():
#     print_debug(30, "Aligning Forward ...")




# def gen_scales_with_thread():
#     print('\nCalling generate_scales_with_thread() in alignem_swift.py:\n')
#
#     global gen_scales_dialog
#     if (alignem.project_data['data']['destination_path'] == None) or (
#             len(alignem.project_data['data']['destination_path']) <= 0):
#         alignem.show_warning("Note", "Scales cannot be generated without a destination. Please first 'Save Project As...'")
#     else:
#         alignem.print_debug(10, "Generating Scales with Progress Bar ...")
#         gen_scales_dialog = GenScalesDialog()
#         # main_win.status.showMessage("Done Generating Scales ...")



# def generate_scales_optimized():
#     print('Generating scales, optimized | generate_scales_optimized...')
#     alignem.print_debug(1, "generate_scales_optimized inside alignem_swift called")
#
#     image_scales_to_run = [alignem.get_scale_val(s) for s in sorted(alignem.project_data['data']['scales'].keys())]
#
#     alignem.print_debug(2, "Create images at all scales: " + str(image_scales_to_run))
#
#     if (alignem.project_data['data']['destination_path'] == None) or (
#             len(alignem.project_data['data']['destination_path']) <= 0):
#
#         alignem.show_warning("Note", "Scales cannot be generated without a destination. Please first 'Save Project As...'")
#
#     else:
#
#         ### Create the queue here
#         task_queue.DEBUG_LEVEL = alignem.DEBUG_LEVEL
#         task_wrapper.DEBUG_LEVEL = alignem.DEBUG_LEVEL
#         scaling_queue = task_queue.TaskQueue(sys.executable)
#         cpus = psutil.cpu_count(logical=False)
#         #    if cpus > 32:
#         #      cpus = 32
#         scaling_queue.start(cpus)
#         scaling_queue.notify = False
#         scaling_queue.passthrough_stdout = False
#         scaling_queue.passthrough_stderr = False
#
#         # Create a list of scaling jobs to be built by looping through scales and layers
#         scaling_jobs_by_input_file = {}
#
#         for scale in sorted(image_scales_to_run):
#
#             alignem.print_debug(70, "Creating images for scale " + str(scale))
#             # main_win.status.showMessage("Generating Scale " + str(scale) + " ...")
#
#             scale_key = str(scale)
#             if not 'scale_' in scale_key:
#                 scale_key = 'scale_' + scale_key
#
#             subdir_path = os.path.join(alignem.project_data['data']['destination_path'], scale_key)
#             scale_1_path = os.path.join(alignem.project_data['data']['destination_path'], 'scale_1')
#
#             create_project_structure_directories(subdir_path)
#
#             alignem.print_debug(70, "Begin creating images at each layer for key: " + str(scale_key))
#
#             layer_index = 0
#             for layer in alignem.project_data['data']['scales'][scale_key]['alignment_stack']:
#                 # if not layer_index in scaling_jobs_by_input_file:
#                 #  scaling_jobs_by_input_file[layer_index] = []
#
#                 alignem.print_debug(40, "Generating images for layer: \"" + str(
#                     alignem.project_data['data']['scales'][scale_key]['alignment_stack'].index(layer)) + "\"")
#                 # Remove previously aligned images from panel ??
#
#                 # Copy (or link) the source images to the expected scale_key"/img_src" directory
#                 for role in layer['images'].keys():
#
#                     # Only copy files for roles "ref" and "base"
#
#                     if role in ['ref', 'base']:
#                         alignem.print_debug(40, "Generating images for role: \"" + role + "\"")
#                         base_file_name = layer['images'][role]['filename']
#                         if base_file_name != None:
#                             if len(base_file_name) > 0:
#                                 abs_file_name = os.path.abspath(base_file_name)
#                                 bare_file_name = os.path.split(abs_file_name)[1]
#                                 destination_path = os.path.abspath(alignem.project_data['data']['destination_path'])
#                                 outfile_name = os.path.join(destination_path, scale_key, 'img_src', bare_file_name)
#                                 if scale == 1:
#                                     # Make links or copy immediately without creating a job
#                                     if get_best_path(abs_file_name) != get_best_path(outfile_name):
#                                         # The paths are different so make the link
#                                         try:
#                                             alignem.print_debug(70, "UnLinking " + outfile_name)
#                                             os.unlink(outfile_name)
#                                         except:
#                                             alignem.print_debug(70, "Error UnLinking " + outfile_name)
#                                         try:
#                                             alignem.print_debug(70,
#                                                                 "Linking from " + abs_file_name + " to " + outfile_name)
#                                             os.symlink(abs_file_name, outfile_name)
#                                         except:
#                                             alignem.print_debug(5,
#                                                                 "Unable to link from " + abs_file_name + " to " + outfile_name)
#                                             alignem.print_debug(5, "Copying file instead")
#                                             # Not all operating systems allow linking for all users (Windows 10, for example, requires admin rights)
#                                             try:
#                                                 shutil.copy(abs_file_name, outfile_name)
#                                             except:
#                                                 alignem.print_debug(1,
#                                                                     "Unable to link or copy from " + abs_file_name + " to " + outfile_name)
#                                                 print_exception()
#                                 else:
#                                     try:
#                                         # Do the scaling
#                                         alignem.print_debug(70,
#                                                             "Copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#
#                                         if os.path.split(os.path.split(os.path.split(abs_file_name)[0])[0])[
#                                             1].startswith('scale_'):
#                                             # Convert the source from whatever scale is currently processed to scale_1
#                                             p, f = os.path.split(abs_file_name)
#                                             p, r = os.path.split(p)
#                                             p, s = os.path.split(p)
#                                             abs_file_name = os.path.join(p, 'scale_1', r, f)
#
#                                         ### Add this job to the task queue or job list
#                                         if not (abs_file_name in scaling_jobs_by_input_file.keys()):
#                                             scaling_jobs_by_input_file[abs_file_name] = []
#                                         scaling_jobs_by_input_file[abs_file_name].append(
#                                             {'scale': scale, 'target': outfile_name})
#                                         # __import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
#                                         # scaling_queue.add_task (cmd=sys.executable, args=['single_scale_job.py', str (scale), str (abs_file_name), str(outfile_name)], wd='.')
#                                         # These two lines generate the scales directly rather than through the queue
#                                         # img = align_swiftir.swiftir.scaleImage ( align_swiftir.swiftir.loadImage(abs_file_name), fac=scale )
#                                         # align_swiftir.swiftir.saveImage ( img, outfile_name )
#
#                                         # Change the base image for this scale to the new file
#                                         layer['images'][role]['filename'] = outfile_name
#                                     except:
#                                         alignem.print_debug(1,
#                                                             "Error copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#                                         print_exception()
#
#                                 # Update the Data Model with the new absolute file name. This replaces the originally opened file names
#                                 alignem.print_debug(40, "Original File Name: " + str(layer['images'][role]['filename']))
#                                 layer['images'][role]['filename'] = outfile_name
#                                 alignem.print_debug(40, "Updated  File Name: " + str(layer['images'][role]['filename']))
#
#                 layer_index += 1
#
#         print("Jobs to Scale: " + str(scaling_jobs_by_input_file))
#         print()
#         job_keys = sorted(scaling_jobs_by_input_file.keys())
#         for k in job_keys:
#             print(" Scaling " + str(k))
#             arg_list = ['multi_scale_job.py', k]
#             for s in scaling_jobs_by_input_file[k]:
#                 arg_list.append(str(s['scale']))
#                 arg_list.append(str(s['target']))
#             scaling_queue.add_task(cmd=sys.executable, args=arg_list, wd='.')
#
#         ### Join the queue here to ensure that all have been generated before returning
#         alignem.print_debug(1, "Waiting for TaskQueue.join to return")
#         scaling_queue.work_q.join()  # It might be better to have a TaskQueue.join method to avoid knowing "inside details" of class
#
#         scaling_queue.shutdown()
#         del scaling_queue
#     print("Exiting generate_scales_optimized()")
#
#     # main_win.status.showMessage("Done Generating Scales ...")



#
#
# def view_change_callback(prev_scale_key, next_scale_key, prev_layer_num, next_layer_num, new_data_model=False):
#     print('view_change_callback | called by ' + inspect.stack()[1].function)
#     # print("  Changing from scale,layer " + str((prev_scale_key, prev_layer_num)) + " to " + str((next_scale_key, next_layer_num)))
#     print('prev_scale_key=%s,next_scale_key=%s, prev_layer_num=%s, next_layer_num=%s' % (prev_scale_key, next_scale_key, prev_layer_num, next_layer_num))
#
#
#     if alignem.project_data != None:
#
#         copy_from_widgets_to_data_model = True
#         copy_from_data_model_to_widgets = False #0503
#
#
#         # making false, instead will use new function main_window.read_project_data_update_gui() (call from change_layer directly)
#         # copy_from_widgets_to_data_model = False
#         # copy_from_data_model_to_widgets = False
#
#         if new_data_model:
#             # Copy all data from the data model into the widgets, ignoring what's in the widgets
#             # But don't copy from the widgets to the data model
#             copy_from_widgets_to_data_model = False
#         elif (prev_scale_key == None) or (next_scale_key == None):
#             # None signals a button change and not an actual layer or scale change
#             # Copy all of the data from the widgets into the data model
#             # But don't copy from the data model to the widgets
#             copy_from_data_model_to_widgets = False
#
#         # Set up convenient prev and next layer references
#         prev_layer = None
#         next_layer = None
#         if prev_scale_key in alignem.project_data['data']['scales']:
#             if prev_layer_num in range(len(alignem.project_data['data']['scales'][prev_scale_key]['alignment_stack'])):
#                 prev_layer = alignem.project_data['data']['scales'][prev_scale_key]['alignment_stack'][prev_layer_num]
#         if next_scale_key in alignem.project_data['data']['scales']:
#             if next_layer_num in range(len(alignem.project_data['data']['scales'][next_scale_key]['alignment_stack'])):
#                 next_layer = alignem.project_data['data']['scales'][next_scale_key]['alignment_stack'][next_layer_num]
#
#         # Begin the copying
#
#         # *****************************************************************
#         # First copy from the widgets to the previous data model if desired
#         # *****************************************************************
#         if copy_from_widgets_to_data_model:
#             print('view_change_callback | writing changes from UI to data model')
#             # Start with the scale-level items
#
#             # Build any scale-level structures that might be needed
#             if not 'method_data' in alignem.project_data['data']['scales'][prev_scale_key]:
#                 alignem.project_data['data']['scales'][prev_scale_key]['method_data'] = {}
#
#             # Copy the scale-level data
#             # alignem.project_data['data']['scales'][prev_scale_key]['null_cafm_trends'] = make_bool(null_cafm_trends.get_value())
#             # alignem.project_data['data']['scales'][prev_scale_key]['use_bounding_rect'] = make_bool(use_bounding_rect.get_value())
#             # alignem.project_data['data']['scales'][prev_scale_key]['poly_order'] = poly_order.get_value()
#
#             #0405 #hardcode whatever values
#             #todo #0406 NEED BIAS CONTROL i.e.
#             # bias controls: CUMULATIVE AFFINE MATRIX CHECKBOX, POLY ORDER
#             # NEED ALL 3 OF THESE, BOUNDING RECTANGLE LAST
#             # NOTE: THESE SETTINGS AFFECT HOW ALIGNED IMAGES ARE DISPLAYED (ALIGNMENT DOES NOT CHANGE)
#             # alignem.project_data['data']['scales'][prev_scale_key]['null_cafm_trends'] = False
#             # alignem.project_data['data']['scales'][prev_scale_key]['poly_order'] = int(0)
#             # alignem.project_data['data']['scales'][prev_scale_key]['use_bounding_rect'] = False
#
#             # alignem.project_data['data']['scales'][prev_scale_key]['null_cafm_trends'] = alignem.main_window.get_null_bias_state()
#
#             alignem.project_data['data']['scales'][prev_scale_key]['poly_order'] = alignem.main_window.get_null_bias_value()
#             alignem.project_data['data']['scales'][prev_scale_key]['use_bounding_rect'] = alignem.main_window.get_bounding_state()
#
#
#             # @Slot()
#             # def get_bounding_state(self) -> bool:
#             #     return float(self.toggle_bounding_rect.isChecked())
#             #
#             # @Slot()
#             # def get_null_bias_state(self) -> bool:
#             #     return float(self.toggle_cafm.isChecked())
#
#
#             alignem.print_debug(25, "In DM: Null Bias = " + str(
#                 alignem.project_data['data']['scales'][prev_scale_key]['null_cafm_trends']))
#
#             alignem.print_debug(25, "In DM: Use Bound = " + str(
#                 alignem.project_data['data']['scales'][prev_scale_key]['use_bounding_rect']))
#
#             alignem.project_data['data']['scales'][prev_scale_key]['method_data']['alignment_option'] = alignem.main_window.get_affine_combobox()
#
#             # Next copy the layer-level items
#             if prev_layer != None:
#
#                 # Build any layer-level structures that might be needed in the data model
#                 if not 'align_to_ref_method' in prev_layer:
#                     prev_layer['align_to_ref_method'] = {}
#                 if not 'method_data' in prev_layer['align_to_ref_method']:
#                     prev_layer['align_to_ref_method']['method_data'] = {}
#
#                 # Copy the layer-level data
#                 # prev_layer['skip'] = make_bool(skip.get_value()) #skip
#                 # prev_layer['skip'] = alignem.main_window.toggle_skip.isChecked() #no longer necessary
#                 # prev_layer['align_to_ref_method']['method_data'][
#                 #     'whitening_factor'] = alignem.main_window.whitening_input.text
#                 # prev_layer['align_to_ref_method']['method_data'][
#                 #     'win_scale_factor'] = alignem.main_window.swim_input.text
#                 prev_layer['align_to_ref_method']['method_data']['whitening_factor'] = float(alignem.main_window.get_whitening_input())
#                 prev_layer['align_to_ref_method']['method_data']['win_scale_factor'] = float(alignem.main_window.get_swim_input())
#
#         # *****************************************************************
#         # Second copy from the data model to the widgets if desired (check each along the way)
#         # *****************************************************************
#         # SET TO FALSE #0503.. new function main_window.read_project_data_update_gui() will accomplish this,
#         # and will be called directly from MainWindow.change_layer
#         if copy_from_data_model_to_widgets:
#             print('view_change_callback | writing changes from data model to UI')
#             alignem.ignore_changes = True  # tag #odd
#
#             #0503 THIS DOES NOT WORK, THINKING UPDATE of GUI ELEMENTS UPON LAYER CHANGE NEEDS TO HAPPEN IN 'change_layer'
#             # try:
#             #     # alignem.main_win.toggle_skip.setChecked(not scale['alignment_stack'][project_data['data']['current_layer']]['skip'])
#             #     # main_window.update_skip_toggle()
#             #     # main_win.update_skip_toggle()
#             #     print('\nTrying alignem.main_window.update_skip_toggle()...\n')
#             #     alignem.main_window.update_skip_toggle()
#             # except:
#             #     print('view_change_callback | WARNING | skip toggle switch UI element failed to update its state')
#
#             # Start with the scale-level items
#             #0405 #0503 - commented the 6 line below out b/c 'NameError: name 'null_cafm_trends' is not defined
#             # if 'null_cafm_trends' in alignem.project_data['data']['scales'][next_scale_key]:
#             #     null_cafm_trends.set_value(alignem.project_data['data']['scales'][next_scale_key]['null_cafm_trends'])
#             # if 'use_bounding_rect' in alignem.project_data['data']['scales'][next_scale_key]:
#             #     use_bounding_rect.set_value(alignem.project_data['data']['scales'][next_scale_key]['use_bounding_rect'])
#             #jy-remove-x
#             # if 'poly_order' in alignem.project_data['data']['scales'][next_scale_key]:
#             #     poly_order.set_value(alignem.project_data['data']['scales'][next_scale_key]['poly_order'])
#
#             # affine #combobox
#             if 'method_data' in alignem.project_data['data']['scales'][next_scale_key]:
#                 # if 'alignment_option' in alignem.project_data['data']['scales'][next_scale_key]['method_data']:
#                 #     new_option = alignem.project_data['data']['scales'][next_scale_key]['method_data']['alignment_option']
#                 #     init_ref_app.set_value(dm_name_to_combo_name[new_option])
#
#                 if 'alignment_option' in alignem.project_data['data']['scales'][next_scale_key]['method_data']:
#                     new_option = alignem.project_data['data']['scales'][next_scale_key]['method_data'][
#                         'alignment_option']
#                     # init_ref_app.set_value(dm_name_to_combo_name[new_option])
#                     print('  Setting affine_combobox: ' + dm_name_to_combo_name[new_option])
#                     alignem.main_window.affine_combobox.setCurrentText(dm_name_to_combo_name[new_option])
#
#             # Next copy the layer-level items
#
#             if next_layer != None:  # next_layer refers to the current layer
#                 # print('  next_layer = ',next_layer)
#                 # Copy the layer-level data
#                 # print("  Evaluating: if 'skip' in next_layer ")
#                 if 'skip' in next_layer:
#                     # print("=> True")
#                     # #skip.set_value(next_layer['skip']) #skip
#                     # print("    alignem.main_window.toggle_skip.isChecked() => ", alignem.main_window.toggle_skip.isChecked())
#                     # print("    Possibly setting checked state of toggle_skip...")
#                     # print("    Evaluating: not bool(next_layer['skip']) => ", next_layer['skip'])
#                     # #alignem.main_window.toggle_skip.setChecked(not bool(next_layer['skip'])) #toggle #toggleskip #setchecked #checked
#                     # print("    alignem.main_window.toggle_skip.isChecked() = ", alignem.main_window.toggle_skip.isChecked())
#
#                     # print("  next_layer['skip'] = ", next_layer['skip']) # <- last code removed
#                     pass
#
#                     # alignem.main_window.toggle_skip.setChecked(not bool(next_layer['skip']))
#
#                     # skip.set_value(next_layer['skip']) #original
#
#                 if 'align_to_ref_method' in next_layer:
#                     if 'method_data' in next_layer['align_to_ref_method']:
#                         if 'whitening_factor' in next_layer['align_to_ref_method']['method_data']:
#                             # print("  next_layer['align_to_ref_method']['method_data']['whitening_factor'] = ", next_layer['align_to_ref_method']['method_data']['whitening_factor'])
#                             print("  Setting 'whitening_input': " + str(
#                                 next_layer['align_to_ref_method']['method_data']['whitening_factor']))
#                             # whitening_factor.set_value(next_layer['align_to_ref_method']['method_data']['whitening_factor'])
#                             alignem.main_window.whitening_input.setText(
#                                 str(next_layer['align_to_ref_method']['method_data']['whitening_factor']))
#                         if 'win_scale_factor' in next_layer['align_to_ref_method']['method_data']:
#                             print("  Setting 'swim_input': " + str(
#                                 (next_layer['align_to_ref_method']['method_data']['win_scale_factor'])))
#                             alignem.main_window.swim_input.setText(
#                                 str(next_layer['align_to_ref_method']['method_data']['win_scale_factor']))
#
#             alignem.ignore_changes = False
#     else:
#         print('view_change_callback | EXCEPTION | alignem.project_data not found')
#
#     # # THIS MIGHT NOT BE THE BEST PLACE FOR THIS, ARBITRARY LOCATION
#     # scale = alignem.project_data['data']['scales'][alignem.project_data['data']['current_scale']]
#     # layer = scale['alignment_stack'][alignem.project_data['data']['current_layer']]
#     # alignem.main_window.whitening_input.setText(str(
#     #     scale['alignment_stack'][alignem.project_data['data']['current_layer']]['align_to_ref_method'][
#     #         'method_data'][
#     #         'whitening_factor']))
#     # alignem.main_window.swim_input.setText(str(
#     #     scale['alignment_stack'][alignem.project_data['data']['current_layer']]['align_to_ref_method'][
#     #         'method_data'][
#     #         'win_scale_factor']))
#
#     print("view_change_callback | {}, layer {}  --> {}, layer {}".format(prev_scale_key, prev_layer_num, next_scale_key,next_layer_num))
#     # print("view_change_callback has completed.\n")
#
#     # print('view_change_callback | updating skip toggle switch')
#     # try:
#     #     # alignem.main_win.toggle_skip.setChecked(not scale['alignment_stack'][project_data['data']['current_layer']]['skip'])
#     #     alignem.main_win.update_skip_toggle()
#     # except:
#     #     print('ZoomPanWidget.mouseMoveEvent | WARNING | unable to set checked state of toggle switch')




# class GenScalesDialog(QDialog):
#     """
#     Simple dialog that consists of a Progress Bar.
#     """
#
#     def __init__(self):
#         super().__init__()
#         print("GenScalesDialog constructor called")
#         self.initUI()
#
#     def initUI(self):
#         self.setWindowTitle('Generating Scales')
#         self.progress = QProgressBar(self)
#         self.progress.setGeometry(0, 0, 300, 25)
#
#         total_images_to_scale = 0
#         image_scales_to_run = [alignem.get_scale_val(s) for s in sorted(alignem.project_data['data']['scales'].keys())]
#         for scale in image_scales_to_run:
#             scale_key = str(scale)
#             if not 'scale_' in scale_key:
#                 scale_key = 'scale_' + scale_key
#             total_images_to_scale += len(alignem.project_data['data']['scales'][scale_key]['alignment_stack'])
#         if total_images_to_scale <= 1:
#             total_images_to_scale = 1
#         print('Total images to scale = ' + str(total_images_to_scale))
#
#         self.progress.setMaximum(total_images_to_scale)
#
#         # self.button = QPushButton('Start', self)
#         # self.button.move(0, 30)
#
#         self.setModal(True)
#         self.show()
#         self.calc = GenScalesThread()
#         self.calc.countChanged.connect(self.onCountChanged)
#         self.calc.start()
#
#     def onCountChanged(self, value):
#         self.progress.setValue(value)


# class GenScalesThread(QThread):
#     countChanged = Signal(int)
#
#     def run(self):
#         print('GenScalesThread constructor called')
#         # Note: all printed output has been suppressed for testing
#         # alignem.print_debug ( 10, "GenScalesThread.run inside alignem_swift called" )
#         # main_win.status.showMessage("Generating Scales ...")
#
#         count = 0
#
#         image_scales_to_run = [alignem.get_scale_val(s) for s in sorted(alignem.project_data['data']['scales'].keys())]
#
#         # alignem.print_debug ( 40, "Create images at all scales: " + str ( image_scales_to_run ) )
#
#         for scale in sorted(image_scales_to_run):
#
#             # alignem.print_debug ( 70, "Creating images for scale " + str(scale) )
#             # main_win.status.showMessage("Generating Scale " + str(scale) + " ...")
#
#             scale_key = str(scale)
#             if not 'scale_' in scale_key:
#                 scale_key = 'scale_' + scale_key
#
#             subdir_path = os.path.join(alignem.project_data['data']['destination_path'], scale_key)
#             scale_1_path = os.path.join(alignem.project_data['data']['destination_path'], 'scale_1')
#
#             create_project_structure_directories(subdir_path)
#
#             for layer in alignem.project_data['data']['scales'][scale_key]['alignment_stack']:
#                 # Remove previously aligned images from panel ??
#
#                 # Copy (or link) the source images to the expected scale_key"/img_src" directory
#                 for role in layer['images'].keys():
#
#                     # Update the counter for the progress bar and emit the signal to update
#                     count += 1
#                     self.countChanged.emit(count)
#
#                     # Only copy files for roles "ref" and "base"
#                     # if role in ['ref', 'base']:
#                     if role in ['base']:
#
#                         base_file_name = layer['images'][role]['filename']
#                         if base_file_name != None:
#                             if len(base_file_name) > 0:
#                                 abs_file_name = os.path.abspath(base_file_name)
#                                 bare_file_name = os.path.split(abs_file_name)[1]
#                                 destination_path = os.path.abspath(alignem.project_data['data']['destination_path'])
#                                 outfile_name = os.path.join(destination_path, scale_key, 'img_src', bare_file_name)
#                                 if scale == 1:
#                                     if get_best_path(abs_file_name) != get_best_path(outfile_name):
#                                         # The paths are different so make the link
#                                         try:
#                                             # alignem.print_debug ( 70, "UnLinking " + outfile_name )
#                                             os.unlink(outfile_name)
#                                         except:
#                                             # alignem.print_debug ( 70, "Error UnLinking " + outfile_name )
#                                             pass
#                                         try:
#                                             # alignem.print_debug ( 70, "Linking from " + abs_file_name + " to " + outfile_name )
#                                             os.symlink(abs_file_name, outfile_name)
#                                         except:
#                                             # alignem.print_debug ( 5, "Unable to link from " + abs_file_name + " to " + outfile_name )
#                                             # alignem.print_debug ( 5, "Copying file instead" )
#                                             # Not all operating systems allow linking for all users (Windows 10, for example, requires admin rights)
#                                             try:
#                                                 shutil.copy(abs_file_name, outfile_name)
#                                             except:
#                                                 # alignem.print_debug ( 1, "Unable to link or copy from " + abs_file_name + " to " + outfile_name )
#                                                 print_exception()
#                                 else:
#                                     try:
#                                         # Do the scaling
#                                         # alignem.print_debug ( 70, "Copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(scale) )
#
#                                         if os.path.split(os.path.split(os.path.split(abs_file_name)[0])[0])[
#                                             1].startswith('scale_'):
#                                             # Convert the source from whatever scale is currently processed to scale_1
#                                             p, f = os.path.split(abs_file_name)
#                                             p, r = os.path.split(p)
#                                             p, s = os.path.split(p)
#                                             abs_file_name = os.path.join(p, 'scale_1', r, f)
#
#                                         img = align_swiftir.swiftir.scaleImage(
#                                             align_swiftir.swiftir.loadImage(abs_file_name), fac=scale)
#                                         align_swiftir.swiftir.saveImage(img, outfile_name)
#                                         # Change the base image for this scale to the new file
#                                         layer['images'][role]['filename'] = outfile_name
#                                     except:
#                                         # alignem.print_debug ( 1, "Error copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(scale) )
#                                         # print_exception()
#                                         pass
#
#                                 # Update the Data Model with the new absolute file name. This replaces the originally opened file names
#                                 # alignem.print_debug ( 40, "Original File Name: " + str(layer['images'][role]['filename']) )
#                                 layer['images'][role]['filename'] = outfile_name
#                                 # alignem.print_debug ( 40, "Updated  File Name: " + str(layer['images'][role]['filename']) )
#         # main_win.status.showMessage("Done Generating Scales")


# gen_scales_dialog = None


# def jump_to_layer():
#     print('Jumping to layer | jump_to_layer...')
#     requested_layer = jump_to_val.get_value()
#     alignem.print_debug(3, "Jump to layer " + str(requested_layer))
#     num_layers = len(alignem.project_data['data']['scales'][getCurScale()]['alignment_stack'])
#     if requested_layer >= num_layers:  # Limit to largest
#         requested_layer = num_layers - 1
#     if requested_layer < 0:  # Consider negative values as indexes from the end
#         requested_layer = num_layers + requested_layer
#     if requested_layer < 0:  # If the end index was greater than the length, just show 0
#         requested_layer = 0
#     alignem.project_data['data']['current_layer'] = requested_layer
#     main_win.image_panel.update_multi_self()



# def link_stack_orig():
#     print('Linking stack, original | link_stack_orig...')
#
#     alignem.print_debug(10, "Linking stack")
#
#     ref_image_stack = []
#     for layer_index in range(len(alignem.project_data['data']['scales'][getCurScale()]['alignment_stack'])):
#         if layer_index == 0:
#             main_win.add_empty_to_role('ref')
#         else:
#             # layer = alignem.project_data['data']['scales'][getCurScale()]['alignment_stack'][layer_index]
#             prev_layer = alignem.project_data['data']['scales'][getCurScale()]['alignment_stack'][
#                 layer_index - 1]
#             fn = ""
#             if 'base' in prev_layer['images'].keys():
#                 fn = prev_layer['images']['base']['filename']
#             main_win.add_image_to_role(fn, 'ref')
#
#     alignem.print_debug(50, "Loading images: " + str(ref_image_stack))
#     # main_win.load_images_in_role ( 'ref', ref_image_stack )
#
#     main_win.update_panels()
#     # __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#     print('Exiting link_stack_orij()')



# def get_file_io_mode():
#     print('Getting file IO mode | get_file_io_mode...')
#     ### All of this code is just trying to find the right menu item for the "Use File I/O" check box:
#     file_io_mode = False
#     menubar = alignem.main_window.menu
#     menubar_items = [menubar.children()[x].title() for x in range(len(menubar.children())) if
#                      'title' in dir(menubar.children()[x])]
#     submenus = [menubar.children()[x] for x in range(len(menubar.children())) if 'title' in dir(menubar.children()[x])]
#     alignem.print_debug(40, "Menubar contains: " + str(menubar_items))
#     setmenu_index = -1
#     for m in menubar_items:
#         if "Set" in m:
#             setmenu_index = menubar_items.index(m)
#     alignem.print_debug(40, "Set menu is item " + str(setmenu_index))
#     if setmenu_index >= 0:
#         set_menu = submenus[setmenu_index]
#         set_menu_actions = set_menu.actions()
#         use_file_io = None  # This will be the widget (menu item)
#         for action in set_menu_actions:
#             if "Use File I/O" in action.text():
#                 use_file_io = action
#                 break
#         if use_file_io != None:
#             # Then we've found the actual widget, so get its value
#             if use_file_io.isChecked():
#                 file_io_mode = True
#     print('get_file_io_mode | Returning %s' % str(file_io_mode))
#     return (file_io_mode)


# def method_debug():
#     print('method_debug() was called...')
#     alignem.print_debug(1, "In Method debug for " + str(__name__))
#     __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})


# def center_all():
#     print('alignem.main_window.center_all_images() was called from alignem_swift.py')
#     # main_win.center_all_images() #0408 #changed because below should be the correct call
#     alignem.main_window.center_all_images()
#
#
# def refresh_all():
#     print('refresh_all | Refreshing all...')
#     alignem.main_window.refresh_all_images()