CACHER="0"
DEBUG="0"
PULL="1"

echo "Parsing cli arguments..."

for i in "$@"; do
  case $i in
    -c|--cacher)
      CACHER="1"
      shift
      ;;
    -d|--debug)
      DEBUG="1"
      shift # past argument with no value
      ;;
    -p=*|--pull=*)
      PULL="${i#*=}"
      shift
      ;;
    -*|--*)
      echo "Unknown option $i"
      exit 1
      ;;
    *)
      ;;
  esac
done

echo "CACHER  : ${CACHER}"
echo "DEBUG   : ${DEBUG}"
echo "PULL    : ${PULL}"

echo "Setting things up..."

echo "Checking if miniconda3 is installed..."
if [ ! -d "$WORK/miniconda3" ]; then
  echo "Miniconda not found in $WORK..."
  echo "Installing..."
  mkdir -p $WORK/miniconda3
  wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O $WORK/miniconda3/miniconda.sh
  bash $WORK/miniconda3/miniconda.sh -b -u -p $WORK/miniconda3
  rm -rf $WORK/miniconda3/miniconda.sh

  echo "Ensuring conda base environment is OFF..."
  conda config --set auto_activate_base false
fi

echo "Initializing conda..."
$WORK/miniconda3/bin/conda init bash

#echo "Sourcing .bashrc..."
#source ~/.bashrc

#echo "Updating conda..."
#conda update --name base conda -y

echo "Checking if AlignEM-SWiFT exists in $WORK..."
if [ ! -d "$WORK/swift-ir" ]; then
  echo "AlignEM-SWiFT not found in $WORK..."
  cd $WORK
  git clone https://github.com/mcellteam/swift-ir.git
fi

echo "Changing directory to swift-ir..."
cd $WORK/swift-ir

echo "Checking out development_ng branch..."
git checkout development_ng
git pull

echo "Purging modules..."
module purge

if [ "$PULL" != "0" ] ; then
  echo "Pulling the latest changes from GitHub..."
  cd $WORK/swift-ir
  git stash
  git pull --ff-only
else
  echo "Skipping pull from GitHub..."
fi
#echo "Pulling the latest changes from GitHUb..."
#cd $WORK/swift-ir
#git stash
#git pull --ff-only

echo "Activating conda environment..."
conda activate /work/08507/joely/ls6/miniconda3/envs/alignTACC1024

#echo "Unsetting MAX_NUM_THREADS..."
#unset MAX_NUM_THREADS
#echo "Unsetting GALLIUM_DRIVER..."
#unset GALLIUM_DRIVER # Conflicts with TACC SWR module and env variables
echo "Unsetting MESA_DEBUG..."
unset MESA_DEBUG
echo "Unsetting QT_API..."
unset QT_API
echo "Setting QT API environment flag QT_API=pyqt5..."
export QT_API=pyqt5

#echo "Setting Environment Variables in Conda API..."
#NOTE SOME OF THESE ARE ALREADY SET IN THE ENVIRONMENT
#conda env config vars set OBJC_DISABLE_INITIALIZE_FORK_SAFETY='YES'
#conda env config vars set QTWEBENGINE_CHROMIUM_FLAGS='--disable-web-security --no-sandbox --enable-logging --log-level=0'
#conda env config vars set PYTHONDEVMODE=1

#echo "Disabling QtWebEngine sandbox..."
#export QTWEBENGINE_CHROMIUM_FLAGS='--disable-sandbox'
#export QTWEBENGINE_DISABLE_SANDBOX=1
export BLOSC_NTHREADS=1

echo "Activating Preconfigured Conda Environment..."
conda activate /work/08507/joely/ls6/miniconda3/envs/alignTACC1024

echo "Environment Variables:"
conda env config vars list

echo "Loading intel/19.1.1 module..."
ml intel/19.1.1
echo "Loading swr/21.2.5 module..."
ml swr/21.2.5
echo "Loading impi/19.0.9 module..."
ml impi/19.0.9
echo "Loading fftw3/3.3.10 module..."
ml fftw3/3.3.10

if [ "$CACHER" = "1" ] ; then
  echo "Loading python_cacher module..."
  ml python_cacher/1.2
fi

echo "3D Acceleration/OpenGL Rendering:"
swr glxinfo -B

node=$(hostname --alias)
echo "Node     : $node"

echo ""
echo "You should now be in the environment 'alignTACC1024'."
echo "To relaunch AlignEM-SWiFT on Lonestar6 @ TACC:"
echo ""
echo "    cd $WORK/swift-ir"
echo "    source bootstrap_alignEM"
echo ""
#echo "Launching AlignEM-SWiFT in *HEADLESS* mode..."
echo "Launching AlignEM-SWiFT..."

if [ "$DEBUG" = "1" ] ; then
  module load valgrind
  PYTHONFAULTHANDLER=1 PYTHONMALLOC=malloc catchsegv valgrind --leak-check=full --show-leak-kinds=all -s python3 $WORK/swift-ir/alignEM.py
else
  python3 $WORK/swift-ir/alignEM.py
fi
__all__ = ['MainWindow']

logger = logging.getLogger(__name__)

class MainWindow(QMainWindow):
    resized = Signal()
    keyPressed = Signal(int)
    alignmentFinished = Signal()
    updateTable = Signal()
    cancelMultiprocessing = Signal()

    def __init__(self, data=None):
        QMainWindow.__init__(self)
        self.app = QApplication.instance()
        self.setObjectName('mainwindow')
        self.window_title = 'AlignEM-SWiFT'
        self.setWindowTitle(self.window_title)
        cfg.thumb = Thumbnailer()
        # self.installEventFilter(self)
        # self.setAttribute(Qt.WA_AcceptTouchEvents, True)
        self.initImageAllocations()
        self.initPrivateMembers()
        self.initThreadpool(timeout=250)
        self.initOpenGlContext()
        self.initPythonConsole()
        self.initStatusBar()
        self.initPbar()
        self.initToolbar()
        self.initControlPanel()
        self.initUI()
        self.initMenu()
        self.initWidgetSpacing()
        self.initStyle()
        self.initShortcuts()
        # self.initData()
        # self.initView()
        self.initLaunchTab()

        self.alignmentFinished.connect(self.updateProjectTable)
        self.cancelMultiprocessing.connect(self.cleanupAfterCancel)

        self.activateWindow()

        self.tell('To Relaunch on Lonestar6:\n\n  cd $WORK/swift-ir\n  source tacc_boostrap\n')

        if not cfg.NO_SPLASH:
            self.show_splash()

        # if cfg.DEV_MODE:
        #     self.profilingTimerButton.click()

        self.initSizeAndPos(cfg.WIDTH, cfg.HEIGHT)


    def initSizeAndPos(self, width, height):
        self.resize(width, height)
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center() # cp PyQt5.QtCore.QPoint
        # cp.setX(cp.x() - 200)
        qr.moveCenter(cp)
        self.move(qr.topLeft())


    def resizeEvent(self, event):
        # if self.detailsWidget.isVisible():
        #     h = self.detailsWidget.geometry().height()
        #     self.detailsCorrSpots.setFixedSize(max(10,h-44), max(10,h-44))
        # if not self._working:
        #     self.resized.emit()
        #     if cfg.project_tab:
        #         cfg.project_tab.initNeuroglancer()
        #     return super(MainWindow, self).resizeEvent(event)
        pass


    def getNgLayout(self):
        return self.comboboxNgLayout.currentText()


    def ngRadiobuttonChanged(self, checked):

        caller = inspect.stack()[1].function
        if caller == 'main':
            logger.info('')
            if checked:
                if self._isProjectTab():
                    if getData('state,MANUAL_MODE'):
                        # cfg.project_tab.MA_viewer_stage.initViewerSbs()
                        # if self.rb0.isChecked():
                        #     cfg.project_tab.MA_viewer_stage.initViewerSlim(force_xy=True)
                        # elif self.rb1.isChecked():
                        #     cfg.project_tab.MA_viewer_stage.initViewerSbs()
                        return


                    if self.rb0.isChecked():
                        cfg.data['ui']['arrangement'] = 'stack'
                        cfg.data['ui']['ng_layout'] = '4panel'
                        # logger.info('rb0 has been checked')
                        cfg.project_tab._overlayBottomLeft.hide()
                        cfg.project_tab._overlayLab.hide()
                        cfg.project_tab._overlayRect.hide()
                        # self.comboboxNgLayout.setCurrentText('4panel')
                    elif self.rb1.isChecked():
                        cfg.data['ui']['arrangement'] = 'comparison'
                        cfg.data['ui']['ng_layout'] = 'xy'
                        # logger.info('rb1/rb2 has been checked')
                        # self.comboboxNgLayout.setCurrentText('xy')
                    elif self.rb2.isChecked():
                        pass
                    # cfg.project_tab.updateNeuroglancer()
                    cfg.project_tab.initNeuroglancer() #0208+

        # else:
        #     logger.critical(f'caller was {caller}')




    # def neuroglancer_configuration_0(self):
    #
    #     # logger.info('')
    #
    #
    #
    # def neuroglancer_configuration_1(self):
    #     logger.critical(f'caller:{inspect.stack()[1].function}')
    #     # logger.info('')
    #
    # def neuroglancer_configuration_2(self):
    #     logger.info('')
    #     if cfg.data:
    #         if cfg.project_tab:
    #             self.comboboxNgLayout.setCurrentText('xy')
    #             cfg.project_tab._widgetArea_details.show()
    #             # cfg.project_tab._tabs.setCurrentIndex(0) #0124-
    #             # cfg.project_tab.updateNeuroglancer()
    #             cfg.project_tab.initNeuroglancer()


    def cleanupAfterCancel(self):
        logger.critical('Cleaning Up After Multiprocessing Tasks Were Canceled...')
        cfg.project_tab.snr_plot.initSnrPlot()
        cfg.project_tab.project_table.setScaleData()
        cfg.project_tab.updateTreeWidget()
        self.updateToolbar()
        self.dataUpdateWidgets()
        self.updateEnabledButtons()


    def hardRestartNg(self):
        caller = inspect.stack()[1].function
        logger.critical('\n\n\n**HARD** Restarting Neuroglancer (caller: %s)...\n\n' % caller)
        if cfg.USE_DELAY:
            time.sleep(cfg.DELAY_BEFORE)
        if self._isProjectTab() or self._isZarrTab():
            if ng.is_server_running():
                logger.info('Stopping Neuroglancer...')
                ng.server.stop()
            elif cfg.project_tab:
                cfg.project_tab.initNeuroglancer()
            elif cfg.zarr_tab:
                cfg.zarr_tab.load()
        if cfg.USE_DELAY:
            time.sleep(cfg.DELAY_AFTER)


    def refreshTab(self):

        if not self._working:
            logger.critical('Refreshing...')
            if self._isProjectTab():
                if cfg.project_tab._tabs.currentIndex() == 0:
                    # cfg.project_tab.webengine.setUrl(QUrl(cfg.emViewer.get_viewer_url()))
                    # cfg.project_tab.webengine.reload()
                    delay = time.time() - self._lastRefresh
                    logger.info('delay: %s' % str(delay))
                    if self._lastRefresh and (delay < 2):
                        self.hardRestartNg()
                    else:
                        cfg.project_tab.initNeuroglancer()
                    self._lastRefresh = time.time()
                if cfg.project_tab._tabs.currentIndex() == 1:
                    logger.critical('Refreshing Table...')
                    self.tell('Refreshing Table...')
                    cfg.project_tab.project_table.setScaleData()
                    self.hud.done()
                if cfg.project_tab._tabs.currentIndex() == 2:
                    logger.critical('Refreshing JSON Tree...')
                    cfg.project_tab.updateTreeWidget()
                elif cfg.project_tab._tabs.currentIndex() == 3:
                    logger.critical('Refreshing SNR Plot...')
                    self.tell('Refreshing SNR Plot...')
                    cfg.project_tab.snr_plot.initSnrPlot()
                    self.hud.done()
            elif self._getTabType() == 'WebBrowser':
                self._getTabObject().browser.page().triggerAction(QWebEnginePage.Reload)
            elif self._getTabType() == 'OpenProject':
                configure_project_paths()
                self._getTabObject().user_projects.set_data()
        else:
            self.warn('The application is busy')
            logger.warning('The application is busy')



    def shutdownNeuroglancer(self):
        if ng.is_server_running():
            logger.critical('Stopping Neuroglancer...')
            # self.tell('Stopping Neuroglancer...')
            ng.server.stop()
            time.sleep(.1)


    def tell(self, message):
        self.hud.post(message, level=logging.INFO)
        self.update()


    def warn(self, message):
        self.hud.post(message, level=logging.WARNING)
        self.update()


    def err(self, message):
        self.hud.post(message, level=logging.ERROR)
        self.update()


    def bug(self, message):
        self.hud.post(message, level=logging.DEBUG)
        self.update()


    def initThreadpool(self, timeout=1000):
        logger.info('')
        self.threadpool = QThreadPool.globalInstance()
        self.threadpool.setExpiryTimeout(timeout)  # ms


    def initImageAllocations(self):
        logger.info('')
        # if qtpy.PYSIDE6:
        #     QImageReader.setAllocationLimit(0)  # PySide6 only
        os.environ['QT_IMAGEIO_MAXALLOC'] = "1_000_000_000_000_000_000"
        from PIL import Image
        Image.MAX_IMAGE_PIXELS = 1_000_000_000_000



    def initOpenGlContext(self):
        logger.info('')
        self.context = QOpenGLContext(self)
        self.context.setFormat(QSurfaceFormat())


    def initPrivateMembers(self):
        logger.info('')
        self._unsaved_changes = False
        self._working = False
        self._scales_combobox_switch = 0 #1125
        self._isPlayingBack = 0
        self._isProfiling = 0
        self.detachedNg = WebPage()
        self._lastRefresh = 0


    def initStyle(self):
        logger.info('')
        self.apply_default_style()


    def initPythonConsole(self):
        logger.info('')

        namespace = {
            'pg': pg,
            'np': np,
            'cfg': src.config,
            'mw': src.config.main_window,
            'emViewer': cfg.emViewer,
            'ng': ng,
        }
        text = """
        Caution - anything executed here is injected into the main event loop of AlignEM-SWiFT!
        """

        cfg.py_console = pyqtgraph.console.ConsoleWidget(namespace=namespace, text=text)
        self._py_console = QWidget()
        self._py_console.setStyleSheet('background-color: #003333; color: #f3f6fb; border-radius: 5px;')
        lab = QLabel('Python Console')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 4px; margin-top: 4px;')
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0,0,0,0)
        vbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignBaseline)
        vbl.addWidget(cfg.py_console)
        self._py_console.setLayout(vbl)
        self._py_console.setObjectName('_py_console')
        self._py_console.hide()


    def initView(self):
        logger.info('Making things look normal...')
        # self._tabs.show()
        self.enableAllTabs()
        self.cpanel.show()
        self.matchpointControls.hide()
        cfg.MP_MODE = False
        setpOpt('state,MANUAL_MODE', False)
        self.main_stack_widget.setCurrentIndex(0)
        self._changeScaleCombo.setEnabled(True)
        cfg.SHADER = ''
        try:
            cfg.project_tab._overlayRect.hide()
            cfg.project_tab._overlayLab.hide()
        except:
            pass
        self.viewer_stack_widget.setCurrentIndex(0)



    def _callbk_showHideNotes(self):
        if self.notes.isHidden():
            label  = 'Hide Notes'
            icon   = 'fa.caret-down'
            self.notes.show()
            sizes = self._splitter.sizes()
            sizes[0] = 200
            self._splitter.setSizes(sizes)
        else:
            label  = ' Notes'
            icon   = 'mdi.notebook-edit'
            self.notes.hide()
        self._btn_show_hide_notes.setIcon(qta.icon(icon, color='#f3f6fb'))
        self._btn_show_hide_notes.setText(label)
        self.updateNotes()

        # if cfg.project_tab:
        #     cfg.project_tab.initNeuroglancer()
        # if cfg.zarr_tab:
        #     cfg.emViewer.bootstrap()


    def _callbk_showHideShader(self):
        if self.shaderCodeWidget.isHidden():
            label  = 'Hide Shader'
            icon   = 'fa.caret-down'
            self.shaderCodeWidget.show()
            if self._isProjectTab():
                # rng = cfg.data.normalize()
                # self.normalizedSlider.setStart(rng[0])
                # self.normalizedSlider.setEnd(rng[1])
                self.brightnessSlider.setValue(cfg.data.brightness())
                self.contrastSlider.setValue(cfg.data.contrast())
                # sizes = self._splitter.sizes()
                # sizes[1] = 140
                # self._splitter.setSizes(sizes)
        else:
            label  = ' Shader'
            icon   = 'mdi.format-paint'
            self.shaderCodeWidget.hide()
        self._btn_show_hide_shader.setIcon(qta.icon(icon, color='#f3f6fb'))
        self._btn_show_hide_shader.setText(label)
        self.updateShaderText()


    def _callbk_showHideDetails(self):
        if self.correlation_signals.isHidden():
            label  = 'Hide Correlation Signal'
            icon   = 'fa.caret-down'

            self.correlation_signals.show()
            self.updateCorrSpotsDrawer()

        else:
            label  = ' Correlation Signal'
            icon   = 'fa.info-circle'
            self.correlation_signals.hide()
        self._btn_show_hide_corr_spots.setIcon(qta.icon(icon, color='#f3f6fb'))
        self._btn_show_hide_corr_spots.setText(label)


    def updateCorrSpotsDrawer(self):
        logger.info('')
        snr_vals = cfg.data.snr_components()
        # logger.info('snr vals: %s' % str(snr_vals))
        n = len(snr_vals)
        for i in range(7):

            h = max(self.correlation_signals.height() - 38, 64)
            # logger.info('h = %d' %h)
            self.corr_signals[i].setFixedSize(h, h)

            if i < n:
                # logger.info('i = %d, SNR = %.3f' % (i, snr_vals[i]))
                path = cfg.data.corr_signal_path(i=i)
                self.corr_signals[i].set_data(path=path, snr=snr_vals[i])
                self.corr_signals[i].show()
            else:
                # logger.info('i = %d, No Image' %i)
                # self.corr_signals[i].set_no_image()
                self.corr_signals[i].hide()


    def fn_shader_control(self):
        logger.info('')
        if self._isProjectTab():
            logger.info(f'range: {self.normalizedSlider.getRange()}')
            cfg.data.set_normalize(self.normalizedSlider.getRange())
            state = copy.deepcopy(cfg.emViewer.state)
            for layer in state.layers:
                layer.shaderControls['normalized'].range = np.array(cfg.data.normalize())
            # state.layers[0].shader_controls['normalized'] = {'range': np.array([20,50])}
            cfg.emViewer.set_state(state)

    def fn_brightness_control(self):
        caller = inspect.stack()[1].function
        if caller == 'main':
            if self._isProjectTab():
                logger.info(f'val = {self.brightnessSlider.value()}')
                cfg.data.set_brightness(self.brightnessSlider.value())
                state = copy.deepcopy(cfg.emViewer.state)
                for layer in state.layers:
                    layer.shaderControls['brightness'] = cfg.data.brightness()
                cfg.emViewer.set_state(state)


    def fn_contrast_control(self):
        caller = inspect.stack()[1].function
        if caller == 'main':
            if self._isProjectTab():
                logger.info(f'val = {self.contrastSlider.value()}')
                cfg.data.set_contrast(self.contrastSlider.value())
                state = copy.deepcopy(cfg.emViewer.state)
                for layer in state.layers:
                    layer.shaderControls['contrast'] = cfg.data.contrast()
                cfg.emViewer.set_state(state)

    def fn_volume_rendering(self):
        if self._isProjectTab():
            state = copy.deepcopy(cfg.emViewer.state)
            state.showSlices = False
            cfg.emViewer.set_state(state)


    def _callbk_showHidePython(self):
        logger.info('')
        # con = (self._py_console, self._dev_console)[cfg.DEV_MODE]
        con = self._dev_console
        if con.isHidden():
            label  = 'Hide Python'
            icon   = 'fa.caret-down'
            con.show()
            sizes = self._splitter.sizes()
            sizes[3] = 200
            self._splitter.setSizes(sizes)
        else:
            label  = ' Python'
            icon   = 'mdi.language-python'
            con.hide()
        self._btn_show_hide_console.setIcon(qta.icon(icon, color='#f3f6fb'))
        self._btn_show_hide_console.setText(label)
        # if cfg.project_tab:
        #     if cfg.project_tab._tabs.currentIndex() == 0:
        #         cfg.project_tab.updateNeuroglancer()

        # if cfg.project_tab:
        #     cfg.project_tab.initNeuroglancer()
        # if cfg.zarr_tab:
        #     cfg.emViewer.bootstrap()


    def _forceShowControls(self):
        self.cpanelMainWidgets.show()
        self._btn_show_hide_ctls.setIcon(qta.icon("fa.caret-down", color='#f3f6fb'))
        self._btn_show_hide_ctls.setText('Hide Controls')


    def _forceHideControls(self):
        self.cpanelMainWidgets.hide()
        self._btn_show_hide_ctls.setIcon(qta.icon("ei.adjust-alt", color='#f3f6fb'))
        self._btn_show_hide_ctls.setText('Controls')


    def _callbk_showHideControls(self):
        logger.info('')
        if self.cpanelMainWidgets.isHidden():
            self._forceShowControls()
        else:
            self._forceHideControls()
        # if cfg.project_tab:
        #     cfg.project_tab.inputNeuroglancer()
        # if cfg.zarr_tab:
        #     cfg.emViewer.bootstrap()


    def _forceHidePython(self):

        # con = (self._py_console, self._dev_console)[cfg.DEV_MODE]
        con = self._dev_console
        label = ' Python'
        icon = 'mdi.language-python'
        color = '#f3f6fb'
        con.hide()
        self._btn_show_hide_console.setIcon(qta.icon(icon, color=color))
        self._btn_show_hide_console.setText(label)


    def autoscale(self, make_thumbnails=True):

        logger.critical('>>>> autoscale >>>>')

        #Todo This should check for existence of original source files before doing anything
        self.stopNgServer() #0202-
        self.tell('Generating TIFF Scale Image Hierarchy...')
        cfg.nTasks = 3
        cfg.nCompleted = 0
        cfg.CancelProcesses = False
        cfg.event = multiprocessing.Event()
        self.pbarLabel.setText('Processing (0/%d)...' % cfg.nTasks)
        self.showZeroedPbar()
        self.set_status('Autoscaling...')
        self._disableGlobTabs()
        try:
            if cfg.USE_EXTRA_THREADING:
                self.worker = BackgroundWorker(fn=generate_scales(dm=cfg.data))
                self.threadpool.start(self.worker)
            else:
                generate_scales(dm=cfg.data)
        except:
            print_exception()
            self.warn('Something Unexpected Happened While Generating TIFF Scale Hierarchy')

        # show_status_report(results=cfg.results, dt=cfg.dt)

        cfg.data.link_reference_sections() #Todo: check if this is necessary
        cfg.data.set_scale(cfg.data.scales()[-1])

        logger.info('Autoscaler is setting image sizes per scale...')
        for s in cfg.data.scales():
            cfg.data.set_image_size(s=s)

        self.tell('Copy-converting TIFFs to NGFF-Compliant Zarr...')
        self.showZeroedPbar()
        try:
            if cfg.USE_EXTRA_THREADING:
                self.worker = BackgroundWorker(fn=generate_zarr_scales(cfg.data))
                self.threadpool.start(self.worker)
            else:
                generate_zarr_scales(cfg.data)
        except:
            print_exception()
            self.warn('Something Unexpected Happened While Converting The Scale Hierarchy To Zarr')

        if make_thumbnails:
            self.tell('Generating Thumbnails...')
            self.showZeroedPbar()
            try:
                if cfg.USE_EXTRA_THREADING:
                    self.worker = BackgroundWorker(fn=cfg.thumb.generate_main())
                    self.threadpool.start(self.worker)
                else:
                    cfg.thumb.generate_main()

            except:
                print_exception()
                self.warn('Something Unexpected Happened While Generating Thumbnails')

            finally:
                cfg.data.scalesList = cfg.data.scales()
                cfg.data.nscales = len(cfg.data.scales())
                cfg.data.set_scale(cfg.data.scales()[-1])
                self.pbar_widget.hide()
                logger.info('Thumbnail Generation Complete')

        self.enableAllTabs()
        # cfg.project_tab.initNeuroglancer()
        self.pbarLabel.setText('')
        self.tell('**** Processes Complete ****')
        logger.info('<<<< autoscale <<<<')


    def _showSNRcheck(self, s=None):
        caller = inspect.stack()[1].function
        if s == None: s = cfg.data.scale()
        if cfg.data.is_aligned():
            logger.info(f'Checking SNR data for {s}...')
            failed = cfg.data.check_snr_status()
            if len(failed) == cfg.data.nSections:
                self.warn(f'No SNR Data Available for %s' % cfg.data.scale_pretty(s=s))
            elif failed:
                indexes, names = zip(*failed)
                lst_names = ''
                for name in names:
                    lst_names += f'\n  Section: {name}'
                self.warn(f'No SNR Data For Layer(s): {", ".join(map(str, indexes))}')


    def regenerate(self, scale) -> None:

        if cfg.project_tab is None: self.warn('No data yet!'); return
        if self._working == True: self.warn('Another Process is Already Running'); return
        if not cfg.data.is_aligned(s=scale): self.warn('Scale Must Be Aligned First'); return
        self.onAlignmentStart(scale=scale)
        logger.info('Regenerate Aligned Images...')
        self.tell('Regenerating Aligned Images,  Scale %d...' % get_scale_val(scale))
        try:
            if cfg.USE_EXTRA_THREADING:
                self.set_status('Regenerating Alignment...')
                self.worker = BackgroundWorker(
                    fn=generate_aligned(scale=scale, start=0, end=None, renew_od=True, reallocate_zarr=True))
                self.threadpool.start(self.worker)
            else:
                generate_aligned(scale=scale, start=0, end=None, renew_od=True, reallocate_zarr=True)

            self.showZeroedPbar()
            try:
                if cfg.USE_EXTRA_THREADING:
                    self.worker = BackgroundWorker(fn=cfg.thumb.generate_aligned(start=0, end=None))
                    self.threadpool.start(self.worker)
                else:
                    cfg.thumb.generate_aligned(start=0, end=None)

            except:
                print_exception()
                self.warn('Something Unexpected Happened While Generating Thumbnails')

            finally:
                cfg.data.scalesList = cfg.data.scales()
                cfg.data.nscales = len(cfg.data.scales())
                cfg.data.set_scale(cfg.data.scales()[-1])
                self.pbar_widget.hide()
                logger.info('Thumbnail Generation Complete')

        except:
            print_exception()
            self.err('An Exception Was Raised During Image Generation.')
        else:
            self.dataUpdateWidgets()
            self._autosave()

        finally:
            self.pbarLabel.setText('')
            dir = cfg.data.dest()
            scale = cfg.data.scale()
            cfg.project_tab._onTabChange()
            if are_aligned_images_generated(dir=dir, scale=scale):
                pass
            else:
                self.err('Image Generation Failed Unexpectedly. Try Re-aligning.')
            self.pbar_widget.hide()
            cfg.project_tab.initNeuroglancer()
            self.tell('**** Processes Complete ****')


    def verify_alignment_readiness(self) -> bool:

        if not cfg.data:
            self.warn('No project yet!')
            return False
        elif self._working == True:
            self.warn('Another Process is Running')
            return False
        elif not cfg.data.is_alignable():
            warning_msg = "Scale %s must be aligned first!" % get_scale_val(cfg.data.next_coarsest_scale_key())
            self.warn(warning_msg)
            return False
        else:
            return True


    @Slot()
    def updateProjectTable(self):
        logger.info('SLOT: Updating Project Table...')
        cfg.project_tab.project_table.setScaleData()

    @Slot()
    def updateSNRPlot(self):
        logger.info('SLOT: Updating SNR Plot...')
        cfg.project_tab.snr_plot.initSnrPlot()

    @Slot()
    def updateProjectDict(self):
        cfg.project_tab.updateTreeWidget()

    # @Slot()
    # def restore_interactivity(self):
    #     self._working = False
    #     self.enableAllButtons()
    #     self.updateEnabledButtons()
    #     self.pbar_widget.hide()


    def present_snr_results(self, start=0, end=None):
        if exist_aligned_zarr_cur_scale():
            self.tell('The Stack is Aligned!')
            logger.info('Alignment seems successful')
        else:
            self.warn('Something Went Wrong')
        logger.info('Calculating SNR Diff Values...')
        diff_avg = cfg.data.snr_average() - cfg.data.snr_prev_average()
        delta_list = cfg.data.delta_snr_list()[start:end]
        no_chg = [i for i, x in enumerate(delta_list) if x == 0]
        pos = [i for i, x in enumerate(delta_list) if x > 0]
        neg = [i for i, x in enumerate(delta_list) if x < 0]
        self.tell('Re-alignment Results:')
        self.tell('  # Better (SNR ↑) : %s' % ' '.join(map(str, pos)))
        self.tell('  # Worse  (SNR ↓) : %s' % ' '.join(map(str, neg)))
        self.tell('  # Equal  (SNR =) : %s' % ' '.join(map(str, no_chg)))
        if abs(diff_avg) < .001: self.tell('  Δ AVG. SNR : 0.000 (NO CHANGE)')
        elif diff_avg < 0:       self.tell('  Δ AVG. SNR : %.3f (WORSE)' % diff_avg)
        else:                    self.tell('  Δ AVG. SNR : %.3f (BETTER)' % diff_avg)


    def onAlignmentEnd(self, start, end):
        logger.info('Running Post-Alignment Tasks...')
        self.alignmentFinished.emit()
        try:
            self.pbarLabel.setText('')
            self.pbar_widget.hide()
            self.enableAllTabs()
            self.updateToolbar()
            self.updateSNRPlot()
            self.updateEnabledButtons()
            self.updateToolbar()
            self.updateMenus()
            cfg.project_tab.updateTreeWidget()
            self.present_snr_results(start=start, end=end)
            prev_snr_average = cfg.data.snr_prev_average()
            snr_average = cfg.data.snr_average()
            self.tell('New Avg. SNR: %.3f, Previous Avg. SNR: %.3f' % (prev_snr_average, snr_average))

            self.update_data_cache()
            self.dataUpdateWidgets()

            self._showSNRcheck()

        except:
            print_exception()
        finally:
            self._working = False
            if not getData('state,MANUAL_MODE'):
                self.enableAllTabs()
                self._autosave()

    def update_data_cache(self):
        logger.info('')
        # if self._isProjectTab():
        if cfg.data:
            cfg.data.update_cache()
            cfg.project_tab.updateTreeWidget()
            s = cfg.data.scale()
            # self.detailsScales.setText('\n'.join([cfg.data.scale_pretty(s=x).ljust(10) + '-' +
            #                                       ('%dx%d' % cfg.data.image_size(s=x)).rjust(12) for x in
            #                                       cfg.data.scales()]))
            # try:
            #     self.detailsTensorLab.setText(json.dumps(cfg.tensor.spec().to_json(), indent=2))
            # except:
            #     pass
            try:
                cfg.project_tab.detailsRuntime.setText(
                    'Gen. Scales      :' + ('%.2fs\n' % cfg.data['data']['t_scaling']).rjust(9) +
                    'Convert Zarr     :' + ('%.2fs\n' % cfg.data['data']['t_scaling_convert_zarr']).rjust(9) +
                    'Source Thumbs    :' + ('%.2fs\n' % cfg.data['data']['t_thumbs']).rjust(9) +
                    'Compute Affines  :' + ('%.2fs\n' % cfg.data['data']['scales'][s]['t_align']).rjust(9) +
                    'Gen. Alignment   :' + ('%.2fs\n' % cfg.data['data']['scales'][s]['t_generate']).rjust(9) +
                    'Aligned Thumbs   :' + ('%.2fs\n' % cfg.data['data']['scales'][s]['t_thumbs_aligned']).rjust(9) +
                    'Corr Spot Thumbs :' + ('%.2fs\n' % cfg.data['data']['scales'][s]['t_thumbs_spot']).rjust(9)
                )
            except:
                logger.warning('detailsTiming cant update')


    def onAlignmentStart(self, scale):
        logger.info('')
        if self._toggleAutogenerate.isChecked():
            cfg.nTasks = 5
        else:
            cfg.nTasks = 3
        cfg.nCompleted = 0
        cfg.CancelProcesses = False
        cfg.event = multiprocessing.Event()
        self.pbarLabel.setText('Processing (0/%d)...' % cfg.nTasks)
        self.stopPlaybackTimer()
        self._disableGlobTabs()
        self.showZeroedPbar()
        cfg.data.set_use_bounding_rect(self._bbToggle.isChecked(), s=cfg.data.curScale)
        if cfg.data.is_aligned(s=scale):
            cfg.data.set_previous_results()
        self._autosave()
        self.stopNgServer()  # 0202-


    def alignAll(self):
        '''MUST handle bounding box for partial-stack alignments.'''
        self.tell('Aligning All Sections (%s)...' % cfg.data.scale_pretty())
        scale = cfg.data.curScale
        is_realign = cfg.data.is_aligned(s=scale)
        # This SHOULD always work. Only set bounding box here. Then, during a single or partial alignment,
        # generate_aligned will use the correct value that is consistent with the other images
        # at the same scale
        cfg.data['data']['scales'][scale]['use_bounding_rect'] = self._bbToggle.isChecked()
        self.align(
            scale=cfg.data.curScale,
            start=0,
            end=None,
            renew_od=True,
            reallocate_zarr=True
        )
        # if not cfg.CancelProcesses:
        #     self.present_snr_results()
        self.onAlignmentEnd(start=0, end=None)
        cfg.project_tab.initNeuroglancer()
        self.tell('**** Processes Complete ****')


    def alignRange(self):
        start = int(self.startRangeInput.text())
        end = int(self.endRangeInput.text())
        self.tell('Re-aligning Sections #%d through #%d (%s)...' %
                  (start, end, cfg.data.scale_pretty()))
        self.align(
            scale=cfg.data.curScale,
            start=start,
            end=end,
            renew_od=False,
            reallocate_zarr=False
        )
        self.onAlignmentEnd(start=start, end=end)
        cfg.project_tab.initNeuroglancer()
        self.tell('**** Processes Complete ****')


    def alignOne(self):
        self.tell('Re-aligning Section #%d (%s)...' %
                  (cfg.data.layer(), cfg.data.scale_pretty()))
        start = cfg.data.layer()
        end = cfg.data.layer() + 1
        self.align(
            scale=cfg.data.curScale,
            start=start,
            end=end,
            renew_od=False,
            reallocate_zarr=False
        )
        self.onAlignmentEnd(start=start, end=end)
        cfg.project_tab.initNeuroglancer()
        self.tell('Section #%d Alignment Complete' % start)
        self.tell('SNR Before: %.3f  SNR After: %.3f' %
                  (cfg.data.snr_prev(l=start), cfg.data.snr(l=start)))
        self.tell('**** Processes Complete ****')


    def alignOneMp(self):
        self.tell('Re-aligning Section #%d (%s)...' %
                  (cfg.data.layer(), cfg.data.scale_pretty()))
        start = cfg.data.layer()
        end = cfg.data.layer() + 1
        self.align(
            scale=cfg.data.curScale,
            start=start,
            end=end,
            renew_od=False,
            reallocate_zarr=False
        )
        self.onAlignmentEnd(start=start, end=end)
        cfg.project_tab.initNeuroglancer()
        self.tell('Section #%d Alignment Complete' % start)
        self.tell('SNR Before: %.3f  SNR After: %.3f' %
                  (cfg.data.snr_prev(l=start), cfg.data.snr(l=start)))
        self.tell('**** Processes Complete ****')


    def align(self, scale, start, end, renew_od=False, reallocate_zarr=False):
        #Todo change printout based upon alignment scope, i.e. for single layer
        caller = inspect.stack()[1].function
        logger.info('')
        if not self.verify_alignment_readiness(): return
        self.onAlignmentStart(scale=scale)
        m = {'init_affine': 'Initializing', 'refine_affine': 'Refining'}
        self.tell("%s Affines (%s)..." %(m[cfg.data.al_option(s=scale)], cfg.data.scale_pretty(s=scale)))
        try:
            if cfg.USE_EXTRA_THREADING:
                self.worker = BackgroundWorker(fn=compute_affines(scale, start, end))
                self.threadpool.start(self.worker)
            else: compute_affines(scale, start, end)
        except:   print_exception(); self.err('An Exception Was Raised During Alignment.')
        # else:     logger.info('Affine Computation Finished')

        try:
            if cfg.USE_EXTRA_THREADING:
                self.worker = BackgroundWorker(fn=cfg.thumb.generate_corr_spot(start=start, end=end))
                self.threadpool.start(self.worker)
            else: cfg.thumb.generate_corr_spot(start=start, end=end)
        except: print_exception(); self.warn('There Was a Problem Generating Corr Spot Thumbnails')
        # else:   logger.info('Correlation Spot Thumbnail Generation Finished')

        # if cfg.project_tab._tabs.currentIndex() == 1:
        #     cfg.project_tab.project_table.setScaleData()

        if self._toggleAutogenerate.isChecked():
            try:
                if cfg.USE_EXTRA_THREADING:
                    self.worker = BackgroundWorker(fn=generate_aligned(
                        scale, start, end, renew_od=renew_od, reallocate_zarr=reallocate_zarr))
                    self.threadpool.start(self.worker)
                else: generate_aligned(scale, start, end, renew_od=renew_od, reallocate_zarr=reallocate_zarr)
            except:
                print_exception()
            finally:
                logger.info('Generate Alignment Finished')

            try:
                if cfg.USE_EXTRA_THREADING:
                    self.worker = BackgroundWorker(fn=cfg.thumb.generate_aligned(start=start, end=end))
                    self.threadpool.start(self.worker)
                else: cfg.thumb.generate_aligned(start=start, end=end)
            except:
                print_exception()
                # self.warn('Something Unexpected Happened While Generating Thumbnails')
            finally:
                logger.info('Generate Aligned Thumbnails Finished')

        self.pbarLabel.setText('')
        self.pbar_widget.hide()
        cfg.nCompleted = 0
        cfg.nTasks = 0


    def rescale(self):

        #Todo clear SNR data!

        if not cfg.data:
            self.warn('No data yet!')
            return

        if getData('state,MANUAL_MODE'):
            return

        msg ='Warning: Rescaling clears project data.\nProgress will be lost. Continue?'
        dlg = AskContinueDialog(title='Confirm Rescale', msg=msg)
        if not dlg.exec():
            logger.info('Rescale Canceled')
            return

        cfg.nTasks = 3
        cfg.nCompleted = 0
        cfg.CancelProcesses = False
        cfg.event = multiprocessing.Event()
        self.pbarLabel.setText('Processing (0/%d)...' % cfg.nTasks)
        self.showZeroedPbar()
        self.stopNgServer() #0202-
        self._disableGlobTabs()

        for scale in cfg.data.scales():
            logger.info('Clearing Method Results, %s' % cfg.data.scale_pretty(s=scale))
            cfg.data.clear_method_results(scale=scale, start=0, end=None)

        # self.initView()
        # self.shutdownNeuroglancer()
        self.clearUIDetails()
        path = cfg.data.dest()
        filenames = cfg.data.get_source_img_paths()
        scales = cfg.data.scales()
        self._scales_combobox_switch = 0 #refactor this out
        self.hud.post("Removing Extant Scale Directories...")
        try:
            for scale in scales:
                # if s != 'scale_1':
                p = os.path.join(path, scale)
                if os.path.exists(p):
                    logger.info(f'removing path {p}...')
                    shutil.rmtree(p)
        except:
            print_exception()
        else:
            self.hud.done()
        finally:
            self.update_data_cache() #0212+

        self.post = self.hud.post("Removing Zarr Scale Directories...")
        try:
            p = os.path.join(path, 'img_src.zarr')
            if os.path.exists(p):
                logger.info(f'removing path {p}...')
                shutil.rmtree(p, ignore_errors=True)
            p = os.path.join(path, 'img_aligned.zarr')
            if os.path.exists(p):
                logger.info(f'removing path {p}...')
                shutil.rmtree(p, ignore_errors=True)
        except:
            print_exception()
        else:
            self.hud.done()

        recipe_dialog = ScaleProjectDialog(parent=self)
        if recipe_dialog.exec():
            logger.info('ConfigProjectDialog - Passing...')
            pass
        else:
            logger.info('ConfigProjectDialog - Returning...')
            return
        logger.info('Clobbering The Project Dictionary...')
        makedirs_exist_ok(cfg.data.dest(), exist_ok=True)
        logger.info(str(filenames))
        self.hud.post("Re-scaling...")

        try:
            self.autoscale(make_thumbnails=False)
        except:
            print_exception()
        else:
            self._autosave()
            self.tell('Rescaling Successful')
        finally:
            self.pbar_widget.hide()
            self.enableAllTabs()
            self.onStartProject()
        self.tell('**** Processes Complete ****')


    def generate_multiscale_zarr(self):
        pass


    def export(self):
        if self._working == True:
            self.warn('Another Process is Already Running')
            return
        logger.critical('Exporting To Zarr...')
        self.tell('Exporting...')
        self.tell('Generating Neuroglancer-Compatible Zarr...')
        src = os.path.abspath(cfg.data['data']['destination_path'])
        out = os.path.abspath(os.path.join(src, 'img_aligned.zarr'))
        try:
            if cfg.USE_EXTRA_THREADING:
                self.worker = BackgroundWorker(fn=generate_zarr_scales())
                self.threadpool.start(self.worker)
            else:
                generate_zarr_scales()
        except:
            print_exception()
            logger.error('Zarr Export Encountered an Exception')

        self._callbk_unsavedChanges()
        self.tell('Process Finished')


    @Slot()
    def clear_skips(self):
        if cfg.project_tab.are_there_any_skips():
            msg = 'Verify reset the reject list.'
            reply = QMessageBox.question(self, 'Verify Reset Reject List', msg, QMessageBox.Cancel | QMessageBox.Ok)
            if reply == QMessageBox.Ok:
                cfg.data.clear_all_skips()
        else:
            self.warn('No Skips To Clear.')


    def apply_all(self) -> None:
        '''Apply alignment settings to all images for all scales'''
        if cfg.data:
            swim_val = self._swimWindowControl.value() / 100.
            whitening_val = self._whiteningControl.value()
            self.tell('Applying These Settings To All Scales + Layers...')
            self.tell('  SWIM Window  : %.3f%%' % self._swimWindowControl.value())
            self.tell('  Whitening    : %.3f' % whitening_val)
            for layer in cfg.data.alstack(s=cfg.data.curScale):
                layer['alignment']['method_data']['win_scale_factor'] = swim_val
                layer['alignment']['method_data']['whitening_factor'] = whitening_val


    def enableAllButtons(self):
        self._btn_alignAll.setEnabled(True)
        self._btn_alignOne.setEnabled(True)
        self._btn_alignRange.setEnabled(True)
        self._btn_regenerate.setEnabled(True)
        self._scaleDownButton.setEnabled(True)
        self._scaleUpButton.setEnabled(True)
        self._ctlpanel_applyAllButton.setEnabled(True)
        self._skipCheckbox.setEnabled(True)
        self._whiteningControl.setEnabled(True)
        self._swimWindowControl.setEnabled(True)
        self._toggleAutogenerate.setEnabled(True)
        self._bbToggle.setEnabled(True)
        self._polyBiasCombo.setEnabled(True)
        self._btn_clear_skips.setEnabled(True)
        self._toggleAutogenerate.setEnabled(True)
        self.startRangeInput.setEnabled(True)
        self.endRangeInput.setEnabled(True)


    def updateEnabledButtons(self) -> None:
        '''This method does three things:
        (1) Update the visibility of next/prev s buttons depending on current s.
        (2) Set the enabled/disabled state of the align_all-all button
        (3) Sets the input validator on the jump-to lineedit widget'''
        logger.info('')
        if cfg.data:
            # self._btn_alignAll.setText('Align All\n%s' % cfg.data.scale_pretty())
            self._ctlpanel_applyAllButton.setEnabled(True)
            self._skipCheckbox.setEnabled(True)
            self._toggleAutogenerate.setEnabled(True)
            self._bbToggle.setEnabled(True)
            self._polyBiasCombo.setEnabled(True)
            self._btn_clear_skips.setEnabled(True)
            self._swimWindowControl.setEnabled(True)
            self._whiteningControl.setEnabled(True)
        else:
            self._ctlpanel_applyAllButton.setEnabled(False)
            self._skipCheckbox.setEnabled(False)
            self._whiteningControl.setEnabled(False)
            self._swimWindowControl.setEnabled(False)
            self._toggleAutogenerate.setEnabled(False)
            self._bbToggle.setEnabled(False)
            self._polyBiasCombo.setEnabled(False)
            self._btn_clear_skips.setEnabled(False)

        if cfg.data:
            # if cfg.data.is_aligned_and_generated(): #0202-
            if cfg.data.is_aligned():
                self._btn_alignAll.setEnabled(True)
                self._btn_alignOne.setEnabled(True)
                self._btn_alignRange.setEnabled(True)
                self._btn_regenerate.setEnabled(True)
                self.startRangeInput.setEnabled(True)
                self.endRangeInput.setEnabled(True)
            elif cfg.data.is_alignable():
                self._btn_alignAll.setEnabled(True)
                self._btn_alignOne.setEnabled(False)
                self._btn_alignRange.setEnabled(False)
                self._btn_regenerate.setEnabled(False)
                self.startRangeInput.setEnabled(False)
                self.endRangeInput.setEnabled(False)
            else:
                self._btn_alignAll.setEnabled(False)
                self._btn_alignOne.setEnabled(False)
                self._btn_alignRange.setEnabled(False)
                self._btn_regenerate.setEnabled(False)
                self.startRangeInput.setEnabled(False)
                self.endRangeInput.setEnabled(False)
            if cfg.data.nscales == 1:
                self._scaleUpButton.setEnabled(False)
                self._scaleDownButton.setEnabled(False)
                if cfg.data.is_aligned():
                    self._btn_alignAll.setEnabled(True)
                    self._btn_alignOne.setEnabled(True)
                    self._btn_alignRange.setEnabled(True)
                    self._btn_regenerate.setEnabled(True)
                    self.startRangeInput.setEnabled(True)
                    self.endRangeInput.setEnabled(True)
                else:
                    self._btn_alignAll.setEnabled(True)
                    self._btn_alignOne.setEnabled(False)
                    self._btn_alignRange.setEnabled(False)
                    self._btn_regenerate.setEnabled(False)
                    self.startRangeInput.setEnabled(False)
                    self.endRangeInput.setEnabled(False)
            else:
                cur_index = self._changeScaleCombo.currentIndex()
                if cur_index == 0:
                    self._scaleDownButton.setEnabled(True)
                    self._scaleUpButton.setEnabled(False)
                elif cfg.data.n_scales() == cur_index + 1:
                    self._scaleDownButton.setEnabled(False)
                    self._scaleUpButton.setEnabled(True)
                else:
                    self._scaleDownButton.setEnabled(True)
                    self._scaleUpButton.setEnabled(True)
            # self._btn_regenerate.setStatusTip('Re-generate All Aligned Images, '
            #                                   'But Keep Current Affines,  %s' % cfg.data.scale_pretty())
            # self._btn_alignRange.setStatusTip('Re-compute Affines for Sections in the Range #%d to End, '
            #                                     'then Generate Them  %s' % (cfg.data.layer(), cfg.data.scale_pretty()))
            # self._btn_alignAll.setStatusTip('Compute Affines for All Sections, '
            #                                 'then Generate Them,  %s' % cfg.data.scale_pretty())
            # self._btn_alignOne.setStatusTip('Compute Affine for the Current Section Only, '
            #                                 'then Generate It,  Scale %d' % cfg.data.scale_val())
        else:
            self._scaleUpButton.setEnabled(False)
            self._scaleDownButton.setEnabled(False)
            self._btn_alignAll.setEnabled(False)
            self._btn_alignOne.setEnabled(False)
            self._btn_alignRange.setEnabled(False)
            self._btn_regenerate.setEnabled(False)
            self.startRangeInput.setEnabled(False)
            self.endRangeInput.setEnabled(False)


    def scale_up(self) -> None:
        '''Callback function for the Next Scale button.'''
        logger.info('')
        if not self._scaleUpButton.isEnabled():
            return
        if self._working:
            self.warn('Changing scales during CPU-bound processes is not currently supported.')
            return
        try:
            self._changeScaleCombo.setCurrentIndex(self._changeScaleCombo.currentIndex() - 1)  # Changes Scale
            if not cfg.data.is_alignable():
                self.warn('Lower scales have not been aligned yet')
        except:
            print_exception()


    def layer_right(self):
        logger.info('')
        if cfg.data:
            if cfg.project_tab:
                requested = cfg.data.layer() + 1
                if requested < len(cfg.data):
                    cfg.data.set_layer(requested)
                    cfg.emViewer.set_layer(requested)
                    self.dataUpdateWidgets()


    def layer_left(self):
        logger.info('')
        if cfg.data:
            if cfg.project_tab:
                requested = cfg.data.layer() - 1
                if requested >= 0:
                    cfg.data.set_layer(requested)
                    cfg.emViewer.set_layer(requested)
                    self.dataUpdateWidgets()



    def scale_down(self) -> None:
        '''Callback function for the Previous Scale button.'''
        logger.info('')
        if not self._scaleDownButton.isEnabled():
            return
        if self._working:
            self.warn('Changing scales during CPU-bound processes is not currently supported.')
            return
        try:
            self._changeScaleCombo.setCurrentIndex(self._changeScaleCombo.currentIndex() + 1)  # Changes Scale
            # cfg.data.set_layer(cur_layer) # Set layer to layer last visited at previous s
        except:
            print_exception()


    @Slot()
    def set_status(self, msg: str) -> None:
        # self.statusBar.showMessage(msg)
        pass


    def minimal_stylesheet(self):
        self.setStyleSheet('')
        logger.info('Changing stylesheet to minimal')


    def apply_default_style(self):
        cfg.THEME = 0
        # self.tell('Setting Default Theme')
        # self.main_stylesheet = os.path.abspath('src/styles/default.qss')
        self.main_stylesheet = os.path.abspath('src/styles/default.qss')
        with open(self.main_stylesheet, 'r') as f:
            style = f.read()
        self.setStyleSheet(style)
        # self.cpanel.setStyleSheet(style)
        # self.hud.set_theme_default()
        self.hud.set_theme_light()



    def reset_groupbox_styles(self):
        logger.info('reset_groupbox_styles:')


    def updateToolbar(self):
        caller = inspect.stack()[1].function
        # logger.info(f'caller: {caller}')
        if self._isProjectTab():
            self.comboboxNgLayout.setCurrentText(cfg.data['ui']['ng_layout'])
            if cfg.data.is_aligned_and_generated():
                self.rb0.setText('Aligned')
                self.aligned_label.show()
                self.generated_label.show()
                self.unaligned_label.hide()
            elif cfg.data.is_aligned():
                self.rb0.setText('Unaligned')
                self.aligned_label.show()
                self.generated_label.hide()
                self.unaligned_label.hide()
            else:
                self.rb0.setText('Unaligned')
                self.aligned_label.hide()
                self.generated_label.hide()
                self.unaligned_label.show()

        if self._isProjectTab() or self._isZarrTab():
            if cfg.tensor:
                self.label_toolbar_resolution.setText(f'{cfg.tensor.shape}')
                self.label_toolbar_resolution.show()
            else:
                self.label_toolbar_resolution.hide()

        else:
            self.aligned_label.hide()
            self.unaligned_label.hide()
            self.generated_label.hide()
            self.label_toolbar_resolution.hide()

    @Slot()
    def dataUpdateWidgets(self, ng_layer=None) -> None:
        '''Reads Project Data to Update MainWindow.'''
        caller = inspect.stack()[1].function
        logger.info(f'Updating widgets (caller: {caller})...')

        if self._isProjectTab():
            if cfg.data:
                if self._working == True:
                    logger.warning(f"Can't update GUI now - working (caller: {caller})...")
                    self.warn("Can't update GUI now - working...")
                    return
                if isinstance(ng_layer, int):
                    try:
                        if 0 <= ng_layer < len(cfg.data):
                            logger.debug(f'Setting Layer: {ng_layer}')
                            cfg.data.set_layer(ng_layer)
                            # self._sectionSlider.setValue(ng_layer)
                    except:
                        print_exception()

                elif cfg.data.skipped():
                    cfg.project_tab._overlayRect.setStyleSheet('background-color: rgba(0, 0, 0, 0.5);')
                    cfg.project_tab._overlayLab.setText('X REJECTED - %s' % cfg.data.name_base())
                    cfg.project_tab._overlayLab.show()
                    cfg.project_tab._overlayRect.show()
                elif ng_layer == 0:
                    cfg.project_tab._overlayLab.setText('No Reference')
                    cfg.project_tab._overlayLab.show()
                else:
                    cfg.project_tab._overlayRect.hide()
                    cfg.project_tab._overlayLab.hide()

                if self.correlation_signals.isVisible():
                    self.updateCorrSpotsDrawer()

                cur = cfg.data.layer()
                if self.notes.isVisible():
                    self.updateNotes()

                if cur == 0:
                    self._prevSectionBtn.setEnabled(False)
                else:
                    self._prevSectionBtn.setEnabled(True)

                if cur >= len(cfg.data) - 1:
                    self._nextSectionBtn.setEnabled(False)
                else:
                    self._nextSectionBtn.setEnabled(True)

                if cfg.project_tab._tabs.currentIndex() == 2:
                    cfg.project_tab.treeview_model.jumpToLayer()

                if cfg.project_tab._tabs.currentIndex() == 3:
                    cfg.project_tab.snr_plot.updateLayerLinePos()
                    cfg.project_tab.updatePlotThumbnail()
                    styles = {'color': '#f3f6fb', 'font-size': '14px', 'font-weight': 'bold'}
                    # cfg.project_tab.snr_plot.plot.setTitle(cfg.data.base_image_name())
                    cfg.project_tab.snr_plot.plot.setLabel('top', cfg.data.base_image_name(), **styles)

                cfg.project_tab.project_table.table.selectRow(cur)
                self._sectionSlider.setValue(cur)
                self._jumpToLineedit.setText(str(cur)) #0131+
                # if getOpt('neuroglancer,SHOW_ALIGNMENT_DETAILS'):
                #     self.updateLayerDetails()
                if getData('state,MANUAL_MODE'):
                    self.matchpoint_text_snr.setText(cfg.data.snr_report())

                if cfg.project_tab.detailsCorrSpots.isVisible():
                    if cfg.data.selected_method() == 'Auto-SWIM':
                        snr_vals = cfg.data.snr_components()
                        n = len(snr_vals)
                        if (n >= 1) and (snr_vals[0] > .001):
                            cfg.project_tab.cs0.set_data(path=cfg.data.corr_spot_q0_path(), snr=snr_vals[0])
                        else:
                            cfg.project_tab.cs0.set_no_image()
                        if (n >= 2):
                            cfg.project_tab.cs1.set_data(path=cfg.data.corr_spot_q1_path(), snr=snr_vals[1])
                        else:
                            cfg.project_tab.cs1.set_no_image()
                        if (n >= 3):
                            cfg.project_tab.cs2.set_data(path=cfg.data.corr_spot_q2_path(), snr=snr_vals[2])
                        else:
                            cfg.project_tab.cs2.set_no_image()
                        if (n >= 4):
                            cfg.project_tab.cs3.set_data(path=cfg.data.corr_spot_q3_path(), snr=snr_vals[3])
                        else:
                            cfg.project_tab.cs3.set_no_image()



                # if self.detailsWidget.isVisible():
                #
                #     n = len(cfg.data.snr_components())
                #     hbl = QHBoxLayout()
                #     hbl.setContentsMargins(2, 2, 2, 2)
                #     for i in range(n):
                #         img = SnrThumbnail(parent=self)
                #         hbl.addWidget(img)

                    # self.cs0 = SnrThumbnail(parent=self)
                    # self.cs1 = SnrThumbnail(parent=self)
                    # self.cs2 = SnrThumbnail(parent=self)
                    # self.cs3 = SnrThumbnail(parent=self)
                    # gl = QGridLayout()
                    # gl.setSpacing(1)
                    # gl.setContentsMargins(0, 0, 0, 0)
                    # gl.addWidget(self.cs0, 0, 0)
                    # gl.addWidget(self.cs1, 0, 1)
                    # gl.addWidget(self.cs2, 1, 0)
                    # gl.addWidget(self.cs3, 1, 1)
                    # self.detailsCorrSpots.setLayout(gl)

                if cfg.project_tab.detailsSection.isVisible():
                    txt_ = f"""
                    Filename:  <b><span style='color: #ffe135;'>{cfg.data.filename_basename()}</span></b><br>
                    Reference:  <b><span style='color: #ffe135;'>{cfg.data.reference_basename()}</span></b><br>
                    Last Aligned: {cfg.data.datetime().rjust(23)}"""
                    method = cfg.data.selected_method()
                    if method == 'Auto-SWIM':        txt_ += '<br>Method:&nbsp;Automatic&nbsp;SWIM'
                    elif method == 'Manual-Hint': txt_ += '<br>Method:&nbsp;Manual,&nbsp;Hint'
                    elif method == 'Manual-Strict':                      txt_ += '<br>Method:&nbsp;Manual, Strict'
                    txt_ += f"""<br>Reject: {('[ ]', "<b><span style='color: #ffe135;'>[X]</span></b>")[cfg.data.skipped()]}"""
                    cfg.project_tab.detailsSection.setText(txt_)

                if cfg.project_tab.detailsAFM.isVisible():
                    afm, cafm = cfg.data.afm(), cfg.data.cafm()
                    afm_txt, cafm_txt = [], []
                    for x in range(2):
                        for y in range(3):
                            if y == 0:
                                afm_txt.append(('%.3f' % afm[x][y]).ljust(7))
                                cafm_txt.append(('%.3f' % cafm[x][y]).ljust(7))
                            elif y == 1:
                                afm_txt.append(('%.3f' % afm[x][y]).rjust(7))
                                cafm_txt.append(('%.3f' % afm[x][y]).rjust(7))
                            else:
                                afm_txt.append(('%.3f' % afm[x][y]).rjust(10))
                                cafm_txt.append(('%.3f' % cafm[x][y]).rjust(10))

                            if (x == 0) and (y == 2):
                                afm_txt.append('\n')
                                cafm_txt.append('\n')
                    cfg.project_tab.detailsAFM.setText('Affine:\n' + ''.join(afm_txt) +
                                            '\n\nCumulative Affine:\n' + ''.join(cafm_txt))


                if cfg.project_tab.detailsSNR.isVisible():
                    snr = cfg.data.snr_components()

                    if cfg.data.selected_method() == 'Auto-SWIM':
                        # logger.info('Updating detailsSNR for Auto-SWIM')
                        cfg.project_tab.detailsSNR.setText(
                            "Avg. SNR&nbsp;&nbsp;:<b><span style='color: #ffe135;'>%s</span></b><br>"
                            "Prev.&nbsp;SNR&nbsp;:%s<br>"
                            "Components<br>"
                            "Top,Left&nbsp;&nbsp;:%s<br>"
                            "Top,Right&nbsp;:%s<br>"
                            "Btm,Left&nbsp;&nbsp;:%s<br>"
                            "Btm,Right&nbsp;:%s" %
                            (('%.3f' % cfg.data.snr()).rjust(9),
                             ('%.3f' % cfg.data.snr_prev()).rjust(9),
                             ('%.3f' % snr[0]).rjust(9),
                             ('%.3f' % snr[1]).rjust(9),
                             ('%.3f' % snr[2]).rjust(9),
                             ('%.3f' % snr[3]).rjust(9))
                        )
                    elif cfg.data.selected_method() in ('Manual-Hint', 'Manual-Strict'):

                        txt = "Avg. SNR&nbsp;&nbsp;:<b><span style='color: #ffe135;'>%s</span></b><br>" \
                              "Prev.&nbsp;SNR&nbsp;:%s<br>" \
                              "Components" % (('%.3f' % cfg.data.snr()).rjust(9),
                                              ('%.3f' % cfg.data.snr_prev()).rjust(9))
                        for i in range(len(snr)):
                            txt += '<br>%d:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%.3f' % (i, snr[i])

                        cfg.project_tab.detailsSNR.setText(txt)

                try:     self._jumpToLineedit.setText(str(cur))
                except:  logger.warning('Current Layer Widget Failed to Update')
                try:     self._skipCheckbox.setChecked(cfg.data.skipped())
                except:  logger.warning('Skip Toggle Widget Failed to Update')
                try:     self._whiteningControl.setValue(cfg.data.whitening())
                except:  logger.warning('Whitening Input Widget Failed to Update')
                try:     self._swimWindowControl.setValue(cfg.data.swim_window() * 100.)
                except:  logger.warning('Swim Input Widget Failed to Update')
                try:
                    if cfg.data.null_cafm():
                        self._polyBiasCombo.setCurrentText(str(cfg.data.poly_order()))
                    else:
                        self._polyBiasCombo.setCurrentText('None')
                except:  logger.warning('Polynomial Order Combobox Widget Failed to Update')
                # cfg.project_tab.slotUpdateZoomSlider()


    def updateNotes(self):
        # caller = inspect.stack()[1].function
        # logger.info('')
        self.notesTextEdit.clear()
        if self._isProjectTab():
            cur = cfg.data.layer()
            self.notesTextEdit.setPlaceholderText('Enter notes about %s here...'
                                                  % cfg.data.base_image_name(s=cfg.data.curScale, l=cur))
            if cfg.data.notes(s=cfg.data.curScale, l=cur):
                self.notesTextEdit.setPlainText(cfg.data.notes(s=cfg.data.curScale, l=cur))
        else:
            self.notesTextEdit.clear()
            self.notesTextEdit.setPlaceholderText('Enter notes about anything here...')
        self.notes.update()

    def updateShaderText(self):
        # caller = inspect.stack()[1].function
        logger.info('')
        self.shaderText.clear()
        if self._isProjectTab():
            self.shaderText.setPlainText(cfg.data['rendering']['shader'])

    def onShaderApply(self):
        # caller = inspect.stack()[1].function
        logger.info('')
        if self._isProjectTab():
            cfg.data.set_brightness(float(self.brightnessLE.text()))
            cfg.data.set_contrast(float(self.contrastLE.text()))
            cfg.data['rendering']['shader'] = self.shaderText.toPlainText()
            cfg.project_tab.initNeuroglancer()
            self._callbk_unsavedChanges()

    def updateLayerDetails(self, s=None, l=None):
        if s == None: s = cfg.data.curScale
        if l == None: l = cfg.data.layer()
        name = "%s" % cfg.data.name_base(s=s, l=l)
        snr_report = cfg.data.snr_report(s=s, l=l)
        snr = f"%s" % snr_report
        skips = ' '.join(map(str, cfg.data.skips_list()))
        matchpoints = ' '.join(map(str, cfg.data.find_layers_with_matchpoints()))
        text0 = f"{name}"
        text1 = f"{snr}"
        text2 = f"Skipped Layers: [{skips}]"
        text3 = f"Match Point Layers: [{matchpoints}]"
        cfg.project_tab._layer_details[0].setText(text0)
        cfg.project_tab._layer_details[1].setText(text1)
        cfg.project_tab._layer_details[2].setText(text2)
        cfg.project_tab._layer_details[3].setText(text3)
        if cfg.data.is_aligned_and_generated():
            afm, cafm = cfg.data.afm(l=l), cfg.data.cafm(l=l)
            cfg.project_tab.afm_widget_.setText(make_affine_widget_HTML(afm, cafm))
        else:
            self.clearAffineWidget()


    def clearUIDetails(self):
        self.layer_details.setText('')
        self.clearAffineWidget()


    def clearAffineWidget(self):
        afm = cafm = [[0] * 3, [0] * 3]
        cfg.project_tab.afm_widget_.setText(make_affine_widget_HTML(afm, cafm))


    # def update_displayed_controls(self):
    #     if getOpt('ui,SHOW_CORR_SPOTS'):
    #         self.corr_spot_thumbs.show()
    #     else:
    #         self.corr_spot_thumbs.hide()


    def setPlaybackSpeed(self):
        dlg = QInputDialog(self)
        dlg.setInputMode(QInputDialog.IntInput)
        dlg.setTextValue(str(cfg.DEFAULT_PLAYBACK_SPEED))
        dlg.setLabelText('Set Playback Speed\n(frames per second)...')
        dlg.resize(200, 120)
        ok = dlg.exec_()
        if ok:
            new_speed = float(dlg.textValue())
            cfg.DEFAULT_PLAYBACK_SPEED = new_speed
            logger.info(f'Automatic playback speed set to {new_speed}fps')
            self.tell(f'Automatic playback speed set to {new_speed}fps')


    def updateHistoryListWidget(self, s=None):
        if s == None: s = cfg.data.curScale
        self.history_label = QLabel('<b>Saved Alignments (Scale %d)</b>' % get_scale_val(s))
        self._hstry_listWidget.clear()
        dir = os.path.join(cfg.data.dest(), s, 'history')
        try:
            self._hstry_listWidget.addItems(os.listdir(dir))
        except:
            logger.warning(f"History Directory '{dir}' Not Found")


    def view_historical_alignment(self):
        logger.info('view_historical_alignment:')
        name = self._hstry_listWidget.currentItem().text()
        if cfg.project_tab:
            if name:
                path = os.path.join(cfg.data.dest(), cfg.data.curScale, 'history', name)
                with open(path, 'r') as f:
                    project = json.load(f)
                self.projecthistory_model.load(project)
                self.globTabs.addTab(self.historyview_widget, cfg.data.scale_pretty())
        self._setLastTab()


    def rename_historical_alignment(self):
        new_name, ok = QInputDialog.getText(self, 'Rename', 'New Name:')
        if not ok: return
        old_name = self._hstry_listWidget.currentItem().text()
        dir = os.path.join(cfg.data.dest(), cfg.data.curScale, 'history')
        old_path = os.path.join(dir, old_name)
        new_path = os.path.join(dir, new_name)
        try:
            os.rename(old_path, new_path)
        except:
            logger.warning('There was a problem renaming the file')
        # self.updateHistoryListWidget()


    def swap_historical_alignment(self):
        name = self._hstry_listWidget.currentItem().text()
        if name is None: return
        scale_val = cfg.data.curScale_val()
        msg = "Are you sure you want to swap your alignment data for Scale %d with '%s'?\n" \
              "Note: You must realign after swapping it in." % (scale_val, name)
        reply = QMessageBox.question(self, 'Message', msg, QMessageBox.Yes, QMessageBox.No)
        if reply != QMessageBox.Yes:
            logger.info("Returning without changing anything.")
            return
        self.tell('Loading %s')
        path = os.path.join(cfg.data.dest(), cfg.data.curScale, 'history', name)
        with open(path, 'r') as f:
            scale = json.load(f)
        self.tell('Swapping Current Scale %d Dictionary with %s' % (scale_val, name))
        cfg.data.set_al_dict(aldict=scale)
        # self.regenerate() #Todo test this under a range of possible scenarios


    def remove_historical_alignment(self):
        logger.info('Loading History File...')
        name = self._hstry_listWidget.currentItem().text()
        if name is None: return
        path = os.path.join(cfg.data.dest(), cfg.data.curScale, 'history', name)
        logger.info('Removing archival alignment %s...' % path)
        try:
            os.remove(path)
        except:
            logger.warning('There was an exception while removing the old file')
        # finally:
        #     self.updateHistoryListWidget()


    def historyItemClicked(self, qmodelindex):
        item = self._hstry_listWidget.currentItem()
        logger.info(f"Selected {item.text()}")
        path = os.path.join(cfg.data.dest(), cfg.data.curScale, 'history', item.text())
        with open(path, 'r') as f:
            scale = json.load(f)


    def ng_layer(self):
        '''The idea behind this was to cache the current layer. Not Being Used Currently'''
        try:
            index = cfg.emViewer.cur_index
            assert isinstance(index, int)
            return index
        except:
            print_exception()


    def request_ng_layer(self):
        '''Returns The Currently Shown Layer Index In Neuroglancer'''
        layer = cfg.emViewer.request_layer()
        logger.info(f'Layer Requested From NG Worker Thread: {layer}')
        return layer


    def _resetSlidersAndJumpInput(self):
        '''Requires Neuroglancer '''
        # caller = inspect.stack()[1].function
        # logger.info(f'caller: {caller}')
        if cfg.data:
            try:
                if self._isProjectTab() or self._isZarrTab():
                    logger.info('Setting section slider and jump input validators...')
                    if cfg.project_tab:
                        self._jumpToLineedit.setValidator(QIntValidator(0, len(cfg.data) - 1))
                        self._sectionSlider.setRange(0, len(cfg.data) - 1)
                        self._sectionSlider.setValue(cfg.data.layer())
                        self.sectionRangeSlider.setMin(0)
                        self.sectionRangeSlider.setStart(0)
                        self.sectionRangeSlider.setMax(len(cfg.data) - 1)
                        self.sectionRangeSlider.setEnd(len(cfg.data) - 1)
                        self.startRangeInput.setValidator(QIntValidator(0, len(cfg.data) - 1))
                        self.endRangeInput.setValidator(QIntValidator(0, len(cfg.data) - 1))
                    # if cfg.zarr_tab:
                    #     if not cfg.tensor:
                    #         logger.warning('No tensor!')
                    #         return
                    #     self._jumpToLineedit.setValidator(QIntValidator(0, cfg.tensor.shape[0] - 1))
                    #     self._jumpToLineedit.setText(str(0))
                    #     self._sectionSlider.setRange(0, cfg.tensor.shape[0] - 1)
                    #     self._sectionSlider.setValue(0)
                    self.update()
            except:
                print_exception()



    def printActiveThreads(self):
        threads = '\n'.join([thread.name for thread in threading.enumerate()])
        logger.info(f'# Active Threads : {threading.active_count()}')
        logger.info(f'Current Thread   : {threading.current_thread()}')
        logger.info(f'All Threads      : \n{threads}')
        self.tell(f'# Active Threads : {threading.active_count()}')
        self.tell(f'Current Thread   : {threading.current_thread()}')
        self.tell(f'All Threads      : \n{threads}')


    @Slot()
    def jump_to(self, requested) -> None:
        logger.info('')
        if self._isProjectTab():
            if requested not in range(len(cfg.data)):
                logger.warning('Requested layer is not a valid layer')
                return
            cfg.data.set_layer(requested)
            cfg.project_tab.updateNeuroglancer() #0214+ intentionally putting this before dataUpdateWidgets (!)
            self.dataUpdateWidgets()


    @Slot()
    def jump_to_layer(self) -> None:
        logger.info('')
        if self._isProjectTab():
            requested = int(self._jumpToLineedit.text())
            if requested not in range(len(cfg.data)):
                logger.warning('Requested layer is not a valid layer')
                return
            cfg.data.set_layer(requested)
            if cfg.project_tab._tabs.currentIndex() == 1:
                cfg.project_tab.project_table.table.selectRow(requested)
            self._sectionSlider.setValue(requested)

    # def jump_to_minimal(self):
    #     logger.info('')
    #     if self._isProjectTab():
    #         cfg.data.set_layer(requested)

    def setSlider(self, val:int):
        self._sectionSlider.setValue(val)


    def jump_to_slider(self):
        # if cfg.data:
        caller = inspect.stack()[1].function
        # logger.info(f'caller: {caller}')
        if caller in ('dataUpdateWidgets', '_resetSlidersAndJumpInput'):
            return

        if getData('state,MANUAL_MODE'):
            return
        if not cfg.project_tab:
            if not cfg.zarr_tab:
                return
        # logger.info(f'caller: {caller}')
        requested = self._sectionSlider.value()
        if cfg.project_tab:
            cfg.data.set_layer(requested)
        if cfg.emViewer: # ? check this
            cfg.emViewer._layer = requested
        # logger.info(f'slider, requested: {requested}')
        if self._isProjectTab():
            if requested in range(len(cfg.data)):
                if cfg.project_tab._tabs.currentIndex() == 0:
                    logger.info('Jumping To Section #%d' % requested)
                    state = copy.deepcopy(cfg.emViewer.state)
                    state.position[0] = requested
                    cfg.emViewer.set_state(state)
                if cfg.project_tab._tabs.currentIndex() == 1:
                    cfg.project_tab.project_table.table.selectRow(requested)
                # elif self.detachedNg:
                #     if self.detachedNg.view.isVisible():
                #         state = copy.deepcopy(cfg.emViewer.state)
                #         state.position[0] = requested
                #         cfg.emViewer.set_state(state)
            self.dataUpdateWidgets()

        # elif cfg.zarr_tab:
        #     logger.info('Jumping To Section #%d' % requested)
        #     state = copy.deepcopy(cfg.emViewer.state)
        #     state.position[0] = requested
        #     cfg.emViewer.set_state(state)

        try:     self._jumpToLineedit.setText(str(requested))
        except:  logger.warning('Current Layer Widget Failed to Update')


    @Slot()
    def reload_scales_combobox(self) -> None:
        if self._isProjectTab():
            self._changeScaleCombo.show()
            logger.info('Reloading Scale Combobox (caller: %s)' % inspect.stack()[1].function)
            self._scales_combobox_switch = 0
            self._changeScaleCombo.clear()
            def pretty_scales():
                lst = []
                for s in cfg.data.scales():
                    siz = cfg.data.image_size(s=s)
                    lst.append('%s %dx%d' % (cfg.data.scale_pretty(s=s), siz[0], siz[1]))
                return lst

            self._changeScaleCombo.addItems(pretty_scales())
            self._changeScaleCombo.setCurrentIndex(cfg.data.scales().index(cfg.data.scale()))
            self._scales_combobox_switch = 1

        else:
            self._changeScaleCombo.hide()


    def onScaleChange(self):
        caller = inspect.stack()[1].function
        logger.critical(f'Changing Scales (caller: {caller})...')
        if not self._working:
            if caller != 'OnStartProject':
                # self.jump_to(cfg.data.layer())
                self.dataUpdateWidgets()
                self.updateEnabledButtons()
                if cfg.project_tab._tabs.currentIndex() == 1:
                    cfg.project_tab.project_table.setScaleData()
                self.updateToolbar()
                self.updateEnabledButtons()
                self._showSNRcheck()
                # self.update_data_cache() #0213+
                try:
                    self._bbToggle.setChecked(cfg.data.has_bb())
                except:
                    logger.warning('Bounding Rect Widget Failed to Update')
                cfg.project_tab.initNeuroglancer()
                # self.hardRestartNg() #0220-
        else:
            self.warn('The application is busy, cant change scales now...')

    def fn_scales_combobox(self) -> None:
        caller = inspect.stack()[1].function
        if caller in ('main', 'scale_up', 'scale_down'):
            if self._isProjectTab():
                if getData('state,MANUAL_MODE') == False:
                    if self._scales_combobox_switch:
                        logger.info(f'caller: {caller}')
                        index = self._changeScaleCombo.currentIndex()
                        cfg.data.set_scale(cfg.data.scales()[index])
                        self.onScaleChange() #0129-


    def fn_ng_layout_combobox(self) -> None:
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        if getData('state,MANUAL_MODE'):
            return
        if caller in ('main','<lambda>'):
            if cfg.data:
                if self._isProjectTab() or self._isZarrTab():
                    choice = self.comboboxNgLayout.currentText()
                    cfg.data['ui']['ng_layout'] = choice

                    try:
                        self.hud("Setting Neuroglancer Layout ['%s']... " % choice)
                        layout_actions = {
                            'xy': self.ngLayout1Action,
                            'yz': self.ngLayout2Action,
                            'xz': self.ngLayout3Action,
                            'xy-3d': self.ngLayout4Action,
                            'yz-3d': self.ngLayout5Action,
                            'xz-3d': self.ngLayout6Action,
                            '3d': self.ngLayout7Action,
                            '4panel': self.ngLayout8Action
                        }
                        layout_actions[choice].setChecked(True)
                        if cfg.project_tab:
                            # cfg.project_tab.updateNeuroglancer(nglayout=choice)
                            cfg.project_tab.updateNeuroglancer()
                        elif cfg.zarr_tab:
                            cfg.zarr_tab.load()
                         # cfg.project_tab.refreshNeuroglancerURL()
                    except:
                        print_exception()
                        logger.error('Unable To Change Neuroglancer Layout')


    def export_afms(self):
        if cfg.project_tab:
            if cfg.data.is_aligned_and_generated():
                file = export_affines_dialog()
                if file == None:
                    logger.warning('No Filename - Canceling Export')
                    return
                afm_lst = cfg.data.afm_list()
                with open(file, 'w') as f:
                    for sublist in afm_lst:
                        for item in sublist:
                            f.write(str(item) + ',')
                        f.write('\n')
                self.tell('Exported: %s' % file)
                self.tell('AFMs exported successfully.')
            else:
                self.warn('The current scale is not aligned. Nothing to export.')
        else:
            self.warn('There is no project open. Nothing to export.')


    def export_cafms(self):
        file = export_affines_dialog()
        if file == None:
            logger.warning('No Filename - Canceling Export')
            return
        logger.info('Export Filename: %s' % file)
        cafm_lst =  cfg.data.cafm_list()
        with open(file, 'w') as f:
            for sublist in cafm_lst:
                for item in sublist:
                    f.write(str(item) + ',')
                f.write('\n')
        self.tell('Exported: %s' % file)
        self.tell('Cumulative AFMs exported successfully.')


    def show_warning(self, title, text):
        QMessageBox.warning(None, title, text)


    def new_project(self, mendenhall=False):
        logger.critical('Starting A New Project...')
        self.tell('Starting A New Project...')
        self.stopPlaybackTimer()
        if cfg.project_tab:
            logger.info('Data is not None. Asking user to confirm new data...')
            msg = QMessageBox(QMessageBox.Warning,
                              'Confirm New Project',
                              'Please confirm create new project.',
                              buttons=QMessageBox.Cancel | QMessageBox.Ok)
            msg.setIcon(QMessageBox.Question)
            msg.setDefaultButton(QMessageBox.Cancel)
            reply = msg.exec_()
            if reply == QMessageBox.Ok:
                logger.info("Response was 'OK'")
            else:
                logger.info("Response was not 'OK' - Returning")
                self.warn('New Project Canceled.')
                return

        self.tell('New Project Path:')
        filename = new_project_dialog()
        if filename in ['', None]:
            logger.info('New Project Canceled.')
            self.warn("New Project Canceled.")
            return
        if not filename.endswith('.swiftir'):
            filename += ".swiftir"
        if os.path.exists(filename):
            logger.warning("The file '%s' already exists." % filename)
            self.warn("The file '%s' already exists." % filename)
            path_proj = os.path.splitext(filename)[0]
            self.tell(f"Removing Extant Project Directory '{path_proj}'...")
            logger.info(f"Removing Extant Project Directory '{path_proj}'...")
            shutil.rmtree(path_proj, ignore_errors=True)
            self.tell(f"Removing Extant Project File '{path_proj}'...")
            logger.info(f"Removing Extant Project File '{path_proj}'...")
            os.remove(filename)

        path, extension = os.path.splitext(filename)
        cfg.data = DataModel(name=path, mendenhall=mendenhall)

        cfg.project_tab = ProjectTab(self, path=path, datamodel=cfg.data)
        cfg.dataById[id(cfg.project_tab)] = cfg.data

        # makedirs_exist_ok(path, exist_ok=True)

        if not mendenhall:
            try:
                self.import_multiple_images()
            except:
                logger.warning('Import Images Dialog Was Canceled - Returning')
                self.warn('Canceling New Project')
                print_exception()
                return

            recipe_dialog = ScaleProjectDialog(parent=self)
            if recipe_dialog.exec():
                logger.info('ConfigProjectDialog - Passing...')
                pass
            else:
                logger.info('ConfigProjectDialog - Returning...')
                return


            makedirs_exist_ok(path, exist_ok=True)
            self._autosave(silently=True)
            self.autoscale()
            self.globTabs.addTab(cfg.project_tab, os.path.basename(path) + '.swiftir')
            self._setLastTab()
            self.onStartProject()
        else:
            create_project_structure_directories(cfg.data.dest(), ['scale_1'])
            # self.onStartProject(mendenhall=True)
            # turn OFF onStartProject for Mendenhall

        logger.critical(f'Appending {filename} to .swift_cache...')
        userprojectspath = os.path.join(os.path.expanduser('~'), '.swift_cache')
        with open(userprojectspath, 'a') as f:
            f.write(filename + '\n')
        self._autosave()


    # def delete_project(self):
    #     logger.critical('')
    #     project_file = cfg.selected_file
    #     project = os.path.splitext(project_file)[0]
    #     if not validate_project_selection():
    #         logger.warning('Invalid Project For Deletion (!)\n%s' % project)
    #         return
    #     self.warn("Delete the following project?\nProject: %s" % project)
    #     txt = "Are you sure you want to PERMANENTLY DELETE " \
    #           "the following project?\n\n" \
    #           "Project: %s" % project
    #     msgbox = QMessageBox(QMessageBox.Warning, 'Confirm Delete Project', txt,
    #                       buttons=QMessageBox.Abort | QMessageBox.Yes)
    #     msgbox.setIcon(QMessageBox.Critical)
    #     msgbox.setMaximumWidth(350)
    #     msgbox.setDefaultButton(QMessageBox.Cancel)
    #     reply = msgbox.exec_()
    #     if reply == QMessageBox.Abort:
    #         self.tell('Aborting Delete Project Permanently Instruction...')
    #         logger.warning('Aborting Delete Project Permanently Instruction...')
    #         return
    #     if reply == QMessageBox.Ok:
    #         logger.info('Deleting Project File %s...' % project_file)
    #         self.tell('Reclaiming Disk Space. Deleting Project File %s...' % project_file)
    #         logger.warning('Executing Delete Project Permanently Instruction...')
    #
    #     logger.critical(f'Deleting Project File: {project_file}...')
    #     self.warn(f'Deleting Project File: {project_file}...')
    #     try:
    #         os.remove(project_file)
    #     except:
    #         print_exception()
    #     else:
    #         self.hud.done()
    #
    #     logger.info('Deleting Project Directory %s...' % project)
    #     self.warn('Deleting Project Directory %s...' % project)
    #     try:
    #
    #         delete_recursive(dir=project)
    #         # shutil.rmtree(project, ignore_errors=True, onerror=handleError)
    #         # shutil.rmtree(project, ignore_errors=True, onerror=handleError)
    #     except:
    #         self.warn('An Error Was Encountered During Deletion of the Project Directory')
    #         print_exception()
    #     else:
    #         self.hud.done()
    #
    #     self.tell('Wrapping up...')
    #     configure_project_paths()
    #     if self.globTabs.currentWidget().__class__.__name__ == 'OpenProject':
    #         logger.critical('Reloading table of projects data...')
    #         try:
    #             self.globTabs.currentWidget().user_projects.set_data()
    #         except:
    #             logger.warning('There was a problem updating the project list')
    #             print_exception()
    #
    #     self.clearSelectionPathText()
    #
    #     self.tell('Deletion Complete!')
    #     logger.info('Deletion Complete')


    def open_project_new(self):
        if getData('state,MANUAL_MODE'):
            return

        for i in range(self.globTabs.count()):
            if self.globTabs.widget(i).__class__.__name__ == 'OpenProject':
                self.globTabs.setCurrentIndex(i)
                return
        self.globTabs.addTab(OpenProject(), 'Open...')
        self._setLastTab()


    def open_selected(self):
        if self._isProjectTab():
            self.open_project_selected()
        if self._isZarrTab():
            pass

    # def open_zarr_selected(self):
    #     path = cfg.selected_file
    #     logger.info("Opening Zarr '%s'..." % path)
    #     try:
    #         with open(os.path.join(path, '.zarray')) as j:
    #             self.zarray = json.load(j)
    #     except:
    #         print_exception()
    #         return
    #
    #     tab = ZarrTab(self, path=path)
    #     self.globTabs.addTab(tab, os.path.basename(path))
    #     self._setLastTab()


    # def open_project_selected(self):
    #     # caller = inspect.stack()[1].function
    #     # logger.info(f'caller: {caller}')
    #     logger.info('')
    #     self.stopPlaybackTimer()
    #     if validate_zarr_selection():
    #         self.open_zarr_selected()
    #         return
    #     elif validate_project_selection():
    #         filename = cfg.selected_file
    #         logger.critical(f'Opening Project {filename}...')
    #         self.tell('Loading Project "%s"' % filename)
    #
    #         try:
    #             with open(filename, 'r') as f:
    #                 cfg.data = DataModel(data=json.load(f))
    #             self._autosave()
    #         except:
    #             self.warn(f'No Such File Found: {filename}')
    #             logger.warning(f'No Such File Found: {filename}')
    #             print_exception()
    #             return
    #         else:
    #             logger.info(f'Project Opened!')
    #
    #         append_project_path(filename)
    #         cfg.data.set_paths_absolute(filename=filename)
    #         cfg.project_tab = ProjectTab(self, path=cfg.data.dest() + '.swiftir', datamodel=cfg.data)
    #         cfg.dataById[id(cfg.project_tab)] = cfg.data
    #         self.onStartProject()
    #         tab_name = os.path.basename(cfg.data.dest() + '.swiftir')
    #         self.globTabs.addTab(cfg.project_tab, tab_name)
    #         self._setLastTab()
    #     else:
    #         self.warn("Invalid Path")


    def detachNeuroglancer(self):
        # from qtpy.QtWebEngineWidgets import QWebEngineView, QWebEnginePage
        logger.info('')
        if getData('state,MANUAL_MODE') == True:
            return

        if self._isProjectTab() or self._isZarrTab():
            logger.info('Creating QWebEngineView...')



            if cfg.emViewer:
                self.detachedNg = WebPage(url=cfg.emViewer.url())
                # logger.info('Showing QWebEngineView...')
                # self.webengineview.load(QUrl())
                # self.webengineview.show()

            else:
                logger.warning('cfg.emViewer does not exist')

            # self.detachedNg = WebPage(parent=self, url=cfg.emViewer.url())
            # self.detachedNg.open(url=cfg.emViewer.url())
        else:
            if not ng.server.is_server_running():
                logger.warning('Neuroglancer is not running.')
            else:
                logger.warning('Wrong tab type.')


    def openDetatchedZarr(self):
        logger.info('')
        if self._isProjectTab() or self._isZarrTab():
            self.detachedNg = WebPage()
            self.detachedNg.open(url=str(cfg.emViewer.url()))
            self.detachedNg.show()
        else:
            if not ng.server.is_server_running():
                self.warn('Neuroglancer is not running.')

    def set_nglayout_combo_text(self, layout:str):
        self.comboboxNgLayout.setCurrentText(layout)


    def onStartProject(self, mendenhall=False):
        '''Functions that only need to be run once per project
                Do not automatically save, there is nothing to save yet'''

        caller = inspect.stack()[1].function
        # logger.critical('caller: %s' % caller)
        logger.critical('Loading project...')

        logpath = os.path.join(cfg.data.dest(),'logs')
        if not os.path.exists(logpath):
            os.mkdir(logpath)

        if cfg.data['ui']['arrangement'] == 'stack':
            cfg.data['ui']['ng_layout'] = '4panel'
            self.rb0.setChecked(True)
        elif cfg.data['ui']['arrangement'] == 'comparison':
            cfg.data['ui']['ng_layout'] = 'xy'
            self.rb1.setChecked(True)

        self.update_data_cache()
        setpOpt('state,MANUAL_MODE', False)
        cfg.data.set_defaults()
        cfg.project_tab.initNeuroglancer()
        self.tell('Updating UI...')
        self.dataUpdateWidgets()
        try:    self._bbToggle.setChecked(cfg.data.has_bb())
        except: logger.warning('Bounding Rect Widget Failed to Update')
        self._changeScaleCombo.setCurrentText(cfg.data.curScale)
        self._fps_spinbox.setValue(cfg.DEFAULT_PLAYBACK_SPEED)
        cfg.project_tab.updateTreeWidget()
        self.updateEnabledButtons()
        self.updateMenus()
        self._resetSlidersAndJumpInput()
        self.updateToolbar()
        self.reload_scales_combobox()
        self.enableAllTabs()
        self.updateNotes()
        self.hud.done()
        self.tell('Updating Table Data...')
        cfg.project_tab.project_table.setScaleData()
        self.hud.done()
        self._sectionSlider.setValue(int(len(cfg.data) / 2))
        # self._forceShowControls() #Todo make a decision on this
        self.update()



    def saveUserPreferences(self):
        logger.info('')
        userpreferencespath = os.path.join(os.path.expanduser('~'), '.swiftrc')
        try:
            f = open(userpreferencespath, 'w')
            json.dump(cfg.settings, f, indent=2)
            f.close()
        except:
            logger.warning(f'Unable to save current user preferences. Using defaults')



    def resetUserPreferences(self):
        logger.info('')
        userpreferencespath = os.path.join(os.path.expanduser('~'), '.swiftrc')
        if os.path.exists(userpreferencespath):
            os.remove(userpreferencespath)
        cfg.settings = {}
        update_preferences_model()
        self.saveUserPreferences()


    def rename_project(self):
        new_name, ok = QInputDialog.getText(self, 'Input Dialog', 'Project Name:')
        if ok:
            dest_orig = Path(cfg.data.dest())
            print(dest_orig)
            parent = dest_orig.parents[0]
            new_dest = os.path.join(parent, new_name)
            new_dest_no_ext = os.path.splitext(new_dest)[0]
            os.rename(dest_orig, new_dest_no_ext)
            cfg.data.set_destination(new_dest)
            # if not new_dest.endswith('.json'):  # 0818-
            #     new_dest += ".json"
            # logger.info('new_dest = %s' % new_dest)
            self._autosave()


    def save(self):
        if cfg.data:
            self.set_status('Saving...')
            self.tell('Saving Project...')
            try:
                self._saveProjectToFile()
                self._unsaved_changes = False
            except:
                self.warn('Unable To Save')
            else:
                self.hud.done()


    def _autosave(self, silently=False):
        if cfg.data:
            if cfg.AUTOSAVE:
                logger.info('Autosaving...')
                try:
                    self._saveProjectToFile(silently=silently)
                except:
                    self._unsaved_changes = True
                    print_exception()


    def _saveProjectToFile(self, saveas=None, silently=False):
        if cfg.data:
            if self._isProjectTab():
                try:
                    cfg.data.basefilenames()
                    if saveas is not None:
                        cfg.data.set_destination(saveas)
                    data_cp = copy.deepcopy(cfg.data)
                    # data_cp.make_paths_relative(start=cfg.data.dest())
                    data_cp_json = data_cp.to_dict()
                    if not silently:
                        logger.info('---- SAVING DATA TO PROJECT FILE ----')
                    jde = json.JSONEncoder(indent=2, separators=(",", ": "), sort_keys=True)
                    proj_json = jde.encode(data_cp_json)
                    name = cfg.data.dest()
                    if not name.endswith('.swiftir'):
                        name += ".swiftir"
                    logger.info('Save Name: %s' % name)
                    with open(name, 'w') as f: f.write(proj_json)
                    del data_cp
                    self.globTabs.setTabText(self.globTabs.currentIndex(), os.path.basename(name))
                except:
                    print_exception()
                else:
                    self._unsaved_changes = False


    def _callbk_unsavedChanges(self):
        if self._isProjectTab():
            logger.info('')
            caller = inspect.stack()[1].function
            if caller == 'main':
                # self.tell('You have unsaved changes.')
                logger.critical("caller: " + inspect.stack()[1].function)
                self._unsaved_changes = True
                name = os.path.basename(cfg.data.dest())
                self.globTabs.setTabText(self.globTabs.currentIndex(), name + '.swiftir' + ' *')


    def update_ng(self):
        if cfg.project_tab:
            cfg.project_tab.initNeuroglancer()
        if cfg.zarr_tab:
            cfg.zarr_tab.load()

    def import_multiple_images(self):
        ''' Import images into data '''
        logger.info('>>>> import_multiple_images >>>>')
        self.tell('Import Images:')
        filenames = natural_sort(import_images_dialog())

        if not filenames:
            logger.warning('No Images Were Selected')
            self.warn('No Images Were Selected')
            return 1

        cfg.data.set_source_path(os.path.dirname(filenames[0])) #Critical!
        self.tell(f'Importing {len(filenames)} Images...')
        logger.info(f'Selected Images: \n{filenames}')

        try:
            for f in filenames:
                if f:
                    cfg.data.append_image(f)
                else:
                    cfg.data.append_empty()
        except:
            print_exception()
            self.err('There Was A Problem Importing Selected Files')
        else:
            self.hud.done()

        if len(cfg.data) > 0:
            cfg.data.nSections = len(filenames)
            img_size = cfg.data.image_size(s='scale_1')
            self.tell(f'Dimensions: {img_size[0]}✕{img_size[1]}')
            cfg.data.link_reference_sections()
        else:
            self.warn('No Images Were Imported')

        logger.info('<<<< import_multiple_images <<<<')


    @Slot()
    def closeEvent(self, event):
        logger.info("MainWindow.closeEvent (called by %s):" % inspect.stack()[1].function)
        self.shutdownInstructions()


    def exit_app(self):
        logger.info("Exiting The Application...")

        quit_msg = "Are you sure you want to exit the program?"
        reply = QMessageBox.question(self, 'Message', quit_msg, QMessageBox.Yes, QMessageBox.No)
        if reply == QMessageBox.Yes:
            pass
        else:
            return

        self.set_status('Exiting...')
        if self._unsaved_changes:
            self.tell('Exit AlignEM-SWiFT?')
            message = "There are unsaved changes.\n\nSave before exiting?"
            msg = QMessageBox(QMessageBox.Warning, "Save Changes", message, parent=self)
            msg.setStandardButtons(QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)
            msg.setDefaultButton(QMessageBox.Save)
            msg.setIcon(QMessageBox.Question)
            reply = msg.exec_()
            if reply == QMessageBox.Cancel:
                logger.info('reply=Cancel. Returning control to the app.')
                self.tell('Canceling exit application')
                return
            if reply == QMessageBox.Save:
                logger.info('reply=Save')
                self.save()
                self.set_status('Wrapping up...')
                logger.info('Project saved. Exiting')
            if reply == QMessageBox.Discard:
                logger.info('reply=Discard Exiting without saving')
        else:
            logger.info('No Unsaved Changes - Exiting')

        self.shutdownInstructions()


    def shutdownInstructions(self):
        logger.info('Performing Shutdown Instructions...')

        # if ng.server.is_server_running():
        #     try:
        #         logger.info('Stopping Neuroglancer Client...')
        #         self.tell('Stopping Neuroglancer Client...')
        #         self.shutdownNeuroglancer()
        #     except:
        #         sys.stdout.flush()
        #         logger.warning('Having trouble shutting down neuroglancer')
        #         self.warn('Having trouble shutting down neuroglancer')
        #     finally:
        #         time.sleep(.3)

        if cfg.USE_EXTRA_THREADING:
            try:
                self.tell('Waiting For Threadpool...')
                logger.info('Waiting For Threadpool...')
                result = self.threadpool.waitForDone(msecs=500)
            except:
                print_exception()
                self.warn(f'Having trouble shutting down threadpool')
            finally:
                time.sleep(.4)

        # if cfg.DEV_MODE:
        self.tell('Shutting Down Python Console Kernel...')
        logger.info('Shutting Down Python Console Kernel...')
        try:

            self.pythonConsole.kernel_client.stop_channels()
            self.pythonConsole.kernel_manager.shutdown_kernel()
        except:
            print_exception()
            self.warn('Having trouble shutting down Python console kernel')
        finally:
            time.sleep(.4)

        self.tell('Graceful, Goodbye!')
        logger.info('Exiting...')
        time.sleep(1)
        QApplication.quit()


    def html_view(self):
        app_root = self.get_application_root()
        html_f = os.path.join(app_root, 'src', 'resources', 'remod.html')
        with open(html_f, 'r') as f:
            html = f.read()
        self.browser_web.setHtml(html)
        self.main_stack_widget.setCurrentIndex(1)

    def html_resource(self, resource='features.html', title='Features'):
        html_f = os.path.join(self.get_application_root(), 'src', 'resources', resource)
        with open(html_f, 'r') as f:
            html = f.read()

        webengine = QWebEngineView()
        webengine.setHtml(html)

        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)

        vbl.addWidget(webengine)
        w.setLayout(vbl)
        self.globTabs.addTab(w, title)
        self._setLastTab()
        # self.main_stack_widget.setCurrentIndex(4)


    def documentation_view(self):
        self.tell('Opening Documentation...')
        browser = WebBrowser()
        browser.setUrl(QUrl('https://github.com/mcellteam/swift-ir/blob/development_ng/README_SWIFTIR.md'))
        self.globTabs.addTab(browser, 'Documentation')
        self._setLastTab()
        self._forceHideControls()


    def remote_view(self):
        self.tell('Opening Neuroglancer Remote Viewer...')
        browser = WebBrowser()
        browser.setUrl(QUrl('https://neuroglancer-demo.appspot.com/'))
        self.globTabs.addTab(browser, 'Neuroglancer')
        self._setLastTab()
        self._forceHideControls()


    def open_url(self, text: str) -> None:
        self.browser_web.setUrl(QUrl(text))
        self.main_stack_widget.setCurrentIndex(1)


    def view_swiftir_examples(self):
        self.browser_web.setUrl(
            QUrl('https://github.com/mcellteam/swift-ir/blob/development_ng/docs/user/command_line/examples/README.md'))
        self.main_stack_widget.setCurrentIndex(1)


    def view_swiftir_commands(self):
        self.browser_web.setUrl(
            QUrl('https://github.com/mcellteam/swift-ir/blob/development_ng/docs/user/command_line/commands/README.md'))
        self.main_stack_widget.setCurrentIndex(1)

    def browser_3dem_community(self):
        self.browser_web.setUrl(QUrl(
            'https://3dem.org/workbench/data/tapis/community/data-3dem-community/'))



    def invalidate_all(self, s=None):
        if ng.is_server_running():
            if s == None: s = cfg.data.curScale
            if cfg.data.is_mendenhall():
                cfg.emViewer.menLV.invalidate()
            else:
                cfg.refLV.invalidate()
                cfg.baseLV.invalidate()
                if exist_aligned_zarr(s):
                    cfg.alLV.invalidate()


    def stopNgServer(self):
        # caller = inspect.stack()[1].function
        # logger.critical(caller)
        if ng.is_server_running():
            logger.info('Stopping Neuroglancer...')
            try:    ng.stop()
            except: print_exception()
        else:
            logger.info('Neuroglancer Is Not Running')

    def startStopProfiler(self):
        logger.info('')
        if self._isProfiling:
            self.profilingTimer.stop()
        else:
            self.profilingTimer.setInterval(cfg.PROFILING_TIMER_SPEED)
            self.profilingTimer.start()
        self._isProfiling = not self._isProfiling

    def startStopTimer(self):
        logger.info('')
        if self._isPlayingBack:
            self.automaticPlayTimer.stop()
            self._btn_automaticPlayTimer.setIcon(qta.icon('fa.play', color=cfg.ICON_COLOR))
        elif cfg.project_tab or cfg.zarr_tab:
            # self.automaticPlayTimer.setInterval(1000 / cfg.DEFAULT_PLAYBACK_SPEED)
            self.automaticPlayTimer.start()
            self._btn_automaticPlayTimer.setIcon(qta.icon('fa.pause', color=cfg.ICON_COLOR))
        self._isPlayingBack = not self._isPlayingBack


    def stopPlaybackTimer(self):
        self.automaticPlayTimer.stop()
        self._btn_automaticPlayTimer.setIcon(qta.icon('fa.play', color=cfg.ICON_COLOR))
        self._isPlayingBack = 0


    def initShortcuts(self):
        logger.info('')
        events = (
            (QKeySequence.MoveToPreviousChar, self.layer_left),
            (QKeySequence.MoveToNextChar, self.layer_right),
            # (QKeySequence.MoveToPreviousChar, self.scale_down),
            # (QKeySequence.MoveToNextChar, self.scale_up),
            (Qt.Key_K, self._callbk_skipChanged),
            (Qt.Key_P, self.startStopTimer)
        )
        for event, action in events:
            QShortcut(event, self, action)


    def reload_remote(self):
        logger.info("Reloading Remote Neuroglancer Client")
        self.remote_view()

    def exit_docs(self):
        self.main_stack_widget.setCurrentIndex(0)

    def exit_remote(self):
        self.main_stack_widget.setCurrentIndex(0)

    def exit_demos(self):
        self.main_stack_widget.setCurrentIndex(0)

    def webgl2_test(self):
        '''https://www.khronos.org/files/webgl20-reference-guide.pdf'''
        self.browser_web.setUrl(QUrl('https://get.webgl.org/webgl2/'))
        self.main_stack_widget.setCurrentIndex(1)

    def google(self):
        self.tell('Opening Google Tab...')
        self.browser = WebBrowser(self)
        self.browser.setObjectName('web_browser')
        self.browser.setUrl(QUrl('https://www.google.com'))
        self.globTabs.addTab(self.browser, 'Web Browser')
        self._setLastTab()
        # self._getTabObject()
        self._forceHideControls()

    def gpu_config(self):
        self.tell('Opening GPU Config...')
        browser = WebBrowser()
        browser.setUrl(QUrl('chrome://gpu'))
        self.globTabs.addTab(browser, 'GPU Configuration')
        self._setLastTab()
        self._forceHideControls()

    def chromium_debug(self):
        self.tell('Opening Chromium Debugger...')
        browser = WebBrowser()
        browser.setUrl(QUrl('http://127.0.0.1:9000'))
        self.globTabs.addTab(browser, 'Debug Chromium')
        self._setLastTab()
        self._forceHideControls()

    def get_ng_state(self):
        if cfg.project_tab:
            try:
                if ng.is_server_running():
                    txt = json.dumps(cfg.emViewer.state.to_json(), indent=2)
                    return f"Viewer State:\n{txt}"
                else:
                    return f"Neuroglancer Is Not Running."
            except:
                return f"N/A"
                print_exception()


    def get_ng_state_raw(self):
        if cfg.project_tab:
            try:
                if ng.is_server_running():
                    return f"Raw Viewer State:\n{cfg.emViewer.config_state.raw_state}"
                else:
                    return f"Neuroglancer Is Not Running."
            except:
                return f"N/A"
                print_exception()


    def browser_reload(self):
        try:
            self.ng_browser.reload()
        except:
            print_exception()


    def dump_ng_details(self):
        if cfg.project_tab:
            if not ng.is_server_running():
                logger.warning('Neuroglancer is not running')
                return
            v = cfg.emViewer
            self.tell("v.position: %s\n" % str(v.state.position))
            self.tell("v.config_state: %s\n" % str(v.config_state))


    def blend_ng(self):
        logger.info("blend_ng():")


    def show_splash(self):
        logger.info('Showing Splash...')
        self.temp_img_panel_index = self.viewer_stack_widget.currentIndex()
        self.splashlabel.show()
        self.viewer_stack_widget.setCurrentIndex(1)
        self.main_stack_widget.setCurrentIndex(0)
        self.splashmovie.start()

        # self.splash_widget = QWidget()  # Todo refactor this it is not in use
        # self.splash_widget.setObjectName('splash_widget')
        # self.splashmovie = QMovie('src/resources/alignem_animation.gif')
        # self.splashlabel = QLabel()
        # self.splashlabel.setMovie(self.splashmovie)
        # self.splashlabel.setMinimumSize(QSize(100, 100))
        # gl = QGridLayout()
        # gl.addWidget(self.splashlabel, 1, 1, 1, 1)
        # self.splash_widget.setLayout(gl)
        # self.splash_widget.setGraphicsEffect(QGraphicsOpacityEffect().setOpacity(0.7))
        # self.splashmovie.finished.connect(lambda: self.runaftersplash())


    def runaftersplash(self):
        self.viewer_stack_widget.setCurrentIndex(self.temp_img_panel_index)
        self.splashlabel.hide()


    def _dlg_cfg_project(self):
        if cfg.project_tab:
            dialog = ConfigProjectDialog(parent=self)
            result = dialog.exec_()
            logger.info(f'ConfigProjectDialog exit code ({result})')
        else:
            self.tell('No Project Yet!')


    def _dlg_cfg_application(self):
        dialog = ConfigAppDialog(parent=self)
        result = dialog.exec_()
        logger.info(f'ConfigAppDialog exit code ({result})')


    def _callbk_bnding_box(self, state):
        caller = inspect.stack()[1].function
        logger.info(f'Bounding Box Toggle Callback (caller: {caller})')
        if caller != 'dataUpdateWidgets':
            # self._bbToggle.setEnabled(state)
            if cfg.project_tab:
                if state:
                    self.warn('Bounding Box is now ON. Warning: Output dimensions may grow large.')
                    cfg.data['data']['scales'][cfg.data['data']['current_scale']]['use_bounding_rect'] = True
                else:
                    self.tell('Bounding Box is now OFF. Output dimensions will match source.')
                    cfg.data['data']['scales'][cfg.data['data']['current_scale']]['use_bounding_rect'] = False


    def _callbk_skipChanged(self, state:int):  # 'state' is connected to skipped toggle
        logger.critical('')
        '''Callback Function for Skip Image Toggle'''
        caller = inspect.stack()[1].function
        if self._isProjectTab():
            if caller != 'dataUpdateWidgets':
                skip_state = self._skipCheckbox.isChecked()
                for s in cfg.data.scales():
                    # layer = self.request_ng_layer()
                    layer = cfg.data.layer()
                    if layer < cfg.data.n_sections():
                        cfg.data.set_skip(skip_state, s=s, l=layer)
                    else:
                        logger.warning(f'Request layer is out of range ({layer}) - Returning')
                        return
                if skip_state:
                    self.tell("Flagged For Skip: %s" % cfg.data.name_base())
                cfg.data.link_reference_sections()
                self.dataUpdateWidgets()
                if cfg.project_tab._tabs.currentIndex() == 1:
                    cfg.project_tab.project_table.setScaleData()
            if cfg.project_tab._tabs.currentIndex() == 3:
                cfg.project_tab.snr_plot.initSnrPlot()



    def skip_change_shortcut(self):
        logger.info('')
        if cfg.data:
            if cfg.project_tab:
                if self._skipCheckbox.isChecked(): self._skipCheckbox.setChecked(False)
                else:                              self._skipCheckbox.setChecked(True)


    # def updateCorrSpotThumbnails(self, s=None, l=None):
    #     if s == None: s=cfg.data.curScale
    #     if l == None: l=cfg.data.layer()
    #     snr_vals = cfg.data.snr_components()
    #     self.corrspot_q0.set_data(path=cfg.data.corr_spot_q0_path(s=s, l=l), snr=snr_vals[0])
    #     self.corrspot_q1.set_data(path=cfg.data.corr_spot_q1_path(s=s, l=l), snr=snr_vals[1])
    #     self.corrspot_q2.set_data(path=cfg.data.corr_spot_q2_path(s=s, l=l), snr=snr_vals[2])
    #     self.corrspot_q3.set_data(path=cfg.data.corr_spot_q3_path(s=s, l=l), snr=snr_vals[3])


    def enterExitManAlignMode(self, force_exit=False):
        #Todo REFACTOR

        if cfg.data:
            if not cfg.data.is_aligned_and_generated():
                logger.warning('Cannot enter manual alignment mode until the series is aligned.')
                self.warn('The series must be aligned normally before Manual Alignment Mode can be used.')
                return

            if self._isProjectTab():
                # self.shutdownNeuroglancer()
                if (not getData('state,MANUAL_MODE')) and (not force_exit):
                    if cfg.data.is_aligned_and_generated():
                        logger.critical('Entering Manual Align Mode...')
                        self.tell('Entering Manual Align Mode...')
                        self.stopPlaybackTimer()
                        # del cfg.emViewer  # 0216+
                        self.setWindowTitle(self.window_title + ' - Manual Alignment Mode')
                        self.alignMatchPointAction.setText('Exit Manual Align Mode')
                        self.cpanel.setVisible(False)
                        self.matchpointControls.setVisible(True)
                        self._changeScaleCombo.setEnabled(False)
                        self.matchpoint_text_snr.setText(cfg.data.snr_report())
                        self.mp_marker_lineweight_spinbox.setValue(getOpt('neuroglancer,MATCHPOINT_MARKER_LINEWEIGHT'))
                        self.mp_marker_size_spinbox.setValue(getOpt('neuroglancer,MATCHPOINT_MARKER_SIZE'))
                        cfg.MP_MODE = True
                        setpOpt('state,MANUAL_MODE', True)
                        pixmap = QPixmap('src/resources/cursor_circle.png')
                        cursor = QCursor(pixmap.scaled(QSize(20, 20), Qt.KeepAspectRatio, Qt.SmoothTransformation))
                        QApplication.setOverrideCursor(cursor)
                        cfg.project_tab.onEnterManualMode()
                    else:
                        self.warn('Alignment must be generated before using Manual Point Alignment method.')
                else:
                    logger.critical('Exiting Manual Align Mode...')
                    self.tell('Exiting Manual Align Mode...')
                    self.setWindowTitle(self.window_title)
                    cfg.MP_MODE = False
                    setpOpt('state,MANUAL_MODE', False)
                    self.alignMatchPointAction.setText('Align Manually')
                    self.cpanel.setVisible(True)
                    self.matchpointControls.setVisible(False)
                    self._changeScaleCombo.setEnabled(True)
                    self.dataUpdateWidgets()
                    QApplication.restoreOverrideCursor()
                    cfg.project_tab.onExitManualMode()

                self.updateToolbar()


    def clear_match_points(self):
        if cfg.project_tab:
            logger.info('Clearing Match Points...')
            cfg.data.clearMps()
            self.dataUpdateWidgets()


    def print_all_matchpoints(self):
        if cfg.project_tab:
            cfg.data.print_all_matchpoints()


    def show_all_matchpoints(self):
        if cfg.project_tab:
            no_mps = True
            for i, l in enumerate(cfg.data.alstack()):
                r = l['images']['ref']['metadata']['man_points']
                b = l['images']['base']['metadata']['man_points']
                if r != []:
                    no_mps = False
                    self.tell(f'Layer: {i}, Ref, Match Points: {str(r)}')
                if b != []:
                    no_mps = False
                    self.tell(f'Layer: {i}, Base, Match Points: {str(b)}')
            if no_mps:
                self.tell('This project has no match points.')
            self.dataUpdateWidgets()


    def show_run_path(self) -> None:
        '''Prints the current working directory (os.getcwd), the 'running in' path, and sys.path.'''
        self.tell('\n\nWorking Directory     : %s\n'
                      'Running In (__file__) : %s' % (os.getcwd(), os.path.dirname(os.path.realpath(__file__))))


    def show_module_search_path(self) -> None:
        '''Prints the current working directory (os.getcwd), the 'running in' path, and sys.path.'''
        self.tell('\n\n' + '\n'.join(sys.path))


    def show_snr_list(self) -> None:
        if cfg.project_tab:
            s = cfg.data.curScale_val()
            lst = ' | '.join(map(str, cfg.data.snr_list()))
            self.tell('\n\nSNR List for Scale %d:\n%s\n' % (s, lst.split(' | ')))


    def show_zarr_info(self) -> None:
        if cfg.project_tab:
            z = zarr.open(os.path.join(cfg.data.dest(), 'img_aligned.zarr'))
            self.tell('\n' + str(z.tree()) + '\n' + str(z.info))


    def show_zarr_info_aligned(self) -> None:
        if cfg.project_tab:
            z = zarr.open(os.path.join(cfg.data.dest(), 'img_aligned.zarr'))
            self.tell('\n' + str(z.info) + '\n' + str(z.tree()))


    def show_zarr_info_source(self) -> None:
        if cfg.project_tab:
            z = zarr.open(os.path.join(cfg.data.dest(), 'img_src.zarr'))
            self.tell('\n' + str(z.info) + '\n' + str(z.tree()))


    def show_hide_developer_console(self):
        if self._dev_console.isHidden():
            self._dev_console.show()
        else:
            self._dev_console.hide()


    def set_opacity(self, obj, val):
        op = QGraphicsOpacityEffect(self)
        op.setOpacity(val)  # 0 to 1 -> fade effect
        obj.setGraphicsEffect(op)
        obj.setAutoFillBackground(True)


    def set_shader_none(self):
        cfg.SHADER = '''void main () {
          emitGrayscale(toNormalized(getDataValue()));
        }'''
        cfg.project_tab.initNeuroglancer()

    def set_shader_colormapJet(self):
        cfg.data['rendering']['shader'] = src.shaders.colormapJet
        cfg.project_tab.initNeuroglancer()

    def set_shader_test1(self):
        cfg.data['rendering']['shader'] = src.shaders.shader_test1
        cfg.project_tab.initNeuroglancer()

    def set_shader_test2(self):
        cfg.data['rendering']['shader'] = src.shaders.shader_test2
        cfg.project_tab.initNeuroglancer()

    def set_shader_default(self):
        cfg.data['rendering']['shader'] = src.shaders.shader_default_
        cfg.project_tab.initNeuroglancer()

    def onProfilingTimer(self):
        cpu_percent = psutil.cpu_percent()
        psutil.virtual_memory()
        percent_ram = psutil.virtual_memory().percent
        num_widgets = len(QApplication.allWidgets())
        # memory_mb = psutil.Process(os.getpid()).memory_info().rss / 1024 ** 2
        # memory_peak = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss
        print('CPU Usage: %.3f%% | RAM Usage: %.3f%%' % (cpu_percent, percent_ram))
        print('Neuoglancer Running? %r' % isNeuroglancerRunning())
        print('# Allocated Widgets: %d' % num_widgets)
        # print(f'CPU Usage    : {cpu_percent:.3f}%')
        # print(f'RAM Usage    : {percent_ram:.3f}%')
        # print(f'Memory Used  : {memory_mb:.3f}MB')
        # print(f'Memory Peak  : {memory_peak/2072576:.3f}MB')
        # print(f'# of widgets : {num_widgets}')
        # print(h.heap())


    def initToolbar(self):
        logger.info('')
        height = int(18)

        self._btn_refreshNg = QPushButton('Refresh')
        self._btn_refreshNg.setStyleSheet('font-size: 12px;')
        self._btn_refreshNg.setFixedHeight(18)
        self._btn_refreshNg.setFixedWidth(68)
        self._btn_refreshNg.setIcon(qta.icon('ei.refresh', color=cfg.ICON_COLOR))
        # self._btn_refreshNg.setFixedSize(QSize(22,22))
        self._btn_refreshNg.clicked.connect(self.refreshTab)
        self._btn_refreshNg.setStatusTip('Refresh Neuroglancer')

        self.toolbar = QToolBar()
        self.toolbar.setFixedHeight(32)
        # self.toolbar.setFixedHeight(64)
        self.toolbar.setObjectName('toolbar')
        self.addToolBar(self.toolbar)

        self.ngRbGroup = QButtonGroup()
        # 'pressed' unlike 'toggled' will trigger multiple times on multiple presses which is desired
        # 'clicked' may be most desired behavior above all...
        # self.ngRbGroup.buttonPressed.connect(self.updateMenus)
        # self.ngRbGroup.buttonPressed.connect(self.ngRadiobuttonChanged)
        # self.ngRbGroup.clicked.connect(self.ngRadiobuttonChanged)
        # self.ngRbGroup.buttonPressed.connect(self.ngRadiobuttonChanged)

        # self.ngRbGroup.buttonPressed.connect(self.updateMenus)
        # self.ngRbGroup.buttonToggled[QAbstractButton, bool].connect(self.ngRadiobuttonChanged)

        # self.rb0 = QRadioButton('Stack')
        # self.rb0 = QRadioButton('Contiguous')
        # self.rb0 = QRadioButton('Default')
        tip = 'View image stack in default layout'
        self.rb0 = QRadioButton('Unaligned')
        # self.rb0.setStyleSheet('font-size: 11px')
        self.rb0.setStatusTip(tip)
        # self.rb0.setChecked(True)
        self.rb0.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.rb0.clicked.connect(self.ngRadiobuttonChanged)
        self.rb0.clicked.connect(self.updateMenus)

        tip = 'View reference image, next to current image, [next to aligned image]'
        # self.rb1 = QRadioButton('Ref | Curr')
        # self.rb1 = QRadioButton('Compare')
        # self.rb1 = QRadioButton('Ref|Base|Aligned, Column')
        self.rb1 = QRadioButton('Comparison')
        # self.rb1.setStyleSheet('font-size: 11px')
        self.rb1.setStatusTip(tip)
        # self.rb1.setChecked(False)
        self.rb1.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.rb1.clicked.connect(self.ngRadiobuttonChanged)
        self.rb1.clicked.connect(self.updateMenus)

        self.rb2 = QRadioButton('Ref|Base|Aligned, Row')
        # self.rb2.setChecked(False)
        self.rb2.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.rb2.clicked.connect(self.ngRadiobuttonChanged)
        self.rb2.clicked.connect(self.updateMenus)
        self.rb2.hide()

        self.ngRbGroup.addButton(self.rb0)
        self.ngRbGroup.addButton(self.rb1)
        self.ngRbGroup.addButton(self.rb2)
        self.ngRbGroup.setExclusive(True)

        self._arrangeRadio = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(8, 0, 8, 0)
        hbl.addWidget(self.rb0)
        hbl.addWidget(self.rb1)
        hbl.addWidget(self.rb2)
        # hbl.addWidget(icon_sbs)
        # hbl.addWidget(self.rb2)
        self._arrangeRadio.setLayout(hbl)

        self._sectionSlider = QSlider(Qt.Orientation.Horizontal, self)
        self._sectionSlider.setFocusPolicy(Qt.StrongFocus)
        self._sectionSlider.setFixedWidth(180)
        self._sectionSlider.valueChanged.connect(self.jump_to_slider)

        tip = 'Show Neuroglancer key bindings'
        self.info_button_buffer_label = QLabel(' ')

        tip = 'Jump To Image #'
        lab = QLabel('Section: ')
        # lab.setStyleSheet('font-size: 11px;')
        lab.setObjectName('toolbar_layer_label')

        '''section # / jump-to lineedit'''
        self._jumpToLineedit = QLineEdit(self)
        self._jumpToLineedit.setStyleSheet('font-size: 11px;')
        self._jumpToLineedit.setFocusPolicy(Qt.ClickFocus)
        self._jumpToLineedit.setStatusTip(tip)
        self._jumpToLineedit.setAlignment(Qt.AlignmentFlag.AlignHCenter)
        self._jumpToLineedit.setFixedSize(QSize(36, 18))
        self._jumpToLineedit.returnPressed.connect(self.jump_to_layer)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(4, 0, 4, 0)
        hbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self._jumpToLineedit)
        self._jumpToSectionWidget = QWidget()
        self._jumpToSectionWidget.setLayout(hbl)
        # self.toolbar.addWidget(self._sectionSlider)

        self._btn_automaticPlayTimer = QPushButton()
        self._btn_automaticPlayTimer.setFixedSize(20,20)
        self._btn_automaticPlayTimer.setIcon(qta.icon('fa.play', color=cfg.ICON_COLOR))
        self.automaticPlayTimer = QTimer(self)
        self._btn_automaticPlayTimer.clicked.connect(self.startStopTimer)

        def onTimer():
            logger.info('')
            self.automaticPlayTimer.setInterval(1000 / self._fps_spinbox.value())
            if cfg.data:
                if cfg.project_tab:
                    if self._sectionSlider.value() < cfg.data.nSections - 1:
                        self._sectionSlider.setValue(self._sectionSlider.value() + 1)
                    else:
                        self._sectionSlider.setValue(0)
                        self.automaticPlayTimer.stop()
                        self._isPlayingBack = 0
                        self._btn_automaticPlayTimer.setIcon(qta.icon('fa.play', color=cfg.ICON_COLOR))

        self.automaticPlayTimer.timeout.connect(onTimer)
        self._sectionSliderWidget = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(4,0,4,0)
        hbl.addWidget(self._btn_automaticPlayTimer, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self._sectionSlider, alignment=Qt.AlignmentFlag.AlignLeft)
        self._sectionSliderWidget.setLayout(hbl)

        lab = QLabel('Speed:')
        self._fps_spinbox = QDoubleSpinBox()
        self._fps_spinbox.setStyleSheet('font-size: 11px')
        # self._fps_spinbox.setStyleSheet('font-size: 11px')
        self._fps_spinbox.setFixedHeight(20)
        self._fps_spinbox.setMinimum(.5)
        self._fps_spinbox.setMaximum(10)
        self._fps_spinbox.setSingleStep(.2)
        self._fps_spinbox.setDecimals(1)
        self._fps_spinbox.setSuffix('fps')
        self._fps_spinbox.setStatusTip('Playback Speed (frames/second)')
        self._fps_spinbox.clear()

        '''NG arrangement/layout combobox'''
        self.comboboxNgLayout = QComboBox(self)
        self.comboboxNgLayout.setStyleSheet('font-size: 11px')
        self.comboboxNgLayout.resize(QSize(76, 20))
        self.comboboxNgLayout.setFixedHeight(20)

        self.comboboxNgLayout.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        # self.comboboxNgLayout.setFixedSize(QSize(76, 20))
        items = ['4panel', 'xy', 'yz', 'xz', 'xy-3d', 'yz-3d', 'xz-3d', '3d']
        self.comboboxNgLayout.addItems(items)
        self.comboboxNgLayout.currentTextChanged.connect(self.fn_ng_layout_combobox)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(4, 0, 4, 0)
        hbl.addWidget(self.comboboxNgLayout)

        '''scale combobox'''
        self._ngLayoutWidget = QWidget()
        self._ngLayoutWidget.setLayout(hbl)
        self._changeScaleCombo = QComboBox(self)
        self._changeScaleCombo.setMinimumWidth(140)
        self._changeScaleCombo.setFixedHeight(20)
        self._changeScaleCombo.resize(QSize(140, 20))
        self._changeScaleCombo.setStyleSheet('font-size: 11px')
        self._changeScaleCombo.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        # self._changeScaleCombo.setFixedSize(QSize(160, 20))

        self._changeScaleCombo.currentTextChanged.connect(self.fn_scales_combobox)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(4, 0, 4, 0)
        hbl.addWidget(self._changeScaleCombo, alignment=Qt.AlignmentFlag.AlignRight)
        self._changeScaleWidget = QWidget()
        self._changeScaleWidget.setLayout(hbl)

        self.label_toolbar_resolution = QLabel('[dims]')
        self.label_toolbar_resolution.setObjectName('label_toolbar_resolution')
        self.label_toolbar_resolution.setFixedHeight(20)
        self.label_toolbar_resolution.hide()
        self.aligned_label = QLabel(' Aligned ')
        self.aligned_label.setObjectName('green_toolbar_label')
        self.aligned_label.setFixedHeight(20)
        self.aligned_label.hide()
        self.unaligned_label = QLabel(' Not Aligned ')
        self.unaligned_label.setObjectName('red_toolbar_label')
        self.unaligned_label.setFixedHeight(20)
        self.unaligned_label.hide()
        self.generated_label = QLabel(' Generated ')
        self.generated_label.setObjectName('green_toolbar_label')
        self.generated_label.setFixedHeight(20)
        self.generated_label.hide()
        # self.extra_header_text_label = QLabel('Match Point Mode')
        # self.extra_header_text_label.setObjectName('extra_header_text_label')
        # self.extra_header_text_label.setFixedHeight(20)
        # self.extra_header_text_label.hide()

        self._al_unal_label_widget = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.label_toolbar_resolution)
        hbl.addWidget(self.aligned_label)
        hbl.addWidget(self.unaligned_label)
        hbl.addWidget(self.generated_label)
        # hbl.addWidget(self.extra_header_text_label)
        self._al_unal_label_widget.setLayout(hbl)

        self._detachNgButton = QPushButton()
        self._detachNgButton.setFixedSize(18,18)
        self._detachNgButton.setIcon(qta.icon("fa.external-link-square", color=ICON_COLOR))
        self._detachNgButton.clicked.connect(self.detachNeuroglancer)
        self._detachNgButton.setStatusTip('Detach Neuroglancer (open in a separate window)')

        self.toolbar.addWidget(self._btn_refreshNg)
        self.toolbar.addWidget(self._arrangeRadio)
        self.toolbar.addWidget(self._al_unal_label_widget)
        w = QWidget()
        w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.toolbar.addWidget(w)
        self.toolbar.addWidget(self._jumpToSectionWidget)
        self.toolbar.addWidget(self._sectionSliderWidget)
        self.toolbar.addWidget(self._fps_spinbox)
        self.toolbar.addWidget(self._ngLayoutWidget)
        self.toolbar.addWidget(self._changeScaleWidget)
        # if cfg.DEV_MODE:
        #     self.toolbar.addWidget(self.profilingTimerButton)
        self.toolbar.addWidget(self._detachNgButton)
        self.toolbar.addWidget(self.info_button_buffer_label)


    def _disableGlobTabs(self):
        indexes = list(range(0, self.globTabs.count()))
        indexes.remove(self.globTabs.currentIndex())
        for i in indexes:
            self.globTabs.setTabEnabled(i, False)
        # self._btn_refreshNg.setEnabled(False)


    def enableAllTabs(self):
        indexes = list(range(0, self.globTabs.count()))
        for i in indexes:
            self.globTabs.setTabEnabled(i, True)
        if cfg.project_tab:
            for i in range(0,4):
                cfg.project_tab._tabs.setTabEnabled(i, True)
        # self._btn_refreshNg.setEnabled(True)


    def _isProjectTab(self):
        if self._getTabType() == 'ProjectTab':
            return True
        else:
            return False


    def _isZarrTab(self):
        if self._getTabType() == 'ZarrTab':
            return True
        else:
            return False


    def _isOpenProjTab(self):
        if self._getTabType() == 'OpenProject':
            return True
        else:
            return False


    def _getTabType(self, index=None):
        try:
            return self.globTabs.currentWidget().__class__.__name__
        except:
            return None


    def getCurrentTabWidget(self):
        return self.globTabs.currentWidget()


    def _getTabObject(self):
        return self.globTabs.currentWidget()


    def _onGlobTabChange(self):
        caller = inspect.stack()[1].function
        logger.critical('caller: %s' %caller)

        self.enableAllTabs()  # Critical - Necessary for case of glob tab closure during disabled state for MA Mode

        if self.globTabs.count() == 0:
            cfg.project_tab = None
            cfg.zarr_tab = None
            cfg.emViewer = None
            cfg.data = None
            return

        QApplication.restoreOverrideCursor()

        # if caller != 'initLaunchTab':
        #     # if caller != '_setLastTab':
        #     # if getData('state,MANUAL_MODE'):
        #     self.enterExitManAlignMode(force_exit=True)


        # if caller in ('onStartProject','_setLastTab'):
        # if caller in ('onStartProject'):
        #     return
        # logger.critical('Changing global tab (caller: %s)...' % caller)
        # cfg.selected_file = None
        self.globTabs.show()
        self.stopPlaybackTimer()
        tabtype = self._getTabType()

        if tabtype == 'OpenProject':
            # self.clearSelectionPathText()
            configure_project_paths()
            self._getTabObject().user_projects.set_data()
            # self._actions_widget.show()
            self._forceHideControls()
        # else:
        #     self._actions_widget.hide()


        if self._isProjectTab():
            logger.critical('Loading Project Tab...')
            cfg.data = self.globTabs.currentWidget().datamodel
            cfg.project_tab = self.globTabs.currentWidget()
            cfg.emViewer = cfg.project_tab.viewer
            cfg.zarr_tab = None
            self._lastRefresh = 0
            self.cpanel.show()
            self.matchpointControls.hide()
            self.update_data_cache() # 0212

            if self.shaderCodeWidget.isVisible():
                self.updateShaderText()

            if cfg.data['ui']['arrangement'] == 'stack':
                cfg.data['ui']['ng_layout'] = '4panel'
                self.rb0.setChecked(True)
            elif cfg.data['ui']['arrangement'] == 'comparison':
                cfg.data['ui']['ng_layout'] = 'xy'
                self.rb1.setChecked(True)
            self.set_nglayout_combo_text(layout=cfg.data['ui']['arrangement'])  # must be before initNeuroglancer
            self.brightnessSlider.setValue(cfg.data.brightness())
            self.contrastSlider.setValue(cfg.data.contrast())
            self.dataUpdateWidgets()
            cfg.project_tab.initNeuroglancer()
        else:
            cfg.project_tab = None
            cfg.emViewer = None
            cfg.data = None
            self._changeScaleCombo.clear()
            # self.detailsWidget.hide()
            # self.clearDetailsWidget()

        if self._isZarrTab():
            logger.critical('Loading Zarr Tab...')
            cfg.zarr_tab = self.globTabs.currentWidget()
            cfg.emViewer = cfg.zarr_tab.viewer
            self.set_nglayout_combo_text(layout='4panel')
            cfg.zarr_tab.viewer.bootstrap()

        self.updateMenus()
        self._resetSlidersAndJumpInput()  # future changes to image importing will require refactor
        self.updateToolbar()
        self.reload_scales_combobox()
        self.updateEnabledButtons()
        self.updateNotes()


    def _onGlobTabClose(self, index):
        if not self._working:
            logger.info(f'Closing Tab: {index}')
            self.globTabs.removeTab(index)


    def _setLastTab(self):
        self.globTabs.setCurrentIndex(self.globTabs.count() - 1)


    def new_mendenhall_protocol(self):
        self.new_project(mendenhall=True)
        scale = cfg.data.scale()

        cfg.data['data']['cname'] = 'none'
        cfg.data['data']['clevel'] = 5
        cfg.data['data']['chunkshape'] = (1, 512, 512)
        cfg.data['data']['scales'][scale]['resolution_x'] = 2
        cfg.data['data']['scales'][scale]['resolution_y'] = 2
        cfg.data['data']['scales'][scale]['resolution_z'] = 50
        self.mendenhall = Mendenhall(parent=self, data=cfg.data)
        self.mendenhall.set_directory()
        self.mendenhall.start_watching()
        cfg.data.set_source_path(self.mendenhall.sink)
        self._saveProjectToFile()


    def open_mendenhall_protocol(self):
        filename = open_project_dialog()
        with open(filename, 'r') as f:
            project = DataModel(json.load(f), mendenhall=True)
        cfg.data = copy.deepcopy(project)
        cfg.data.set_paths_absolute(filename=filename) #+
        self.mendenhall = Mendenhall(parent=self, data=cfg.data)
        self.mendenhall.start_watching()
        cfg.project_tab.initNeuroglancer()


    def stop_mendenhall_protocol(self):
        self.mendenhall.stop_watching()


    def aligned_mendenhall_protocol(self):
        # cfg.MV = not cfg.MV
        cfg.project_tab.initNeuroglancer()


    def import_mendenhall_protocol(self):
        ''' Import images into data '''
        scale = 'scale_1'
        logger.info('Importing Images...')
        filenames = natural_sort(os.listdir(cfg.data.source_path()))
        self.tell('Import Images:')
        logger.info(f'filenames: {filenames}')
        # for i, f in enumerate(filenames):
        #     cfg.data.append_image(f, role_name='base')
        #     cfg.data.add_img(
        #         scale_key=s,
        #         layer_index=layer_index,
        #         role=role_name,
        #         filename=None
        #     )
        cfg.data.link_reference_sections()
        logger.info(f'source path: {cfg.data.source_path()}')
        self._saveProjectToFile()

    def showActiveThreads(self, action):
        logger.info('')
        threads = '\n'.join([thread.name for thread in threading.enumerate()])
        text = f'# Active Threads : {threading.active_count()}' \
               f'Current Thread   : {threading.current_thread()}' \
               f'All Threads      : \n{threads}'
        self.menuTextActiveThreads.setText(text)


    def updateMenus(self):
        '''NOTE: This should always be run AFTER initializing Neuroglancer!'''
        caller = inspect.stack()[1].function
        logger.info('')
        self.tensorMenu.clear()
        if self._isProjectTab() or self._isZarrTab():
            # logger.info('Clearing menus...')


            def addTensorMenuInfo(label, body):
                menu = self.tensorMenu.addMenu(label)
                textedit = QTextEdit(self)
                textedit.setFixedSize(QSize(600,600))
                textedit.setReadOnly(True)
                textedit.setText(body)
                action = QWidgetAction(self)
                action.setDefaultWidget(textedit)
                menu.addAction(action)

            if self._isProjectTab():
                if cfg.unal_tensor:
                    # logger.info('Adding Raw Series tensor to menu...')
                    txt = json.dumps(cfg.unal_tensor.spec().to_json(), indent=2)
                    addTensorMenuInfo(label='Raw Series', body=txt)
                if cfg.data.is_aligned():
                    if cfg.al_tensor:
                        # logger.info('Adding Aligned Series tensor to menu...')
                        txt = json.dumps(cfg.al_tensor.spec().to_json(), indent=2)
                        addTensorMenuInfo(label='Aligned Series', body=txt)
            if self._isZarrTab():
                txt = json.dumps(cfg.tensor.spec().to_json(), indent=2)
                addTensorMenuInfo(label='Zarr Series', body=txt)

            self.updateNgMenuStateWidgets()
        else:
            self.clearNgStateMenus()


    def clearTensorMenu(self):
        self.tensorMenu.clear()
        textedit = QTextEdit(self)
        textedit.setFixedSize(QSize(50,28))
        textedit.setReadOnly(True)
        textedit.setText('N/A')
        action = QWidgetAction(self)
        action.setDefaultWidget(textedit)
        self.tensorMenu.addAction(action)


    def updateNgMenuStateWidgets(self):
        if not cfg.data:
            self.clearNgStateMenus()
            return
        textedit = QTextEdit(self)
        textedit.setFixedSize(QSize(600, 600))
        textedit.setReadOnly(True)
        textedit.setText(self.get_ng_state())
        action = QWidgetAction(self)
        action.setDefaultWidget(textedit)
        self.ngStateMenu.clear()
        self.ngStateMenu.addAction(action)


    def clearNgStateMenus(self):
        self.clearMenu(menu=self.ngStateMenu)
        # self.clearMenu(menu=self.ngRawStateMenu)

        # self.ngStateMenu.clear()
        # textedit = QTextEdit(self)
        # textedit.setFixedSize(QSize(50, 28))
        # textedit.setReadOnly(True)
        # textedit.setText('N/A')
        # action = QWidgetAction(self)
        # action.setDefaultWidget(textedit)
        # selpf.ngStateMenu.addAction(action)
        #
        # self.ngRawStateMenu.clear()
        # textedit = QTextEdit(self)
        # textedit.setFixedSize(QSize(50, 28))
        # textedit.setReadOnly(True)
        # textedit.setText('N/A')
        # action = QWidgetAction(self)
        # action.setDefaultWidget(textedit)
        # self.ngRawStateMenu.addAction(action)

    def clearMenu(self, menu):
        menu.clear()
        textedit = QTextEdit(self)
        textedit.setFixedSize(QSize(50, 28))
        textedit.setReadOnly(True)
        textedit.setText('N/A')
        action = QWidgetAction(self)
        action.setDefaultWidget(textedit)
        menu.addAction(action)



    def initMenu(self):
        '''Initialize Menu'''
        logger.info('')
        #
        # self.scManualAlign = QShortcut(QKeySequence('Ctrl+M'), self)
        # self.scManualAlign.activated.connect(self.enterExitManAlignMode)


        self.action_groups = {}
        self.menu = self.menuBar()
        self.menu.setNativeMenuBar(True)  # Fix for non-native menubar on macOS

        fileMenu = self.menu.addMenu('File')

        self.newAction = QAction('&New Project...', self)
        self.newAction.triggered.connect(self.new_project)
        self.newAction.setShortcut('Ctrl+N')
        self.addAction(self.newAction)
        fileMenu.addAction(self.newAction)

        self.openAction = QAction('&Open...', self)
        # self.openAction.triggered.connect(self.open_project)
        self.openAction.triggered.connect(self.open_project_new)
        self.openAction.setShortcut('Ctrl+O')
        self.addAction(self.openAction)
        fileMenu.addAction(self.openAction)

        # self.openArbitraryZarrAction = QAction('Open &Zarr...', self)
        # self.openArbitraryZarrAction.triggered.connect(self.open_zarr_selected)
        # self.openArbitraryZarrAction.setShortcut('Ctrl+Z')
        # fileMenu.addAction(self.openArbitraryZarrAction)

        exportMenu = fileMenu.addMenu('Export')

        self.exportAfmAction = QAction('Affines...', self)
        self.exportAfmAction.triggered.connect(self.export_afms)
        exportMenu.addAction(self.exportAfmAction)

        self.exportCafmAction = QAction('Cumulative Affines...', self)
        self.exportCafmAction.triggered.connect(self.export_cafms)
        exportMenu.addAction(self.exportCafmAction)

        self.ngRemoteAction = QAction('Remote Neuroglancer', self)
        self.ngRemoteAction.triggered.connect(self.remote_view)
        fileMenu.addAction(self.ngRemoteAction)

        self.saveAction = QAction('&Save Project', self)
        self.saveAction.triggered.connect(self.save)
        self.saveAction.setShortcut('Ctrl+S')
        self.addAction(self.saveAction)
        fileMenu.addAction(self.saveAction)

        self.savePreferencesAction = QAction('Save User Preferences', self)
        self.savePreferencesAction.triggered.connect(self.saveUserPreferences)
        fileMenu.addAction(self.savePreferencesAction)

        self.resetPreferencesAction = QAction('Set Default Preferences', self)
        self.resetPreferencesAction.triggered.connect(self.resetUserPreferences)
        fileMenu.addAction(self.resetPreferencesAction)

        self.refreshAction = QAction('&Refresh', self)
        self.refreshAction.triggered.connect(self.refreshTab)
        self.refreshAction.setShortcut('Ctrl+R')
        self.addAction(self.refreshAction)
        fileMenu.addAction(self.refreshAction)

        def fn():
            self.globTabs.removeTab(self.globTabs.currentIndex())
        self.closeTabAction = QAction('Close Tab', self)
        self.closeTabAction.triggered.connect(fn)
        self.closeTabAction.setShortcut('Ctrl+W')
        self.addAction(self.closeTabAction)
        fileMenu.addAction(self.closeTabAction)

        self.exitAppAction = QAction('&Quit', self)
        self.exitAppAction.triggered.connect(self.exit_app)
        self.exitAppAction.setShortcut('Ctrl+Q')
        self.addAction(self.exitAppAction)
        fileMenu.addAction(self.exitAppAction)

        viewMenu = self.menu.addMenu("View")

        self.ngShowScaleBarAction = QAction('Show Ng Scale Bar', self)
        self.ngShowScaleBarAction.setCheckable(True)
        self.ngShowScaleBarAction.setChecked(getOpt('neuroglancer,SHOW_SCALE_BAR'))
        self.ngShowScaleBarAction.triggered.connect(lambda val: setOpt('neuroglancer,SHOW_SCALE_BAR', val))
        self.ngShowScaleBarAction.triggered.connect(self.update_ng)
        viewMenu.addAction(self.ngShowScaleBarAction)

        self.ngShowAxisLinesAction = QAction('Show Ng Axis Lines', self)
        self.ngShowAxisLinesAction.setCheckable(True)
        self.ngShowAxisLinesAction.setChecked(getOpt('neuroglancer,SHOW_AXIS_LINES'))
        self.ngShowAxisLinesAction.triggered.connect(lambda val: setOpt('neuroglancer,SHOW_AXIS_LINES', val))
        self.ngShowAxisLinesAction.triggered.connect(self.update_ng)
        viewMenu.addAction(self.ngShowAxisLinesAction)

        self.ngShowUiControlsAction = QAction('Show Ng UI Controls', self)
        self.ngShowUiControlsAction.setCheckable(True)
        self.ngShowUiControlsAction.setChecked(getOpt('neuroglancer,SHOW_UI_CONTROLS'))
        # self.ngShowUiControlsAction.triggered.connect(self.ng_toggle_show_ui_controls)
        self.ngShowUiControlsAction.triggered.connect(lambda val: setOpt('neuroglancer,SHOW_UI_CONTROLS', val))
        self.ngShowAxisLinesAction.triggered.connect(self.update_ng)
        viewMenu.addAction(self.ngShowUiControlsAction)

        self.ngShowYellowFrameAction = QAction('Show Yellow Frame', self)
        self.ngShowYellowFrameAction.setCheckable(True)
        self.ngShowYellowFrameAction.setChecked(getOpt('neuroglancer,SHOW_YELLOW_FRAME'))
        self.ngShowYellowFrameAction.triggered.connect(lambda val: setOpt('neuroglancer,SHOW_YELLOW_FRAME', val))
        self.ngShowYellowFrameAction.triggered.connect(self.update_ng)
        viewMenu.addAction(self.ngShowYellowFrameAction)

        def fn():
            cfg.project_tab.spreadW.setVisible(getOpt('neuroglancer,SHOW_UI_CONTROLS'))
            cfg.project_tab.updateUISpacing()
        self.ngShowUiControlsAction.triggered.connect(fn)
        self.ngShowUiControlsAction.triggered.connect(self.update_ng)
        viewMenu.addAction(self.ngShowUiControlsAction)

        # self.showCorrSpotsAction = QAction('Show Correlation Spots', self)
        # self.showCorrSpotsAction.setCheckable(True)
        # self.showCorrSpotsAction.setChecked(getOpt('ui,SHOW_CORR_SPOTS'))
        # self.showCorrSpotsAction.triggered.connect(lambda val: setOpt('ui,SHOW_CORR_SPOTS', val))
        # self.showCorrSpotsAction.triggered.connect(self.update_displayed_controls)
        # viewMenu.addAction(self.showCorrSpotsAction)

        # self.ngShowPanelBordersAction = QAction('Show Ng Panel Borders', self)
        # self.ngShowPanelBordersAction.setCheckable(True)
        # self.ngShowPanelBordersAction.setChecked(getOpt('neuroglancer,SHOW_PANEL_BORDERS'))
        # self.ngShowPanelBordersAction.triggered.connect(lambda val: setOpt('neuroglancer,SHOW_PANEL_BORDERS', val))
        # self.ngShowPanelBordersAction.triggered.connect(self.update_ng)
        # ngMenu.addAction(self.ngShowPanelBordersAction)

        self.ngShowAlignmentDetailsAction = QAction('Show Alignment Details', self)
        self.ngShowAlignmentDetailsAction.setCheckable(True)
        self.ngShowAlignmentDetailsAction.setChecked(getOpt('neuroglancer,SHOW_ALIGNMENT_DETAILS'))
        self.ngShowAlignmentDetailsAction.triggered.connect(
            lambda val: setOpt('neuroglancer,SHOW_ALIGNMENT_DETAILS', val))
        self.ngShowAlignmentDetailsAction.triggered.connect(self.dataUpdateWidgets)
        viewMenu.addAction(self.ngShowAlignmentDetailsAction)

        # self.colorMenu = ngMenu.addMenu('Select Background Color')
        # from qtpy.QtWidgets import QColorDialog
        # self.ngColorMenu= QColorDialog(self)
        # action = QWidgetAction(self)
        # action.setDefaultWidget(self.ngColorMenu)
        # # self.ngStateMenu.hovered.connect(self.updateNgMenuStateWidgets)
        # self.colorMenu.addAction(action)


        alignMenu = self.menu.addMenu('Align')

        menu = alignMenu.addMenu('History')
        action = QWidgetAction(self)
        action.setDefaultWidget(self._tool_hstry)
        menu.addAction(action)

        self.alignAllAction = QAction('Align All', self)
        self.alignAllAction.triggered.connect(self.alignAll)
        self.alignAllAction.setShortcut('Ctrl+A')
        alignMenu.addAction(self.alignAllAction)

        self.alignOneAction = QAction('Align One', self)
        self.alignOneAction.triggered.connect(self.alignOne)
        alignMenu.addAction(self.alignOneAction)

        self.alignMatchPointAction = QAction('Align Manually', self)
        self.alignMatchPointAction.triggered.connect(self.enterExitManAlignMode)
        self.alignMatchPointAction.setShortcut('Ctrl+M')
        alignMenu.addAction(self.alignMatchPointAction)
        # self.addAction(self.alignMatchPointAction)

        self.skipChangeAction = QAction('Toggle Skip', self)
        self.skipChangeAction.triggered.connect(self.skip_change_shortcut)
        self.skipChangeAction.setShortcut('Ctrl+K')
        self.addAction(self.skipChangeAction)
        alignMenu.addAction(self.skipChangeAction)

        self.showMatchpointsAction = QAction('Show Matchpoints', self)
        self.showMatchpointsAction.triggered.connect(self.show_all_matchpoints)
        alignMenu.addAction(self.showMatchpointsAction)

        mendenhallMenu = alignMenu.addMenu('Mendenhall Protocol')

        self.newMendenhallAction = QAction('New', self)
        self.newMendenhallAction.triggered.connect(self.new_mendenhall_protocol)
        mendenhallMenu.addAction(self.newMendenhallAction)

        self.openMendenhallAction = QAction('Open', self)
        self.openMendenhallAction.triggered.connect(self.open_mendenhall_protocol)
        mendenhallMenu.addAction(self.openMendenhallAction)

        self.importMendenhallAction = QAction('Import', self)
        self.importMendenhallAction.triggered.connect(self.import_mendenhall_protocol)
        mendenhallMenu.addAction(self.importMendenhallAction)

        self.alignedMendenhallAction = QAction('Sunny Side Up', self)
        self.alignedMendenhallAction.triggered.connect(self.aligned_mendenhall_protocol)
        mendenhallMenu.addAction(self.alignedMendenhallAction)

        self.stopMendenhallAction = QAction('Stop', self)
        self.stopMendenhallAction.triggered.connect(self.stop_mendenhall_protocol)
        mendenhallMenu.addAction(self.stopMendenhallAction)


        ngMenu = self.menu.addMenu("Neuroglancer")

        self.ngStateMenu = ngMenu.addMenu('JSON State') #get_ng_state
        self.ngStateMenuText = QTextEdit(self)
        self.ngStateMenuText.setReadOnly(False)
        action = QWidgetAction(self)
        action.setDefaultWidget(self.ngStateMenuText)
        # self.ngStateMenu.hovered.connect(self.updateNgMenuStateWidgets)
        ngMenu.hovered.connect(self.updateNgMenuStateWidgets)
        self.ngStateMenu.addAction(action)
        self.clearNgStateMenus()

        self.tensorMenu = ngMenu.addMenu('Tensors')
        self.clearTensorMenu()

        ngPerspectiveMenu = ngMenu.addMenu("Perspective")

        self.ngLayout1Action = QAction('xy', self)
        self.ngLayout2Action = QAction('xz', self)
        self.ngLayout3Action = QAction('yz', self)
        self.ngLayout4Action = QAction('yz-3d', self)
        self.ngLayout5Action = QAction('xy-3d', self)
        self.ngLayout6Action = QAction('xz-3d', self)
        self.ngLayout7Action = QAction('3d', self)
        self.ngLayout8Action = QAction('4panel', self)
        ngPerspectiveMenu.addAction(self.ngLayout1Action)
        ngPerspectiveMenu.addAction(self.ngLayout2Action)
        ngPerspectiveMenu.addAction(self.ngLayout3Action)
        ngPerspectiveMenu.addAction(self.ngLayout4Action)
        ngPerspectiveMenu.addAction(self.ngLayout5Action)
        ngPerspectiveMenu.addAction(self.ngLayout6Action)
        ngPerspectiveMenu.addAction(self.ngLayout7Action)
        ngPerspectiveMenu.addAction(self.ngLayout8Action)
        self.ngLayout1Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('xy'))
        self.ngLayout2Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('xz'))
        self.ngLayout3Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('yz'))
        self.ngLayout4Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('yz-3d'))
        self.ngLayout5Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('xy-3d'))
        self.ngLayout6Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('xz-3d'))
        self.ngLayout6Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('3d'))
        self.ngLayout8Action.triggered.connect(lambda: self.comboboxNgLayout.setCurrentText('4panel'))
        ngLayoutActionGroup = QActionGroup(self)
        ngLayoutActionGroup.setExclusive(True)
        ngLayoutActionGroup.addAction(self.ngLayout1Action)
        ngLayoutActionGroup.addAction(self.ngLayout2Action)
        ngLayoutActionGroup.addAction(self.ngLayout3Action)
        ngLayoutActionGroup.addAction(self.ngLayout4Action)
        ngLayoutActionGroup.addAction(self.ngLayout5Action)
        ngLayoutActionGroup.addAction(self.ngLayout6Action)
        ngLayoutActionGroup.addAction(self.ngLayout7Action)
        ngLayoutActionGroup.addAction(self.ngLayout8Action)
        # self.ngLayout1Action.setCheckable(True)
        # self.ngLayout1Action.setChecked(True)
        # self.ngLayout2Action.setCheckable(True)
        # self.ngLayout3Action.setCheckable(True)
        # self.ngLayout4Action.setCheckable(True)
        # self.ngLayout5Action.setCheckable(True)
        # self.ngLayout6Action.setCheckable(True)
        # self.ngLayout7Action.setCheckable(True)
        # self.ngLayout8Action.setCheckable(True)
        #
        # ngArrangementMenu = ngMenu.addMenu("Arrangement")
        #
        # self.soloViewAction = QAction('Stack', self)
        # self.soloViewAction.triggered.connect(lambda: self.rb0.setChecked(True))
        # self.soloViewAction.triggered.connect(self.updateMenus)
        # ngArrangementMenu.addAction(self.soloViewAction)
        #
        # self.colViewAction = QAction('Column', self)
        # self.colViewAction.triggered.connect(lambda: self.rb1.setChecked(True))
        # self.colViewAction.triggered.connect(self.updateMenus)
        #
        # ngArrangementMenu.addAction(self.colViewAction)
        #
        # self.rowViewAction = QAction('Row', self)
        # self.rowViewAction.triggered.connect(lambda: self.rb2.setChecked(True))
        # self.rowViewAction.triggered.connect(self.updateMenus)
        # ngArrangementMenu.addAction(self.rowViewAction)


        ngShaderMenu = ngMenu.addMenu("Experimental Shaders")

        self.shader1Action = QAction('None', self)
        self.shader1Action.triggered.connect(self.set_shader_none)
        ngShaderMenu.addAction(self.shader1Action)

        self.shaderDefaultAction = QAction('default', self)
        self.shaderDefaultAction.triggered.connect(self.set_shader_default)
        ngShaderMenu.addAction(self.shaderDefaultAction)

        self.shader2Action = QAction('colorMap Jet', self)
        self.shader2Action.triggered.connect(self.set_shader_colormapJet)
        ngShaderMenu.addAction(self.shader2Action)

        self.shader3Action = QAction('shader_test1', self)
        self.shader3Action.triggered.connect(self.set_shader_test1)
        ngShaderMenu.addAction(self.shader3Action)

        self.shader4Action = QAction('shader_test2', self)
        self.shader4Action.triggered.connect(self.set_shader_test2)
        ngShaderMenu.addAction(self.shader4Action)



        shaderActionGroup = QActionGroup(self)
        shaderActionGroup.setExclusive(True)
        shaderActionGroup.addAction(self.shader1Action)
        shaderActionGroup.addAction(self.shader2Action)
        shaderActionGroup.addAction(self.shader3Action)
        shaderActionGroup.addAction(self.shader4Action)
        self.shader1Action.setCheckable(True)
        self.shader1Action.setChecked(True)
        self.shader2Action.setCheckable(True)
        self.shader3Action.setCheckable(True)
        self.shader4Action.setCheckable(True)


        self.detachNgAction = QAction('Detach Neuroglancer...', self)
        self.detachNgAction.triggered.connect(self.detachNeuroglancer)
        ngMenu.addAction(self.detachNgAction)

        self.hardRestartNgNgAction = QAction('Hard Restart Neuroglancer', self)
        self.hardRestartNgNgAction.triggered.connect(self.hardRestartNg)
        ngMenu.addAction(self.hardRestartNgNgAction)

        actionsMenu = self.menu.addMenu('Actions')

        self.rescaleAction = QAction('Rescale...', self)
        self.rescaleAction.triggered.connect(self.rescale)
        actionsMenu.addAction(self.rescaleAction)

        self.rechunkAction = QAction('Rechunk...', self)
        self.rechunkAction.triggered.connect(self.rechunk)
        actionsMenu.addAction(self.rechunkAction)


        configMenu = self.menu.addMenu('Configure')

        self.projectConfigAction = QAction('Configure Project...', self)
        self.projectConfigAction.triggered.connect(self._dlg_cfg_project)
        configMenu.addAction(self.projectConfigAction)

        self.appConfigAction = QAction('Configure Debugging...', self)
        self.appConfigAction.triggered.connect(self._dlg_cfg_application)
        configMenu.addAction(self.appConfigAction)

        self.setPlaybackSpeedAction = QAction('Configure Playback...', self)
        self.setPlaybackSpeedAction.triggered.connect(self.setPlaybackSpeed)
        configMenu.addAction(self.setPlaybackSpeedAction)

        debugMenu = self.menu.addMenu('Debug')

        self.initViewAction = QAction('Fix View', self)
        self.initViewAction.triggered.connect(self.initView)
        debugMenu.addAction(self.initViewAction)

        tracemallocMenu = debugMenu.addMenu('tracemalloc')


        self.tracemallocStartAction = QAction('Start', self)
        self.tracemallocStartAction.triggered.connect(tracemalloc_start)
        tracemallocMenu.addAction(self.tracemallocStartAction)

        self.tracemallocCompareAction = QAction('Snapshot/Compare', self)
        self.tracemallocCompareAction.triggered.connect(tracemalloc_compare)
        tracemallocMenu.addAction(self.tracemallocCompareAction)

        self.tracemallocStopAction = QAction('Stop', self)
        self.tracemallocStopAction.triggered.connect(tracemalloc_stop)
        tracemallocMenu.addAction(self.tracemallocStopAction)

        self.tracemallocClearAction = QAction('Clear Traces', self)
        self.tracemallocClearAction.triggered.connect(tracemalloc_clear)
        tracemallocMenu.addAction(self.tracemallocClearAction)

        self.debugWebglAction = QAction('Web GL Test', self)
        self.debugWebglAction.triggered.connect(self.webgl2_test)
        debugMenu.addAction(self.debugWebglAction)

        self.debugGpuAction = QAction('GPU Configuration', self)
        self.debugGpuAction.triggered.connect(self.gpu_config)
        debugMenu.addAction(self.debugGpuAction)

        self.chromiumDebugAction = QAction('Troubleshoot Chromium', self)
        self.chromiumDebugAction.triggered.connect(self.chromium_debug)
        debugMenu.addAction(self.chromiumDebugAction)

        def fn():
            try:
                log = json.dumps(cfg.webdriver.get_log(), indent=2)
            except:
                log = 'Webdriver is offline.'
            self.menuTextWebdriverLog.setText(log)

        menu = debugMenu.addMenu('Webdriver Log')
        self.menuTextWebdriverLog = QTextEdit(self)
        self.menuTextWebdriverLog.setReadOnly(True)
        self.menuTextWebdriverLog.setText('Webdriver is offline.')
        action = QWidgetAction(self)
        action.setDefaultWidget(self.menuTextWebdriverLog)
        menu.hovered.connect(fn)
        debugMenu.hovered.connect(fn)
        menu.addAction(action)


        def fn():
            try:
                log = json.dumps(cfg.webdriver.get_log(), indent=2)
            except:
                log = 'Webdriver is offline.'
            self.menuTextWebdriverLog.setText(log)

        menu = debugMenu.addMenu('Debug Dump')
        self.menuTextWebdriverLog = QTextEdit(self)
        self.menuTextWebdriverLog.setReadOnly(True)
        action = QWidgetAction(self)
        action.setDefaultWidget(self.menuTextWebdriverLog)
        menu.hovered.connect(fn)
        debugMenu.hovered.connect(fn)
        menu.addAction(action)


        def fn():
            threads = '\n'.join([thread.name for thread in threading.enumerate()])
            html = \
            f"""<html><body>
            <h4><b>Active Threads :</b></h4>
            <p>{threading.active_count()}</p>
            <h4><b>Current Thread :</b></h4>
            <p>{threading.current_thread()}</p>
            <h4><b>Active Threads :</b></h4>
            <p>{threads}</p>
            </body></html>"""
            self.menuTextActiveThreads.setText(html)

        menu = debugMenu.addMenu('Active Threads')
        self.menuTextActiveThreads = QTextEdit(self)
        self.menuTextActiveThreads.setReadOnly(True)
        action = QWidgetAction(self)
        action.setDefaultWidget(self.menuTextActiveThreads)
        menu.hovered.connect(fn)
        debugMenu.hovered.connect(fn)
        menu.addAction(action)

        self.moduleSearchPathAction = QAction('Module Search Path', self)
        self.moduleSearchPathAction.triggered.connect(self.show_module_search_path)
        debugMenu.addAction(self.moduleSearchPathAction)

        self.runtimePathAction = QAction('Runtime Path', self)
        self.runtimePathAction.triggered.connect(self.show_run_path)
        debugMenu.addAction(self.runtimePathAction)

        overrideMenu = debugMenu.addMenu('Override')

        self.anableAllControlsAction = QAction('Enable All Controls', self)
        self.anableAllControlsAction.triggered.connect(self.enableAllButtons)
        overrideMenu.addAction(self.anableAllControlsAction)

        if cfg.DEV_MODE:
            # developerMenu = debugMenu.addMenu('Developer')
            self.developerConsoleAction = QAction('Developer Console', self)
            self.developerConsoleAction.triggered.connect(self.show_hide_developer_console)
            debugMenu.addAction(self.developerConsoleAction)

        from src.ui.snr_plot import SnrPlot
        tw = SnrPlot()

        testMenu = debugMenu.addMenu('Test Menu Widgets')
        action = QWidgetAction(self)
        action.setDefaultWidget(tw)
        testMenu.addAction(action)

        helpMenu = self.menu.addMenu('Help')

        menu = helpMenu.addMenu('Keyboard Bindings')
        textbrowser = QTextBrowser(self)
        textbrowser.setSource(QUrl('src/resources/KeyboardCommands.html'))
        action = QWidgetAction(self)
        action.setDefaultWidget(textbrowser)
        menu.addAction(action)

        menu = helpMenu.addMenu('SWiFT-IR Components')
        textbrowser = QTextBrowser(self)
        textbrowser.setSource(QUrl('src/resources/swiftir_components.html'))
        action = QWidgetAction(self)
        action.setDefaultWidget(textbrowser)
        menu.addAction(action)


        action = QAction('SWiFT-IR Examples', self)
        action.triggered.connect(self.view_swiftir_examples)
        helpMenu.addAction(action)

        # self.reloadBrowserAction = QAction('Reload QtWebEngine', self)
        # self.reloadBrowserAction.triggered.connect(self.browser_reload)
        # helpMenu.addAction(self.reloadBrowserAction)

        action = QAction('Remod Help', self)
        action.triggered.connect(self.html_view)
        helpMenu.addAction(action)

        self.featuresAction = QAction('AlignEM-SWiFT Features', self)
        self.featuresAction.triggered.connect(lambda: self.html_resource(resource='features.html', title='Features'))
        helpMenu.addAction(self.featuresAction)

        self.documentationAction = QAction('Documentation', self)
        self.documentationAction.triggered.connect(self.documentation_view)
        helpMenu.addAction(self.documentationAction)

        self.googleAction = QAction('Google', self)
        self.googleAction.triggered.connect(self.google)
        helpMenu.addAction(self.googleAction)


    # @Slot()
    # def widgetsUpdateData(self) -> None:
    #     '''Reads MainWindow to Update Project Data.'''
    #     logger.debug('widgetsUpdateData:')

    def set_corrspot_size(self, size):
        # self.corrspot_q0.setFixedHeight(h)
        # self.corrspot_q1.setFixedHeight(h)
        # self.corrspot_q2.setFixedHeight(h)
        # self.corrspot_q3.setFixedHeight(h)
        self.corrspot_q0.setFixedSize(size,size)
        self.corrspot_q1.setFixedSize(size,size)
        self.corrspot_q2.setFixedSize(size,size)
        self.corrspot_q3.setFixedSize(size,size)
        # self.corrspot_q0.resize(size,size)
        # self.corrspot_q1.resize(size,size)
        # self.corrspot_q2.resize(size,size)
        # self.corrspot_q3.resize(size,size)



    def _valueChangedSwimWindow(self):
        # logger.info('')
        caller = inspect.stack()[1].function
        # if caller == 'initControlPanel': return
        if caller == 'main':
            logger.info(f'caller: {caller}')
            cfg.data.set_swim_window(float(self._swimWindowControl.value()) / 100.)

    def _valueChangedWhitening(self):
        # logger.info('')
        caller = inspect.stack()[1].function
        # if caller != 'initControlPanel':
        if caller == 'main':
            logger.info(f'caller: {caller}')
            cfg.data.set_whitening(float(self._whiteningControl.value()))


    def _valueChangedPolyOrder(self):
        # logger.info('')
        caller = inspect.stack()[1].function
        if caller == 'initControlPanel': return
        logger.info(f'caller: {caller}')
        if self._polyBiasCombo.currentText() == 'None':
            cfg.data.set_use_poly_order(False)
        else:
            cfg.data.set_use_poly_order(True)
            cfg.data.set_poly_order(self._polyBiasCombo.currentText())


    def _toggledAutogenerate(self) -> None:
        # logger.info('')
        caller = inspect.stack()[1].function
        if caller == 'initControlPanel': return
        logger.info(f'caller: {caller}')

        if self._toggleAutogenerate.isChecked():
            self.tell('Images will be generated automatically after alignment')
        else:
            self.tell('Images will not be generated automatically after alignment')


    def rechunk(self):
        if self._isProjectTab():
            if cfg.data.is_aligned_and_generated():
                target = os.path.join(cfg.data.dest(), 'img_aligned.zarr', 's%d' % cfg.data.scale_val())
                _src = os.path.join(cfg.data.dest(), 'img_aligned.zarr', '_s%d' % cfg.data.scale_val())
            else:
                target = os.path.join(cfg.data.dest(), 'img_src.zarr', 's%d' % cfg.data.scale_val())
                _src = os.path.join(cfg.data.dest(), 'img_src.zarr', '_s%d' % cfg.data.scale_val())

            dlg = RechunkDialog(self, target=target)
            if dlg.exec():

                t_start = time.time()

                logger.info('Rechunking...')
                chunkshape = cfg.data['data']['chunkshape']
                intermediate = "intermediate.zarr"

                os.rename(target, _src)
                try:
                    source = zarr.open(store=_src)
                    self.tell('Configuring rechunking (target: %s). New chunk shape: %s...' % (target, str(chunkshape)))
                    logger.info('Configuring rechunk operation (target: %s)...' % target)
                    rechunked = rechunk(
                        source=source,
                        target_chunks=chunkshape,
                        target_store=target,
                        max_mem=100_000_000_000,
                        temp_store=intermediate
                    )
                    self.tell('Rechunk plan:\n%s' % str(rechunked))
                except:
                    self.warn('Unable to rechunk the array')
                    print_exception()
                    os.rename(_src, target) # set name back to original name
                    return

                self.tell('Rechunking...')
                logger.info('Rechunking...')
                rechunked.execute()
                self.hud.done()

                logger.info('Removing %s...' %intermediate)
                self.tell('Removing %s...' %intermediate)
                shutil.rmtree(intermediate, ignore_errors=True)
                shutil.rmtree(intermediate, ignore_errors=True)

                logger.info('Removing %s...' %_src)
                self.tell('Removing %s...' %_src)
                shutil.rmtree(_src, ignore_errors=True)
                shutil.rmtree(_src, ignore_errors=True)
                self.hud.done()

                t_end = time.time()
                dt = t_end - t_start
                z = zarr.open(store=target)
                info = str(z.info)
                self.tell('\n%s' %info)

                self.tell('Rechunking Time: %.2f' % dt)
                logger.info('Rechunking Time: %.2f' % dt)

                cfg.project_tab.initNeuroglancer()

            else:
                logger.info('Rechunking Canceled')


    def initControlPanel(self):

        button_size = QSize(54, 20)
        std_input_size = QSize(74, 20)
        std_button_size = QSize(96, 20)
        normal_button_size = QSize(64, 22)
        baseline = Qt.AlignmentFlag.AlignBaseline
        vcenter  = Qt.AlignmentFlag.AlignVCenter
        hcenter  = Qt.AlignmentFlag.AlignHCenter
        center   = Qt.AlignmentFlag.AlignCenter
        left     = Qt.AlignmentFlag.AlignLeft
        right    = Qt.AlignmentFlag.AlignRight

        tip = 'Set Whether to Use or Reject the Current Layer'
        self._lab_keep_reject = QLabel('Reject:')
        # self._lab_keep_reject.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414; color: #141414')
        self._lab_keep_reject.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        self._lab_keep_reject.setStatusTip(tip)
        self._skipCheckbox = QCheckBox()
        self._skipCheckbox.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._skipCheckbox.setObjectName('_skipCheckbox')
        self._skipCheckbox.stateChanged.connect(self._callbk_skipChanged)
        self._skipCheckbox.stateChanged.connect(self._callbk_unsavedChanges)
        self._skipCheckbox.setStatusTip(tip)
        self._skipCheckbox.setEnabled(False)
        lay = QHBoxLayout()
        lay.setContentsMargins(2, 0, 2, 0)
        lay.addWidget(self._lab_keep_reject, alignment=right)
        lay.addWidget(self._skipCheckbox, alignment=left)
        self._ctlpanel_skip = QWidget()
        self._ctlpanel_skip.setLayout(lay)

        tip = 'Use All Images (Reset)'
        self._btn_clear_skips = QPushButton('Reset')
        self._btn_clear_skips.setEnabled(False)
        self._btn_clear_skips.setStyleSheet("font-size: 10px;")
        self._btn_clear_skips.setStatusTip(tip)
        self._btn_clear_skips.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._btn_clear_skips.clicked.connect(self.clear_skips)
        self._btn_clear_skips.setFixedSize(button_size)

        tip = "Whitening factor used for Signal Whitening Fourier Transform Image Registration (default=-0.68)"
        lab = QLabel("Whitening\nFactor:")
        lab.setAlignment(right)
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        self._whiteningControl = QDoubleSpinBox(self)
        self._whiteningControl.setFixedHeight(26)
        self._whiteningControl.valueChanged.connect(self._callbk_unsavedChanges)
        self._whiteningControl.valueChanged.connect(self._valueChangedWhitening)
        self._whiteningControl.setAlignment(Qt.AlignmentFlag.AlignCenter)
        # self._whiteningControl.setValue(cfg.DEFAULT_WHITENING)
        self._whiteningControl.setFixedSize(std_input_size)
        self._whiteningControl.setDecimals(2)
        self._whiteningControl.setSingleStep(.01)
        self._whiteningControl.setMinimum(-2)
        self._whiteningControl.setMaximum(2)
        # self._whiteningControl.setEnabled(False)
        lab.setStatusTip(tip)
        self._whiteningControl.setStatusTip(tip)
        lay = QHBoxLayout()
        lay.addWidget(lab, alignment=right)
        lay.addWidget(self._whiteningControl, alignment=left)
        lay.setContentsMargins(0, 0, 0, 0)
        self._ctlpanel_whitening = QWidget()
        self._ctlpanel_whitening.setLayout(lay)

        tip = "The region size SWIM uses for computing alignment, specified as percentage of image" \
              "width. (default=81.25%)"
        lab = QLabel("SWIM\nWindow:")
        lab.setAlignment(right)
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        self._swimWindowControl = QDoubleSpinBox(self)
        self._swimWindowControl.setSuffix('%')
        self._swimWindowControl.setFixedHeight(26)
        self._swimWindowControl.valueChanged.connect(self._callbk_unsavedChanges)
        self._swimWindowControl.valueChanged.connect(self._valueChangedSwimWindow)
        self._swimWindowControl.setAlignment(Qt.AlignmentFlag.AlignCenter)
        # self._swimWindowControl.setValue(cfg.DEFAULT_SWIM_WINDOW)
        self._swimWindowControl.setFixedSize(std_input_size)
        self._swimWindowControl.setDecimals(2)
        # self._swimWindowControl.setEnabled(False)
        lab.setStatusTip(tip)
        self._swimWindowControl.setStatusTip(tip)
        lay = QHBoxLayout()
        lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(lab, alignment=right)
        lay.addWidget(self._swimWindowControl, alignment=left)
        self._ctlpanel_inp_swimWindow = QWidget()
        self._ctlpanel_inp_swimWindow.setLayout(lay)

        # tip = 'Apply SWIM Window and Whitening Factor settings to entire dataset.'
        self._ctlpanel_applyAllButton = QPushButton("Apply To All\nSections")
        self._ctlpanel_applyAllButton.setEnabled(False)
        self._ctlpanel_applyAllButton.setStatusTip('Apply These Settings To The Entire Image Stack')
        self._ctlpanel_applyAllButton.setStyleSheet("font-size: 9px;")
        self._ctlpanel_applyAllButton.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._ctlpanel_applyAllButton.clicked.connect(self.apply_all)
        # self._ctlpanel_applyAllButton.setFixedSize(QSize(54, 20))
        self._ctlpanel_applyAllButton.setFixedSize(normal_button_size)

        # hbl = QHBoxLayout()
        # hbl.setContentsMargins(0, 0, 0, 0)
        # hbl.addWidget(self._ctlpanel_inp_swimWindow)
        # hbl.addWidget(self._ctlpanel_whitening)
        # hbl.addWidget(self._ctlpanel_applyAllButton)

        tip = 'Go To Previous Section.'
        self._prevSectionBtn = QPushButton()
        self._prevSectionBtn.setStyleSheet("font-size: 11px;")
        self._prevSectionBtn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._prevSectionBtn.setStatusTip(tip)
        self._prevSectionBtn.clicked.connect(self.layer_left)
        self._prevSectionBtn.setFixedSize(QSize(18, 18))
        self._prevSectionBtn.setIcon(qta.icon("fa.arrow-left", color=ICON_COLOR))
        self._prevSectionBtn.setEnabled(False)

        tip = 'Go To Next Section.'
        self._nextSectionBtn = QPushButton()
        self._nextSectionBtn.setStyleSheet("font-size: 11px;")
        self._nextSectionBtn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._nextSectionBtn.setStatusTip(tip)
        self._nextSectionBtn.clicked.connect(self.layer_right)
        self._nextSectionBtn.setFixedSize(QSize(18, 18))
        self._nextSectionBtn.setIcon(qta.icon("fa.arrow-right", color=ICON_COLOR))
        self._nextSectionBtn.setEnabled(False)

        self._sectionChangeWidget = QWidget()
        lab = QLabel('Section:')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(lab, alignment=right)
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self._prevSectionBtn, alignment=right)
        hbl.addWidget(self._nextSectionBtn, alignment=left)
        self._sectionChangeWidget.setLayout(hbl)

        tip = 'Go To Previous Scale.'
        self._scaleDownButton = QPushButton()
        self._scaleDownButton.setEnabled(False)
        self._scaleDownButton.setStyleSheet("font-size: 11px;")
        self._scaleDownButton.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._scaleDownButton.setStatusTip(tip)
        self._scaleDownButton.clicked.connect(self.scale_down)
        self._scaleDownButton.setFixedSize(QSize(18, 18))
        self._scaleDownButton.setIcon(qta.icon("fa.arrow-left", color=ICON_COLOR))

        tip = 'Go To Next Scale.'
        self._scaleUpButton = QPushButton()
        self._scaleUpButton.setEnabled(False)
        self._scaleUpButton.setStyleSheet("font-size: 11px;")
        self._scaleUpButton.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._scaleUpButton.setStatusTip(tip)
        self._scaleUpButton.clicked.connect(self.scale_up)
        self._scaleUpButton.setFixedSize(QSize(18, 18))
        self._scaleUpButton.setIcon(qta.icon("fa.arrow-right", color=ICON_COLOR))

        self._scaleSetWidget = QWidget()
        lab = QLabel('Scale:')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(lab, alignment=right)
        hbl.addWidget(self._scaleDownButton, alignment=right)
        hbl.addWidget(self._scaleUpButton, alignment=left)
        self._scaleSetWidget.setLayout(hbl)

        # lab = QLabel('Scale:')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        # self._ctlpanel_changeScale = QWidget()
        # lay = QHBoxLayout()
        # lay.setContentsMargins(0, 0, 0, 0)
        # lay.addWidget(lab, alignment=right)
        # lay.addWidget(self._scaleSetWidget, alignment=left)
        # self._ctlpanel_changeScale.setLayout(lay)

        tip = 'Align and Generate All Sections'
        self._btn_alignAll = QPushButton('Align All')
        self._btn_alignAll.setEnabled(False)
        self._btn_alignAll.setStyleSheet("font-size: 10px;")
        self._btn_alignAll.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._btn_alignAll.setStatusTip(tip)
        self._btn_alignAll.clicked.connect(self.alignAll)
        self._btn_alignAll.setFixedSize(normal_button_size)

        tip = 'Align and Generate the Current Section Only'
        self._btn_alignOne = QPushButton('Align One')
        self._btn_alignOne.setEnabled(False)
        self._btn_alignOne.setStyleSheet("font-size: 10px;")
        self._btn_alignOne.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._btn_alignOne.setStatusTip(tip)
        self._btn_alignOne.clicked.connect(self.alignOne)
        self._btn_alignOne.setFixedSize(normal_button_size)

        self.sectionRangeSlider = RangeSlider()
        self.sectionRangeSlider.setStyleSheet('border-radius: 2px;')
        self.sectionRangeSlider.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.sectionRangeSlider.setFixedWidth(120)
        self.sectionRangeSlider.setMin(0)
        self.sectionRangeSlider.setStart(0)

        self.startRangeInput = QLineEdit()
        self.startRangeInput.setFixedSize(34,22)
        self.startRangeInput.setEnabled(False)

        self.endRangeInput = QLineEdit()
        self.endRangeInput.setFixedSize(34,22)
        self.endRangeInput.setEnabled(False)

        self.rangeInputWidget = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(2, 0, 2, 0)
        hbl.setSpacing(0)
        hbl.addWidget(self.startRangeInput)
        hbl.addWidget(QLabel(':'))
        hbl.addWidget(self.endRangeInput)
        self.rangeInputWidget.setLayout(hbl)

        self.sectionRangeSlider.startValueChanged.connect(lambda val: self.startRangeInput.setText(str(val)))
        self.sectionRangeSlider.endValueChanged.connect(lambda val: self.endRangeInput.setText(str(val)))
        self.startRangeInput.textChanged.connect(lambda val: self.sectionRangeSlider.setStart(int(val)))
        self.endRangeInput.textChanged.connect(lambda val: self.sectionRangeSlider.setEnd(int(val)))


        tip = 'Align and Generate a Range of Sections'
        self._btn_alignRange = QPushButton('Align Range')
        self._btn_alignRange.setEnabled(False)
        self._btn_alignRange.setStyleSheet("font-size: 10px;")
        self._btn_alignRange.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._btn_alignRange.setStatusTip(tip)
        self._btn_alignRange.clicked.connect(self.alignRange)
        self._btn_alignRange.setFixedSize(normal_button_size)

        tip = 'Auto-generate aligned images.'
        lab = QLabel("Auto-\ngenerate:")
        lab.setAlignment(right)
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        lab.setStatusTip(tip)
        self._toggleAutogenerate = ToggleSwitch()
        self._toggleAutogenerate.stateChanged.connect(self._toggledAutogenerate)
        self._toggleAutogenerate.stateChanged.connect(self._callbk_unsavedChanges)
        self._toggleAutogenerate.setStatusTip(tip)
        self._toggleAutogenerate.setChecked(True)
        self._toggleAutogenerate.setEnabled(False)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(lab, alignment=right | vcenter)
        hbl.addWidget(self._toggleAutogenerate, alignment=right | vcenter)
        self._ctlpanel_toggleAutogenerate = QWidget()
        self._ctlpanel_toggleAutogenerate.setLayout(hbl)

        tip = 'Polynomial bias (default=None). Affects aligned images including their pixel dimension. This' \
              ' option is set at the coarsest s, in order to form a contiguous dataset.'
        lab = QLabel("Corrective\nPolynomial:")
        lab.setAlignment(right)
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        lab.setStatusTip(tip)
        self._polyBiasCombo = QComboBox(self)
        self._polyBiasCombo.setStyleSheet("font-size: 11px;")
        self._polyBiasCombo.currentIndexChanged.connect(self._valueChangedPolyOrder)
        self._polyBiasCombo.currentIndexChanged.connect(self._callbk_unsavedChanges)
        self._polyBiasCombo.setStatusTip(tip)
        self._polyBiasCombo.addItems(['None', '0', '1', '2', '3', '4'])
        self._polyBiasCombo.setCurrentText(str(cfg.DEFAULT_POLY_ORDER))
        self._polyBiasCombo.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._polyBiasCombo.setFixedSize(QSize(60, 20))
        self._polyBiasCombo.setEnabled(False)
        lay = QHBoxLayout()
        # lay.setSpacing(0)
        lay.setContentsMargins(4, 0, 4, 0)
        lay.addWidget(lab, alignment=right)
        lay.addWidget(self._polyBiasCombo, alignment=left)
        self._ctlpanel_polyOrder = QWidget()
        self._ctlpanel_polyOrder.setLayout(lay)


        tip = 'Bounding rectangle (only applies to "Align All"). Caution: Turning this ON may ' \
              'significantly increase the size of your aligned images.'
        lab = QLabel("Bounding Box:")
        # lab.setAlignment(right | vcenter)
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        lab.setStatusTip(tip)
        self._bbToggle = ToggleSwitch()
        # self._bbToggle.setChecked(True)
        self._bbToggle.setStatusTip(tip)
        self._bbToggle.toggled.connect(self._callbk_bnding_box)
        self._bbToggle.setEnabled(False)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0,0,0,0)
        # hbl.addWidget(lab, alignment=baseline | Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(lab, alignment=right)
        hbl.addWidget(self._bbToggle, alignment=left)
        self._ctlpanel_bb = QWidget()
        self._ctlpanel_bb.setLayout(hbl)

        tip = "Recomputes the cumulative affine and generates new aligned images" \
              "based on the current Null Bias and Bounding Rectangle presets."
        self._btn_regenerate = QPushButton('Regenerate')
        self._btn_regenerate.setStyleSheet('font-size: 10px;')
        self._btn_regenerate.setEnabled(False)
        self._btn_regenerate.setStatusTip(tip)
        self._btn_regenerate.clicked.connect(lambda: self.regenerate(scale=cfg.data.curScale))
        self._btn_regenerate.setFixedSize(normal_button_size)

        self._wdg_alignButtons = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self._btn_regenerate)
        hbl.addWidget(self._btn_alignOne)
        hbl.addWidget(self.sectionRangeSlider)
        hbl.addWidget(self.rangeInputWidget)
        hbl.addWidget(self._btn_alignRange)
        hbl.addWidget(self._btn_alignAll)
        self._wdg_alignButtons.setLayout(hbl)
        # lab = QLabel('Actions\n(Highly Parallel):')

        # lab.setAlignment(right | vcenter)
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lay = QHBoxLayout()
        # vbl.setSpacing(1)
        lay.setContentsMargins(2, 2, 2, 2)
        # lay.addWidget(lab, alignment=right)
        lay.addWidget(self._wdg_alignButtons, alignment=left)
        self._ctlpanel_alignRegenButtons = QWidget()
        self._ctlpanel_alignRegenButtons.setLayout(lay)

        form_layout = QFormLayout()
        hbl0 = QHBoxLayout()
        hbl1 = QHBoxLayout()
        hbl2 = QHBoxLayout()
        hbl0.setContentsMargins(0, 0, 0, 0)
        hbl1.setContentsMargins(0, 0, 0, 0)
        hbl2.setContentsMargins(0, 0, 0, 0)

        hbl0.addStretch()
        hbl0.addWidget(self._ctlpanel_skip)
        hbl0.addStretch()
        hbl0.addWidget(self._ctlpanel_bb)
        hbl0.addStretch()
        hbl0.addWidget(self._ctlpanel_toggleAutogenerate)
        hbl0.addStretch()
        hbl0.addWidget(self._sectionChangeWidget)
        hbl0.addStretch()
        hbl0.addWidget(self._scaleSetWidget)
        hbl0.addStretch()

        hbl1.addStretch()
        hbl1.addWidget(self._ctlpanel_polyOrder)
        hbl1.addStretch()
        hbl1.addWidget(self._ctlpanel_inp_swimWindow)
        hbl1.addStretch()
        hbl1.addWidget(self._ctlpanel_whitening)
        hbl1.addStretch()
        hbl1.addWidget(self._ctlpanel_applyAllButton)
        hbl1.addStretch()

        hbl2.addStretch()
        hbl2.addWidget(self._ctlpanel_alignRegenButtons)
        hbl2.addStretch()

        lab = QLabel('Control Panel')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 4px; margin-top: 4px;')
        form_layout.addRow(lab)

        w = QWidget()
        w.setLayout(hbl0)
        form_layout.addRow(w)

        w = QWidget()
        w.setLayout(hbl1)
        form_layout.addRow(w)

        w = QWidget()
        w.setLayout(hbl2)
        form_layout.addRow(w)

        form_layout.setContentsMargins(0, 0, 0, 0)


        gb = QGroupBox()
        # gb = QGroupBox('Control Panel')
        # gb.setStyleSheet('background-color: #141414; border-radius: 5px;')
        # gb.setStyleSheet(style)
        gb.setContentsMargins(0, 0, 0, 0)
        gb.setLayout(form_layout)


        self.cpanel = QWidget()
        with open('src/styles/cpanel.qss', 'r') as f:
            self.cpanel.setStyleSheet(f.read())

        # self.cpanel.setStyleSheet('border-radius: 5px;')
        # lab = QLabel('Control Panel')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        vbl = QVBoxLayout()
        vbl.setSpacing(0)
        vbl.setContentsMargins(0, 0, 0, 0)
        # vbl.addWidget(lab, alignment=baseline)
        # vbl.addWidget(lab)
        vbl.addWidget(gb)
        self.cpanel.setLayout(vbl)


        # self.cpanel = ControlPanel(
        #     parent=self,
        #     name='ctl_panel',
        #     title='Control Panel',
        #     # items=wids,
        #     bg_color='#f3f6fb'
        # )
        # # self.cpanel.setCustomLayout(self._cpanelVLayout)
        # self.cpanel.setCustomLayout(form_layout)

        # self.cpanel.setFixedWidth(520)
        # self.cpanel.setMaximumHeight(120)
        # self.cpanel.setFixedSize(QSize(520,128))
        self.cpanel.setFixedHeight(120)


    def splittersHaveMoved(self, pos, index):
        # logger.info('')
        self.correlation_signals.setMinimumHeight(16)  # reverse this on splitter moved (hacky)MinimumHeight(10)  # reverse this on splitter moved (hacky)



        if self.correlation_signals.isVisible():
            self.updateCorrSpotsDrawer()
            # h = self.correlation_signals.geometry().height()
            # # self.corr_spot_thumbs.setFixedHeight(max(10,h-44))
            # for w in self.corr_signals:
            #     w.setFixedSize(max(10,h-44))
    #
    #     logger.info('pos: %s index: %s' % (str(pos),str(index)) )
    #     if self.detailsWidget.isHidden():
    #         label = ' Details'
    #         icon = 'fa.info-circle'
    #         self._btn_show_hide_corr_spots.setIcon(qta.icon(icon, color='#f3f6fb'))
    #         self._btn_show_hide_corr_spots.setText(label)
    #
    #     if self.shaderCodeWidget.isHidden():
    #         label = ' Shader'
    #         icon = 'mdi.format-paint'
    #         self.shaderCodeWidget.hide()
    #         self._btn_show_hide_shader.setIcon(qta.icon(icon, color='#f3f6fb'))
    #         self._btn_show_hide_shader.setText(label)
    #
    #     if self.notes.isHidden():
    #         label  = ' Notes'
    #         icon   = 'mdi.notebook-edit'
    #         self.notes.hide()
    #         self._btn_show_hide_notes.setIcon(qta.icon(icon, color='#f3f6fb'))
    #         self._btn_show_hide_notes.setText(label)
    #
    #     if self._dev_console.isHidden():
    #         self._forceHidePython()
    #
    #     if self.cpanelMainWidgets.isHidden():
    #         self._forceHideControls()


    def initUI(self):
        '''Initialize Main UI'''
        logger.info('')

        std_button_size = QSize(96, 20)
        normal_button_size = QSize(64, 24)

        with open('src/styles/controls.qss', 'r') as f:
            lower_controls_style = f.read()

        '''Headup Display'''
        self.hud = HeadupDisplay(self.app)
        self.hud.resize(QSize(400,120))
        # self.hud.setMinimumWidth(256)
        self.hud.setMinimumWidth(180)
        self.hud.setObjectName('hud')
        # path = 'src/resources/KeyboardCommands1.html'
        # with open(path) as f:
        #     contents = f.read()
        # self.hud.textedit.appendHtml(contents)
        self.user = getpass.getuser()
        self.tell(f'Hello User, please report any issues or bugs to joel@salk.edu.')


        '''
        keyboard_commands = [
            QLabel('Keyboard Commands:'),
            QLabel('^N - New Project'),
            QLabel('^O - Open Project'),
            QLabel('^Z - Open Zarr'),
            QLabel('^S - Save'),
            QLabel('^Q - Quit'),
            QLabel('^↕ - Zoom'),
            QLabel(' , - Prev (comma)'),
            QLabel(' . - Next (period)'),
            QLabel(' ← - Scale Down'),
            QLabel(' → - Scale Up'),
            QLabel('^A - Align All'),
            QLabel('^K - Skip')
        ]

        '''

        # keyboard_commands = [
        #     QLabel('^N - New Project   ^O - Open Project   ^Z - Open Zarr'),
        #     QLabel('^S - Save          ^Q - Quit           ^↕ - Zoom'),
        #     QLabel(' , - Prev (comma)   . - Next (period)  ^K - Skip'),
        #     QLabel(' ← - Scale Down     → - Scale Up       ^A - Align All')
        # ]
        # f = QFont()
        # f.setFamily('Courier')
        # list(map(lambda x: x.setFont(f), keyboard_commands))
        # list(map(lambda x: x.setContentsMargins(0,0,0,0), keyboard_commands))
        # list(map(lambda x: x.setMargin(0), keyboard_commands))

        # self._tool_keyBindings = WidgetArea(parent=self, title='Keyboard Bindings', labels=keyboard_commands)
        # self._tool_keyBindings.setObjectName('_tool_keyBindings')
        # self._tool_keyBindings.setStyleSheet('font-size: 10px; '
        #                                       'font-weight: 500; color: #141414;')

        baseline = Qt.AlignmentFlag.AlignBaseline
        vcenter  = Qt.AlignmentFlag.AlignVCenter
        hcenter  = Qt.AlignmentFlag.AlignHCenter
        center   = Qt.AlignmentFlag.AlignCenter
        left     = Qt.AlignmentFlag.AlignLeft
        right    = Qt.AlignmentFlag.AlignRight

        self._processMonitorWidget = QWidget()
        self._processMonitorWidget.setStyleSheet('background-color: #1b2328; color: #f3f6fb; border-radius: 5px;')
        lab = QLabel('Process Monitor')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 4px; margin-top: 4px;')
        vbl = QVBoxLayout()
        vbl.setSpacing(1)
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(lab, alignment=baseline)
        vbl.addWidget(self.hud)
        self._processMonitorWidget.setLayout(vbl)

        # self._btn_refresh = QPushButton('Refresh')
        # self._btn_refresh.clicked.connect(cfg.emViewer.ini)


        # self.initControlPanel()

        '''
                    self.layer_details.setText(f"{name}{skip}"
                                                 f"{bb_dims}"
                                                 f"{snr}"
                                                 f"{completed}"
                                                 f"<b>Skipped Layers:</b> [{skips}]<br>"
                                                 f"<b>Match Point Layers:</b> [{matchpoints}]"
        '''


        self._layer_details = (
            QLabel('Name :'),
            QLabel('Bounds :'),
            QLabel('SNR :'),
            QLabel('Progress :'),
            QLabel('Rejected Layer :'),
            QLabel('Matchpoints :'),
        )
        self._tool_textInfo_NEW = WidgetArea(parent=self, title='Details', labels=self._layer_details)

        lab = QLabel('Details')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        self.layer_details = QTextEdit()
        self.layer_details.setObjectName('layer_details')
        self.layer_details.setReadOnly(True)
        self._tool_textInfo = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.setSpacing(1)
        # vbl.addWidget(lab, alignment=baseline)
        # vbl.addWidget(self.layer_details)
        self._tool_textInfo.setLayout(vbl)

        self._tool_hstry = QWidget()
        # self._tool_hstry.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self._tool_hstry.setObjectName('_tool_hstry')
        self._hstry_listWidget = QListWidget()
        # self._hstry_listWidget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self._hstry_listWidget.setObjectName('_hstry_listWidget')
        self._hstry_listWidget.installEventFilter(self)
        self._hstry_listWidget.itemClicked.connect(self.historyItemClicked)
        lab = QLabel('History')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        vbl = QVBoxLayout()
        vbl.addWidget(lab, alignment=baseline)
        vbl.addWidget(self._hstry_listWidget)
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.setSpacing(1)
        self._tool_hstry.setLayout(vbl)

        self._hstry_treeview = QTreeView()
        self._hstry_treeview.setStyleSheet('background-color: #ffffff;')
        self._hstry_treeview.setObjectName('treeview')
        self.projecthistory_model = JsonModel()
        self._hstry_treeview.setModel(self.projecthistory_model)
        self._hstry_treeview.header().setSectionResizeMode(0, QHeaderView.Stretch)
        self._hstry_treeview.setAlternatingRowColors(True)
        self.exit_projecthistory_view_button = QPushButton("Back")
        self.exit_projecthistory_view_button.setFixedSize(normal_button_size)
        self.exit_projecthistory_view_button.clicked.connect(self.back_callback)
        gl = QGridLayout()
        gl.addWidget(self._hstry_treeview, 0, 0, 1, 2)
        gl.addWidget(self.exit_projecthistory_view_button, 1, 0, 1, 1)
        self.historyview_widget = QWidget()
        self.historyview_widget.setObjectName('historyview_widget')
        self.historyview_widget.setLayout(gl)

        self.ng_widget = QWidget()
        self.ng_widget.setObjectName('ng_widget')
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)

        self.splash_widget = QWidget()  # Todo refactor this it is not in use
        self.splash_widget.setObjectName('splash_widget')
        self.splashmovie = QMovie('src/resources/alignem_animation.gif')
        self.splashlabel = QLabel()
        self.splashlabel.setMovie(self.splashmovie)
        self.splashlabel.setMinimumSize(QSize(100, 100))
        gl = QGridLayout()
        gl.addWidget(self.splashlabel, 1, 1, 1, 1)
        self.splash_widget.setLayout(gl)
        self.splash_widget.setGraphicsEffect(QGraphicsOpacityEffect().setOpacity(0.7))
        self.splashmovie.finished.connect(self.runaftersplash)

        self.permFileBrowser = FileBrowser()

        self.viewer_stack_widget = QStackedWidget()
        self.viewer_stack_widget.setObjectName('viewer_stack_widget')
        self.viewer_stack_widget.addWidget(self.ng_widget)
        self.viewer_stack_widget.addWidget(self.splash_widget)
        self.viewer_stack_widget.addWidget(self.permFileBrowser)

        self.matchpointControls = QWidget()
        with open('src/styles/cpanel.qss', 'r') as f:
            self.matchpointControls.setStyleSheet(f.read())

        self.matchpointControls.setFixedSize(QSize(560,120))
        self.matchpointControls.hide()

        mp_marker_lineweight_label = QLabel('Lineweight')
        self.mp_marker_lineweight_spinbox = QSpinBox()
        self.mp_marker_lineweight_spinbox.setMinimum(1)
        self.mp_marker_lineweight_spinbox.setMaximum(32)
        self.mp_marker_lineweight_spinbox.setSuffix('pt')
        # self.mp_marker_lineweight_spinbox.valueChanged.connect(self.set_mp_marker_lineweight)
        self.mp_marker_lineweight_spinbox.valueChanged.connect(
            lambda val: setOpt('neuroglancer,MATCHPOINT_MARKER_LINEWEIGHT', val))

        mp_marker_size_label = QLabel('Size')
        self.mp_marker_size_spinbox = QSpinBox()
        self.mp_marker_size_spinbox.setMinimum(1)
        self.mp_marker_size_spinbox.setMaximum(32)
        self.mp_marker_size_spinbox.setSuffix('pt')
        self.mp_marker_size_spinbox.valueChanged.connect(
            lambda val: setOpt('neuroglancer,MATCHPOINT_MARKER_SIZE', val))

        self.exit_matchpoint_button = QPushButton('Exit')
        self.exit_matchpoint_button.setStatusTip('Exit Manual Alignment Mode')
        self.exit_matchpoint_button.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.exit_matchpoint_button.clicked.connect(self.enterExitManAlignMode)
        self.exit_matchpoint_button.setFixedSize(normal_button_size)

        self.realign_matchpoint_button = QPushButton('Realign\nSection')
        self.realign_matchpoint_button.setStatusTip('Realign The Current Layer')
        self.realign_matchpoint_button.setStyleSheet("font-size: 9px;")
        self.realign_matchpoint_button.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.realign_matchpoint_button.clicked.connect(self.alignOneMp)
        self.realign_matchpoint_button.setFixedSize(normal_button_size)

        self.matchpoint_text_snr = QLabel()
        self.matchpoint_text_snr.setFixedHeight(26)
        self.matchpoint_text_snr.setWordWrap(True)
        self.matchpoint_text_snr.setStyleSheet('border-width: 0px;font-size: 12px; font-weight: 600;')
        self.matchpoint_text_snr.setMaximumWidth(300)
        # self.matchpoint_text_snr.setFixedHeight(24)
        self.matchpoint_text_snr.setObjectName('matchpoint_text_snr')

        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.exit_matchpoint_button)
        hbl.addWidget(self.realign_matchpoint_button)
        hbl.addWidget(mp_marker_lineweight_label)
        hbl.addWidget(self.mp_marker_lineweight_spinbox)
        hbl.addWidget(mp_marker_size_label)
        hbl.addWidget(self.mp_marker_size_spinbox)
        hbl.addWidget(self.matchpoint_text_snr)
        hbl.addStretch()

        self.matchpoint_text_prompt = QTextEdit()
        # self.matchpoint_text_prompt.setMaximumWidth(600)
        self.matchpoint_text_prompt.setFixedHeight(74)
        self.matchpoint_text_prompt.setReadOnly(True)
        self.matchpoint_text_prompt.setObjectName('matchpoint_text_prompt')
        self.matchpoint_text_prompt.setStyleSheet('border: 0px;')
        self.matchpoint_text_prompt.setHtml("Select 3-5 corresponding match points on the reference and base images. Key Bindings:<br>"
                                            "<b>Enter/return</b> - Add match points (Left, Right, Left, Right...)<br>"
                                            "<b>s</b>            - Save match points<br>"
                                            "<b>c</b>            - Clear match points for this layer")

        lab = QLabel('Control Panel - Manual Point Selection')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 4px; margin-top: 4px;')

        vbl = QVBoxLayout()
        vbl.setContentsMargins(4, 0, 4, 0)
        vbl.addWidget(lab)
        vbl.addLayout(hbl)
        vbl.addWidget(self.matchpoint_text_prompt)
        # vbl.addStretch()

        gb = QGroupBox()
        gb.setLayout(vbl)

        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(gb)

        self.matchpointControls.setLayout(vbl)

        self.corrspot_q0 = SnrThumbnail(parent=self)
        self.corrspot_q1 = SnrThumbnail(parent=self)
        self.corrspot_q2 = SnrThumbnail(parent=self)
        self.corrspot_q3 = SnrThumbnail(parent=self)

        # self.set_corrspot_size(120)

        # self.corrspot_q0.resize(128,128)
        # self.corrspot_q1.resize(128,128)
        # self.corrspot_q2.resize(128,128)
        # self.corrspot_q3.resize(128,128)
        # self.corrspot_q0.setFixedSize(128,128)
        # self.corrspot_q1.setFixedSize(128,128)
        # self.corrspot_q2.setFixedSize(128,128)
        # self.corrspot_q3.setFixedSize(128,128)
        # self.corrspot_q0.setMaximumWidth(128)
        # self.corrspot_q1.setMaximumWidth(128)
        # self.corrspot_q2.setMaximumWidth(128)
        # self.corrspot_q3.setMaximumWidth(128)

        # self.matchpointControlPanel = QWidget()
        # hbl = QHBoxLayout()
        # hbl.setContentsMargins(4, 0, 4, 0)
        # hbl.addWidget(self.matchpointControls)

        self.corr_spot_thumbs = QWidget()
        # self.corr_spot_thumbs.setMinimumHeight(30)
        # self.corr_spot_thumbs.setStyleSheet('background-color: #1b1e23; color: #f3f6fb; border-radius: 5px; ')
        hbl = QHBoxLayout()
        hbl.setSpacing(1)
        # hbl.setContentsMargins(4,4,4,8)

        self.cs0 = CorrSignalThumbnail(self)
        self.cs1 = CorrSignalThumbnail(self)
        self.cs2 = CorrSignalThumbnail(self)
        self.cs3 = CorrSignalThumbnail(self)
        self.cs4 = CorrSignalThumbnail(self)
        self.cs5 = CorrSignalThumbnail(self)
        self.cs6 = CorrSignalThumbnail(self)
        self.corr_signals = [
            self.cs0,
            self.cs1,
            self.cs2,
            self.cs3,
            self.cs4,
            self.cs5,
            self.cs6
        ]
        hbl.setContentsMargins(2, 2, 2, 2)
        hbl.addWidget(self.cs0)
        hbl.addWidget(self.cs1)
        hbl.addWidget(self.cs2)
        hbl.addWidget(self.cs3)
        hbl.addWidget(self.cs4)
        hbl.addWidget(self.cs5)
        hbl.addWidget(self.cs6)
        w = QWidget()
        w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        hbl.addWidget(w)
        self.corr_spot_thumbs.setLayout(hbl)
        # self.corr_spot_thumbs.setVisible(getOpt(lookup='ui,SHOW_CORR_SPOTS'))


        '''Show/Hide Primary Tools Buttons'''
        # show_hide_button_sizes = QSize(102, 18)
        show_hide_button_sizes = QSize(280, 18)

        tip = 'Show/Hide Alignment Controls'
        self._btn_show_hide_ctls = QPushButton('Hide Controls')
        self._btn_show_hide_ctls.setStyleSheet(lower_controls_style)
        self._btn_show_hide_ctls.setStatusTip(tip)
        self._btn_show_hide_ctls.clicked.connect(self._callbk_showHideControls)
        self._btn_show_hide_ctls.setIcon(qta.icon('fa.caret-down', color='#f3f6fb'))

        tip = 'Show/Hide Python Console'
        self._btn_show_hide_console = QPushButton(' Python')
        self._btn_show_hide_console.setStyleSheet(lower_controls_style)
        self._btn_show_hide_console.setStatusTip(tip)
        self._btn_show_hide_console.clicked.connect(self._callbk_showHidePython)
        self._btn_show_hide_console.setIcon(qta.icon("mdi.language-python", color='#f3f6fb'))

        def fn():
            caller = inspect.stack()[1].function
            if caller != 'updateNotes':
                if self._isProjectTab():
                    if cfg.data:
                        cfg.data.save_notes(text=self.notesTextEdit.toPlainText())
                else:
                    cfg.settings['notes']['global_notes'] = self.notesTextEdit.toPlainText()
                self.notes.update()

        self.notes = QWidget()
        self.notes.setStyleSheet('background-color: #1b2328; color: #f3f6fb; border-radius: 5px; ')
        # self.notesTextEdit = QPlainTextEdit()
        self.notesTextEdit = QTextEdit()
        self.notesTextEdit.setStyleSheet('color: #f3f6fb; font-size: 11px; border-width: 0px; border-radius: 0px;')
        self.notesTextEdit.setPlaceholderText('Type any notes here...')
        self.notesTextEdit.textChanged.connect(fn)
        lab = QLabel('Notes')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 2px; margin-top: 2px;')
        vbl = QVBoxLayout()
        vbl.setContentsMargins(4, 0, 4, 0)
        vbl.addWidget(lab)
        vbl.addWidget(self.notesTextEdit)
        self.notes.setLayout(vbl)
        self.notes.hide()


        tip = 'Show/Hide Project Notes'
        self._btn_show_hide_notes = QPushButton(' Notes')
        self._btn_show_hide_notes.setStyleSheet(lower_controls_style)
        self._btn_show_hide_notes.setStatusTip(tip)
        self._btn_show_hide_notes.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self._btn_show_hide_notes.clicked.connect(self._callbk_showHideNotes)
        self._btn_show_hide_notes.setIcon(qta.icon('mdi.notebook-edit', color='#f3f6fb'))

        tip = 'Show/Hide Shader Code'
        self._btn_show_hide_shader = QPushButton(' Shader')
        self._btn_show_hide_shader.setStyleSheet(lower_controls_style)
        self._btn_show_hide_shader.setStatusTip(tip)
        self._btn_show_hide_shader.clicked.connect(self._callbk_showHideShader)
        self._btn_show_hide_shader.setIcon(qta.icon('mdi.format-paint', color='#f3f6fb'))


        tip = 'Show/Hide Project Details'
        self._btn_show_hide_corr_spots = QPushButton(' Correlation Signal')
        self._btn_show_hide_corr_spots.setStyleSheet(lower_controls_style)
        self._btn_show_hide_corr_spots.setStatusTip(tip)
        self._btn_show_hide_corr_spots.clicked.connect(self._callbk_showHideDetails)
        self._btn_show_hide_corr_spots.setIcon(qta.icon('fa.info-circle', color='#f3f6fb'))


        self._showHideFeatures = QWidget()
        self._showHideFeatures.setObjectName('_showHideFeatures')
        hbl = QHBoxLayout()
        hbl.setSpacing(1)
        hbl.setContentsMargins(4, 0, 4, 0)
        hbl.addWidget(self._btn_show_hide_ctls)
        hbl.addWidget(self._btn_show_hide_console)
        hbl.addWidget(self._btn_show_hide_notes)
        hbl.addWidget(self._btn_show_hide_shader)
        hbl.addWidget(self._btn_show_hide_corr_spots)

        # hbl.addStretch()
        self._showHideFeatures.setLayout(hbl)
        self._showHideFeatures.setMaximumHeight(20)

        dSize = 166

        self.detailsTitle = QLabel('Correlation Signal')
        self.detailsTitle.setFixedHeight(13)
        self.detailsTitle.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 2px; margin-top: 2px;')


        # #0210
        # self.detailsScales = QLabel()
        # self.btnDetailsScales = QPushButton('Hide Scales')
        # self.btnDetailsScales.setFixedWidth(dSize)
        # self.btnDetailsScales.setIcon(qta.icon('fa.caret-down', color='#f3f6fb'))
        # def fn():
        #     self.detailsScales.setVisible(not self.detailsScales.isVisible())
        #     if self.detailsScales.isHidden():
        #         label, icon = ' Scales', 'fa.caret-right'
        #     else:
        #         label, icon = 'Hide Scales', 'fa.caret-down'
        #     self.btnDetailsScales.setIcon(qta.icon(icon, color='#f3f6fb'))
        #     self.btnDetailsScales.setText(label)
        # self.btnDetailsScales.clicked.connect(fn)
        # self.detailsScales.setWordWrap(True)
        # self.detailsScales.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        # self.detailsScales.setStyleSheet("""font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 11px;""")
        # # self.detailsScales.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum) #???
        # self.detailsScales.setFixedWidth(dSize)
        # # self.detailsScales.setReadOnly(True)
        #
        # self.detailsSkips = QLabel()
        # self.btndetailsSkips = QPushButton('Hide Rejects')
        # self.btndetailsSkips.setFixedWidth(dSize)
        # self.btndetailsSkips.setIcon(qta.icon('fa.caret-down', color='#f3f6fb'))
        # def fn():
        #     self.detailsSkips.setVisible(not self.detailsSkips.isVisible())
        #     if self.detailsSkips.isHidden(): label, icon = ' Rejects', 'fa.caret-right'
        #     else:                            label, icon = 'Hide Rejects', 'fa.caret-down'
        #     self.btndetailsSkips.setIcon(qta.icon(icon, color='#f3f6fb'))
        #     self.btndetailsSkips.setText(label)
        # self.btndetailsSkips.clicked.connect(fn)
        # self.detailsSkips.setWordWrap(True)
        # self.detailsSkips.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        # self.detailsSkips.setStyleSheet("""font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;""")
        # self.detailsSkips.setFixedWidth(dSize)
        # # self.detailsSkips.setReadOnly(True)

        # self.detailsTensor = QWidget()
        # self.detailsTensor.setFixedWidth(dSize)
        # self.detailsTensorLab = QLabel()
        # self.detailsTensorLab.setWordWrap(True)
        # # self.detailsTensorLab.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        # self.detailsTensorLab.setStyleSheet("""
        # font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
        # color: #f3f6fb;
        # font-size: 10px;""")
        # self.detailsTensorLab.hide()
        # self.btnDetailsTensor = QPushButton('Tensor')
        # self.btnDetailsTensor.setIcon(qta.icon('fa.caret-right', color='#f3f6fb'))
        # def fn():
        #     logger.info('')
        #     self.detailsTensorLab.setVisible(not self.detailsTensorLab.isVisible())
        #     if self.detailsTensorLab.isHidden():
        #         label, icon = ' Tensor', 'fa.caret-right'
        #     else:
        #         label, icon  = 'Hide Tensor', 'fa.caret-down'
        #         self.detailsTensorLab.setText(json.dumps(cfg.tensor.spec().to_json(), indent=2))
        #     self.btnDetailsTensor.setIcon(qta.icon(icon, color='#f3f6fb'))
        #     self.btnDetailsTensor.setText(label)
        # self.btnDetailsTensor.setFixedWidth(dSize + 26)
        # self.btnDetailsTensor.clicked.connect(fn)
        # vbl = QVBoxLayout()
        # vbl.setContentsMargins(0, 0, 0, 0)
        # vbl.addWidget(self.btnDetailsTensor)
        # vbl.addWidget(self.detailsTensorLab)
        # self.detailsTensor.setLayout(vbl)


        # self.correlation_signals = QWidget()
        self.correlation_signals = QScrollArea()
        self.correlation_signals.setMinimumHeight(100)
        self.correlation_signals.setStyleSheet('background-color: #1b1e23; color: #f3f6fb; border-radius: 5px; ')
        self.correlation_signals.setWidgetResizable(True)
        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.setSpacing(0)
        vbl.addWidget(self.detailsTitle)
        vbl.addWidget(self.corr_spot_thumbs)
        w.setLayout(vbl)
        # self.correlation_signals.setLayout(vbl)
        # self.correlation_signals.hide()
        self.correlation_signals.setWidget(w)
        self.correlation_signals.hide()


        # self.detailsWidget = QScrollArea()
        # self.detailsWidget.setWidgetResizable(True)

        self._btn_volumeRendering = QPushButton('Volume')
        self._btn_applyShader = QPushButton('Apply')
        self._btn_applyShader.clicked.connect(self.onShaderApply)

        self._btn_resetBrightnessAndContrast = QPushButton('Reset')
        # self._btn_resetBrightnessAndContrast.setFixedSize(QSize(80,36))
        def fn():
            reset_val = 0.0
            cfg.data.set_brightness(reset_val)
            cfg.data.set_contrast(reset_val)
            self.brightnessSlider.setValue(cfg.data.brightness())
            self.contrastSlider.setValue(cfg.data.contrast())
            if self._isProjectTab():
                cfg.data['rendering']['shader'] = cfg.SHADER
                self.updateShaderText()
                # cfg.project_tab.initNeuroglancer()
                cfg.project_tab.updateNeuroglancer()

        self._btn_resetBrightnessAndContrast.clicked.connect(fn)


        self.shaderCodeWidget = QWidget()
        # self.shaderCodeWidget.setFixedHeight(128)
        self.shaderText = QPlainTextEdit()
        style = '''
        border-width: 1px;
        border-radius: 5px;
        color: #141414;
        background-color: #f3f6fb;
        font-size: 12px;
        font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
        '''
        self.shaderText.setStyleSheet(style)
        self.shaderSideButtons = QWidget()
        self.shaderSideButtons.setFixedWidth(60)
        self.shaderSideButtons.setStyleSheet("""
        QPushButton {background-color: #ede9e8; color: #141414;}
        QPushButton::pressed {background-color: #ede9e8; color: #141414; border-bottom-style: solid;
        border-bottom-color: #ede9e8; border-bottom-width: 2px; }
        QPushButton::hover {color: #161c20;}
        """)
        self._btn_volumeRendering.clicked.connect(self.fn_volume_rendering)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(4,4,4,4)
        vbl.addWidget(self._btn_volumeRendering, alignment=Qt.AlignVCenter)
        vbl.addWidget(self._btn_applyShader, alignment=Qt.AlignVCenter)
        vbl.addWidget(self._btn_resetBrightnessAndContrast, alignment=Qt.AlignVCenter)
        self.shaderSideButtons.setLayout(vbl)

        # self.normalizedSlider = RangeSlider()
        # self.normalizedSlider.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        # # self.normalizedSlider.setFixedWidth(120)
        # self.normalizedSlider.setMin(1)
        # self.normalizedSlider.setStart(1)
        # self.normalizedSlider.setMax(255)
        # self.normalizedSlider.setEnd(255)
        # self.normalizedSlider.startValueChanged.connect(self.fn_shader_control)
        # self.normalizedSlider.endValueChanged.connect(self.fn_shader_control)
        #
        # self.normalizedSliderWidget = QWidget()
        # self.normalizedSliderWidget.setFixedWidth(120)
        # vbl = QVBoxLayout()
        # vbl.setSpacing(1)
        # vbl.setContentsMargins(0, 0, 0, 0)
        # lab = QLabel('Normalize:')
        # lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #141414;')
        # vbl.addWidget(lab)
        # vbl.addWidget(self.normalizedSlider)
        # self.normalizedSliderWidget.setLayout(vbl)

        self.brightnessLE = QLineEdit()
        self.brightnessLE.setText('0.00')
        self.brightnessLE.setValidator(QDoubleValidator(-1, 1, 2))
        # self.brightnessLE.setFixedWidth(120)
        self.brightnessLE.textChanged.connect(
            lambda: self.brightnessSlider.setValue(float(self.brightnessLE.text())))
        self.brightnessLE.textChanged.connect(self.fn_brightness_control)
        self.brightnessSlider = DoubleSlider(Qt.Orientation.Horizontal, self)
        self.brightnessSlider.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.brightnessSlider.setMinimum(-1.0)
        self.brightnessSlider.setMaximum(1.0)
        self.brightnessSlider.setValue(0)
        self.brightnessSlider.valueChanged.connect(self.fn_brightness_control)
        self.brightnessSlider.valueChanged.connect(self._callbk_unsavedChanges)
        self.brightnessSlider.valueChanged.connect(
            lambda: self.brightnessLE.setText('%.2f' %self.brightnessSlider.value()))
        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setSpacing(1)
        vbl.setContentsMargins(0, 0, 0, 0)
        lab = QLabel('Brightness:')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb')
        vbl.addWidget(lab)
        vbl.addWidget(self.brightnessSlider)
        w.setLayout(vbl)
        w.setMaximumHeight(36)
        w.setMinimumWidth(140)


        self.brightnessSliderWidget = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(w)
        hbl.addWidget(self.brightnessLE)
        self.brightnessSliderWidget.setLayout(hbl)


        self.contrastLE = QLineEdit()
        self.contrastLE.setText('0.00')
        self.contrastLE.setValidator(QDoubleValidator(-1,1,2))
        # self.contrastLE.setFixedWidth(120)
        self.contrastLE.textChanged.connect(
            lambda: self.contrastSlider.setValue(float(self.contrastLE.text())))
        self.contrastLE.textChanged.connect(self.fn_contrast_control)
        self.contrastSlider = DoubleSlider(Qt.Orientation.Horizontal, self)
        self.contrastSlider.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        self.contrastSlider.setMinimum(-1.0)
        self.contrastSlider.setMaximum(1.0)
        self.contrastSlider.setValue(0)
        # self.contrastSlider.setSingleStep(.02)
        # self.contrastSlider.setSingleStep(0.01)
        self.contrastSlider.valueChanged.connect(self.fn_contrast_control)
        self.contrastSlider.valueChanged.connect(self._callbk_unsavedChanges)
        self.contrastSlider.valueChanged.connect(
            lambda: self.contrastLE.setText('%.2f' %self.contrastSlider.value()))
        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setSpacing(1)
        vbl.setContentsMargins(0, 0, 0, 0)
        lab = QLabel('Contrast:')
        lab.setStyleSheet('font-size: 10px; font-weight: 500; color: #f3f6fb;')
        vbl.addWidget(lab)
        vbl.addWidget(self.contrastSlider)
        w.setLayout(vbl)
        w.setFixedHeight(30)
        w.setMinimumWidth(140)

        self.contrastSliderWidget = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(w)
        hbl.addWidget(self.contrastLE)
        self.contrastSliderWidget.setLayout(hbl)

        self.bcWidget = QWidget()
        self.bcWidget.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding,)
        self.bcWidget.setMaximumWidth(180)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.brightnessSliderWidget)
        vbl.addWidget(self.contrastSliderWidget)
        self.bcWidget.setLayout(vbl)

        self.bcWidgetAndSideButtons = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(4, 4, 4, 4)
        hbl.setSpacing(0)
        hbl.addWidget(self.bcWidget)
        hbl.addWidget(self.shaderSideButtons)
        self.bcWidgetAndSideButtons.setLayout(hbl)
        self.bcWidgetAndSideButtons.setMaximumHeight(80)
        self.bcWidgetAndSideButtons.setMaximumWidth(320)

        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.shaderText)
        # hbl.addWidget(self.bcWidget)
        # hbl.addWidget(self.normalizedSliderWidget)
        # hbl.addWidget(self.shaderSideButtons)
        hbl.addWidget(self.bcWidgetAndSideButtons, alignment=Qt.AlignBottom)
        self.shaderMainWidget = QWidget()
        self.shaderMainWidget.setLayout(hbl)

        lab = QLabel('Shader')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin-left: 4px; margin-top: 4px;')
        vbl = QVBoxLayout()
        vbl.setContentsMargins(1,1,1,1)
        vbl.addWidget(lab)
        vbl.addWidget(self.shaderMainWidget)

        self.shaderCodeWidget.setLayout(vbl)
        self.shaderCodeWidget.setStyleSheet('background-color: #1b2328; color: #f3f6fb; border-radius: 5px;')
        self.shaderCodeWidget.hide()


        '''Tabs Global Widget'''
        self.globTabs = QTabWidget()
        # self.globTabs.setTabBarAutoHide(True)
        self.globTabs.setElideMode(Qt.ElideMiddle)
        self.globTabs.setMovable(True)
        self.globTabs.hide()

        self.globTabs.setDocumentMode(True)
        self.globTabs.setTabsClosable(True)
        self.globTabs.setObjectName('globTabs')
        self.globTabs.tabCloseRequested[int].connect(self._onGlobTabClose)
        self.globTabs.currentChanged.connect(self._onGlobTabChange)
        #
        # self._buttonOpen = QPushButton('Open')
        # self._buttonOpen.clicked.connect(self.open_project_selected)
        # self._buttonOpen.setFixedSize(64, 20)
        #
        # self._buttonDelete = QPushButton('Delete')
        # self._buttonDelete.clicked.connect(self.delete_project)
        # self._buttonDelete.setFixedSize(64, 20)
        #
        # self._buttonNew = QPushButton('New')
        # self._buttonNew.clicked.connect(self.new_project)
        # self._buttonNew.setFixedSize(64, 20)
        #
        # # self._buttonNew = QPushButton('Remember')
        # # self._buttonNew.setStyleSheet("font-size: 9px;")
        # # self._buttonNew.clicked.connect(self.new_project)
        # # self._buttonNew.setFixedSize(64, 20)
        # # # self._buttonNew.setStyleSheet(style)
        #
        # # self.selectionReadout = QLabel('<h4>Selection:</h4>')
        # # self.selectionReadout = QLabel()
        # self.selectionReadout = QLineEdit()
        # self.selectionReadout.returnPressed.connect(self.open_project_selected)
        # # self.selectionReadout.textEdited.connect(self.validateUserEnteredPath)
        # self.selectionReadout.textChanged.connect(self.validateUserEnteredPath)
        # self.selectionReadout.setFixedHeight(22)
        # self.selectionReadout.setMinimumWidth(700)
        #
        # self.validity_label = QLabel('Invalid')
        # self.validity_label.setObjectName('validity_label')
        # self.validity_label.setFixedHeight(20)
        # self.validity_label.hide()
        #
        # hbl = QHBoxLayout()
        # hbl.setContentsMargins(6, 2, 6, 2)
        # hbl.addWidget(self._buttonNew)
        # hbl.addWidget(self.selectionReadout)
        # hbl.addWidget(self.validity_label)
        # hbl.addWidget(self._buttonOpen)
        # hbl.addWidget(self._buttonDelete)
        # self.spacer_item_docs = QSpacerItem(0, 0, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        # hbl.addSpacerItem(self.spacer_item_docs)
        #
        # self._buttonOpen.setEnabled(False)
        # self._buttonDelete.setEnabled(False)
        #
        # self._actions_widget = QWidget()
        # self._actions_widget.setFixedHeight(26)
        # self._actions_widget.setLayout(hbl)

        # self.cpanelMainWidgets = QWidget()
        self.cpanelMainSplitter = QSplitter(Qt.Orientation.Horizontal)
        self.cpanelMainSplitter.splitterMoved.connect(self.splittersHaveMoved)

        hbl = QHBoxLayout()
        hbl.setContentsMargins(6, 0, 6, 0)

        self.cpanelMainSplitter.addWidget(self._processMonitorWidget)
        self.cpanelMainSplitter.addWidget(self.cpanel)
        self.cpanelMainSplitter.addWidget(self.matchpointControls)
        self.cpanelMainSplitter.setCollapsible(0, False)
        self.cpanelMainSplitter.setCollapsible(1, False)
        self.cpanelMainSplitter.setCollapsible(2, False)
        self.cpanelMainSplitter.setCollapsible(3, False)
        hbl.addWidget(self.cpanelMainSplitter)

        self.cpanelMainWidgets = QWidget()
        self.cpanelMainWidgets.setLayout(hbl)
        self.cpanelMainWidgets.setFixedHeight(120)

        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.cpanelMainWidgets)

        self.pythonConsole = PythonConsole()
        self.__dev_console = QWidget()
        # self.__dev_console.setStyleSheet("font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;")
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.pythonConsole)
        self.__dev_console.setLayout(vbl)

        self._dev_console = QWidget()
        self._dev_console.setStyleSheet("background-color: #003333; border-radius: 5px;")
        self._dev_console.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        # self._dev_console.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        # self._dev_console.resize(QSize(600,600))

        self.__dev_console.setStyleSheet("font-size: 10px; "
                                        "background-color: #003333; "
                                        "color: #f3f6fb; "
                                         "font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;"

                                        )
        lab = QLabel('Python Console')
        lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500; margin: 2px;')
        # lab.setStyleSheet('color: #f3f6fb; font-size: 10px; font-weight: 500;')
        vbl = QVBoxLayout()
        vbl.setSpacing(1)
        vbl.setContentsMargins(1, 1, 1, 1) # this provides for thin contrasting margin
        vbl.addWidget(lab, alignment=Qt.AlignBaseline)
        vbl.addWidget(self.__dev_console)
        self._dev_console.setLayout(vbl)
        # self._dev_console.setStyleSheet('font-size: 11px; border-width: 0px; border-radius: 0px;')

        self._dev_console.hide()
        # if cfg.DEV_MODE:
        #     self._dev_console = PythonConsole()
        #     self._splitter.addWidget(self._dev_console)           # (5)
        #     self._dev_console.hide()
        # else:
        #     self._dev_console = None

        self.notes.setContentsMargins(0, 0, 0, 0)
        self.shaderCodeWidget.setContentsMargins(0, 0, 0, 0)
        # self.detailsWidget.setContentsMargins(0, 0, 0, 0)
        # self._py_console.setContentsMargins(6, 0, 6, 0)
        self._dev_console.setContentsMargins(0, 0, 0, 0)

        '''Main Vertical Splitter'''
        self._splitter = QSplitter(Qt.Orientation.Vertical)      # __SPLITTER INDEX__


        self._splitter.splitterMoved.connect(self.splittersHaveMoved)
        # self._splitter.addWidget(self.globTabs)          # (0)

        self._splitter.addWidget(self.notes)             # (0)
        self._splitter.addWidget(self.shaderCodeWidget)  # (1)
        self._splitter.addWidget(self.correlation_signals)     # (2)
        self._splitter.addWidget(self._dev_console)      # (3)
        # self._splitter.addWidget(self._showHideFeatures) # (4)
        # self._mainVSplitterSizes = [1000, 128, 128, 128, 180, 128, 128]
        # self._splitter.setSizes(self._mainVSplitterSizes)
        self._splitter.setContentsMargins(6, 0, 6, 0)

        self._splitter.setHandleWidth(2)
        self._splitter.setCollapsible(0, False)
        self._splitter.setCollapsible(1, False)
        self._splitter.setCollapsible(2, False)
        self._splitter.setCollapsible(3, False)
        # self._splitter.setCollapsible(4, True)

        self._splitter.setStretchFactor(0, 2)
        self._splitter.setStretchFactor(1, 2)
        self._splitter.setStretchFactor(2, 3)
        self._splitter.setStretchFactor(3, 1)
        # self._splitter.setStretchFactor(4, 0)

        self.browser_html_widget = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        self.browser_html = QWebEngineView()
        vbl.addWidget(self.browser_html)
        self.browser_html_widget.setLayout(vbl)

        btn = QPushButton()
        btn.setStatusTip('Go Back')
        btn.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        btn.clicked.connect(lambda: self.main_stack_widget.setCurrentIndex(0))
        btn.setFixedSize(QSize(20, 20))
        btn.setIcon(qta.icon('fa.arrow-left', color=ICON_COLOR))

        '''Documentation Panel'''
        self.browser_web = QWebEngineView()
        # self.browser = WebPage(self)
        self._buttonExitBrowserWeb = QPushButton()
        self._buttonExitBrowserWeb.setFixedSize(18, 18)
        self._buttonExitBrowserWeb.setIcon(qta.icon('fa.arrow-left', color=ICON_COLOR))
        self._buttonExitBrowserWeb.setStyleSheet('font-size: 9px;')
        self._buttonExitBrowserWeb.setFixedSize(std_button_size)
        self._buttonExitBrowserWeb.clicked.connect(self.exit_docs)
        # self._readmeButton = QPushButton("README.md")
        # self._readmeButton.setFixedSize(50, 18)
        # self._readmeButton.setStyleSheet('font-size: 9px;')
        # self._readmeButton.setFixedSize(std_button_size)
        # self._readmeButton.clicked.connect(self.documentation_view)
        self.browser_widget = QWidget()
        w = QWidget()
        w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        def browser_backward():
            self.browser_web.page().triggerAction(QWebEnginePage.Back)

        def browser_forward():
            self.browser_web.page().triggerAction(QWebEnginePage.Forward)

        def browser_reload():
            self.browser_web.page().triggerAction(QWebEnginePage.Reload)

        def browser_view_source():
            self.browser_web.page().triggerAction(QWebEnginePage.ViewSource)

        def browser_copy():
            self.browser_web.page().triggerAction(QWebEnginePage.Copy)

        def browser_paste():
            self.browser_web.page().triggerAction(QWebEnginePage.Paste)

        buttonBrowserBack = QPushButton()
        buttonBrowserBack.setStatusTip('Go Back')
        buttonBrowserBack.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserBack.clicked.connect(browser_backward)
        buttonBrowserBack.setFixedSize(QSize(20, 20))
        buttonBrowserBack.setIcon(qta.icon('fa.arrow-left', color=ICON_COLOR))

        buttonBrowserForward = QPushButton()
        buttonBrowserForward.setStatusTip('Go Forward')
        buttonBrowserForward.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserForward.clicked.connect(browser_forward)
        buttonBrowserForward.setFixedSize(QSize(20, 20))
        buttonBrowserForward.setIcon(qta.icon('fa.arrow-right', color=ICON_COLOR))

        buttonBrowserRefresh = QPushButton()
        buttonBrowserRefresh.setStatusTip('Refresh')
        buttonBrowserRefresh.setIcon(qta.icon("ei.refresh", color=cfg.ICON_COLOR))
        buttonBrowserRefresh.setFixedSize(QSize(22,22))
        buttonBrowserRefresh.clicked.connect(browser_reload)

        # buttonBrowserViewSource = QPushButton()
        # buttonBrowserViewSource.setStatusTip('View Source')
        # buttonBrowserViewSource.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        # buttonBrowserViewSource.clicked.connect(browser_view_source)
        # buttonBrowserViewSource.setFixedSize(QSize(20, 20))
        # buttonBrowserViewSource.setIcon(qta.icon('ri.code-view', color=ICON_COLOR))

        buttonBrowserCopy = QPushButton('Copy')
        buttonBrowserCopy.setStatusTip('Copy Text')
        buttonBrowserCopy.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserCopy.clicked.connect(browser_copy)
        buttonBrowserCopy.setFixedSize(QSize(50, 20))

        buttonBrowserPaste = QPushButton('Paste')
        buttonBrowserPaste.setStatusTip('Paste Text')
        buttonBrowserPaste.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserPaste.clicked.connect(browser_paste)
        buttonBrowserPaste.setFixedSize(QSize(50, 20))

        button3demCommunity = QPushButton('3DEM Community Data')
        button3demCommunity.setStyleSheet('font-size: 10px;')
        button3demCommunity.setStatusTip('Vist the 3DEM Community Workbench')
        button3demCommunity.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        button3demCommunity.clicked.connect(self.browser_3dem_community)
        button3demCommunity.setFixedSize(QSize(120, 20))

        #webpage
        browser_controls_widget = QWidget()
        browser_controls_widget.setFixedHeight(24)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserBack, alignment=right)
        hbl.addWidget(buttonBrowserForward, alignment=left)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserRefresh, alignment=left)
        # hbl.addWidget(QLabel(' '))
        # hbl.addWidget(buttonBrowserViewSource, alignment=left)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserCopy, alignment=left)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserPaste, alignment=left)
        hbl.addWidget(QLabel('   |   '))
        hbl.addWidget(button3demCommunity, alignment=left)
        browser_controls_widget.setLayout(hbl)

        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(browser_controls_widget, alignment=Qt.AlignmentFlag.AlignLeft)
        vbl.addWidget(self.browser_web)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self._buttonExitBrowserWeb, alignment=Qt.AlignmentFlag.AlignLeft)
        # hbl.addWidget(self._readmeButton, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(w)
        browser_bottom_controls = QWidget()
        browser_bottom_controls.setFixedHeight(20)
        browser_bottom_controls.setLayout(hbl)
        vbl.addWidget(browser_bottom_controls)
        self.browser_widget.setLayout(vbl)

        '''Remote Neuroglancer Viewer (_wdg_remote_viewer)'''
        self._wdg_remote_viewer = QWidget()
        self.browser_remote = QWebEngineView()
        self._btn_remote_exit = QPushButton('Back')
        self._btn_remote_exit.setFixedSize(std_button_size)
        self._btn_remote_exit.clicked.connect(self.exit_remote)
        self._btn_remote_reload = QPushButton('Reload')
        self._btn_remote_reload.setFixedSize(std_button_size)
        self._btn_remote_reload.clicked.connect(self.reload_remote)

        vbl = QVBoxLayout()
        vbl.addWidget(self.browser_remote)
        hbl = QHBoxLayout()
        hbl.addWidget(self._btn_remote_exit, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(self._btn_remote_reload, alignment=Qt.AlignmentFlag.AlignLeft)
        # hbl.addSpacerItem(QSpacerItem(0, 0, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum))
        vbl.addLayout(hbl)
        self._wdg_remote_viewer.setLayout(vbl)

        '''Demos Panel (_wdg_demos)'''
        # get rid of this?
        self._wdg_demos = QWidget()
        self._btn_demos_exit = QPushButton('Back')
        self._btn_demos_exit.setFixedSize(std_button_size)
        self._btn_demos_exit.clicked.connect(self.exit_demos)

        vbl = QVBoxLayout()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self._btn_demos_exit)
        vbl.addLayout(hbl)
        self._wdg_demos.setLayout(vbl)

        self._splitterSplitter = QSplitter(Qt.Orientation.Vertical)
        self._splitterSplitter.splitterMoved.connect(self.splittersHaveMoved)
        self._splitterSplitter.addWidget(self.globTabs)
        # self._splitterSplitter.addWidget(self._actions_widget)
        self._splitterSplitter.addWidget(self.cpanelMainWidgets)
        self._splitterSplitter.addWidget(self._splitter)
        self._splitterSplitter.setCollapsible(0,False)
        self._splitterSplitter.setCollapsible(1,False)
        self._splitterSplitter.setCollapsible(2,False)
        self._splitterSplitter.setCollapsible(3,False)
        self._splitterSplitter.setStretchFactor(0, 1)
        self._splitterSplitter.setStretchFactor(1, 1)
        self._splitterSplitter.setStretchFactor(2, 1)
        self._splitterSplitter.setStretchFactor(3, 1)
        self._splitterSplitter.setHandleWidth(2)

        self.main_panel = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        # vbl.addWidget(self.globTabs)
        # vbl.addWidget(self._actions_widget)
        # vbl.addWidget(self._splitter)
        vbl.addWidget(self._splitterSplitter)
        vbl.addWidget(self._showHideFeatures)

        #Todo keep this main_stack_widget for now, repurpose later
        self.main_stack_widget = QStackedWidget(self)               #____INDEX____
        self.main_stack_widget.addWidget(self.main_panel)           # (0)
        self.main_stack_widget.addWidget(self.browser_widget)       # (1)
        self.main_stack_widget.addWidget(self._wdg_demos)           # (2)
        self.main_stack_widget.addWidget(self._wdg_remote_viewer)   # (3)
        self.main_stack_widget.addWidget(self.browser_html_widget)  # (4)
        self.main_panel.setLayout(vbl)
        # self.setWindowIcon(QIcon(QPixmap('src/resources/em_guy_icon.png')))
        self.setCentralWidget(self.main_stack_widget)
        # QShortcut(QKeySequence('Ctrl+M'), self.main_stack_widget, self.enterExitManAlignMode)

    #
    # def validateUserEnteredPath(self):
    #     # logger.info(f'caller:{inspect.stack()[1].function}')
    #     cfg.selected_file = self.selectionReadout.text()
    #     if validate_project_selection() or validate_zarr_selection():
    #         self.validity_label.hide()
    #         self._buttonOpen.setEnabled(True)
    #         self._buttonDelete.setEnabled(True)
    #     else:
    #         self.validity_label.show()
    #         self._buttonOpen.setEnabled(False)
    #         self._buttonDelete.setEnabled(False)
    #
    #
    #
    # def setSelectionPathText(self, path):
    #     # logger.info(f'caller:{inspect.stack()[1].function}')
    #     self.selectionReadout.setText(path)
    #     if self._isProjectTab():
    #         logger.info('Evaluating whether path is AlignEM-SWiFT Project...')
    #         if validate_project_selection():
    #             self.validity_label.hide()
    #             self._buttonOpen.setEnabled(True)
    #             self._buttonDelete.setEnabled(True)
    #         else:
    #             self.validity_label.show()
    #             self._buttonOpen.setEnabled(False)
    #             self._buttonDelete.setEnabled(False)
    #     elif self._isZarrTab():
    #         logger.info('Evaluating whether path is Zarr...')
    #         if validate_zarr_selection():
    #             self.validity_label.hide()
    #             self._buttonOpen.setEnabled(True)
    #             self._buttonDelete.setEnabled(True)
    #         else:
    #             self.validity_label.show()
    #             self._buttonOpen.setEnabled(False)
    #             self._buttonDelete.setEnabled(False)


    # def clearSelectionPathText(self):
    #     self.selectionReadout.setText('')


    def initLaunchTab(self):
        self._launchScreen = OpenProject()
        self.globTabs.addTab(self._launchScreen, 'Open...')
        self._setLastTab()


    def get_application_root(self):
        return Path(__file__).parents[2]


    def initWidgetSpacing(self):
        logger.info('')
        self._py_console.setContentsMargins(0, 0, 0, 0)
        self.hud.setContentsMargins(0, 0, 0, 0)
        self.layer_details.setContentsMargins(0, 0, 0, 0)
        self.matchpoint_text_snr.setMaximumHeight(20)
        self._tool_hstry.setMinimumWidth(248)
        # cfg.project_tab._transformationWidget.setFixedWidth(248)
        # cfg.project_tab._transformationWidget.setFixedSize(248,100)
        self.layer_details.setMinimumWidth(248)


    def initStatusBar(self):
        logger.info('')
        self.statusBar = self.statusBar()
        # self.statusBar.setFixedHeight(30)
        self.statusBar.setFixedHeight(26)


    def initPbar(self):
        self.pbar = QProgressBar()
        self.pbar.setTextVisible(True)
        font = QFont('Arial', 12)
        font.setBold(True)
        self.pbar.setFont(font)
        # self.pbar.setFixedHeight(18)
        self.pbar.setFixedHeight(18)
        self.pbar.setFixedWidth(500)
        self.pbar_widget = QWidget(self)
        self.status_bar_layout = QHBoxLayout()
        self.status_bar_layout.setContentsMargins(0, 0, 0, 0)

        # self.pbar_cancel_button = QPushButton('Stop')
        self.pbar_cancel_button = QPushButton('Stop')
        self.pbar_cancel_button.setFixedSize(48,18)
        self.pbar_cancel_button.setStatusTip('Terminate Pending Multiprocessing Tasks')
        self.pbar_cancel_button.setIcon(qta.icon('mdi.cancel', color=cfg.ICON_COLOR))
        self.pbar_cancel_button.setStyleSheet("font-size: 10px;")
        self.pbar_cancel_button.clicked.connect(self.forceStopMultiprocessing)

        self.pbar_widget.setLayout(self.status_bar_layout)
        self.pbarLabel = QLabel('Processing... ')
        self.status_bar_layout.addWidget(self.pbarLabel, alignment=Qt.AlignmentFlag.AlignRight)
        self.status_bar_layout.addWidget(self.pbar)
        self.status_bar_layout.addWidget(self.pbar_cancel_button)
        self.statusBar.addPermanentWidget(self.pbar_widget)
        self.pbar_widget.hide()

    def forceStopMultiprocessing(self):
        cfg.CancelProcesses = True
        cfg.event.set()

    def setPbarMax(self, x):
        self.pbar.setMaximum(x)


    def updatePbar(self, x):
        self.pbar.setValue(x)
        self.repaint()


    def setPbarText(self, text: str):
        self.pbar.setFormat('(%p%) ' + text)
        self.pbarLabel.setText('Processing (%d/%d)...' % (cfg.nCompleted, cfg.nTasks))
        self.repaint()


    def showZeroedPbar(self):
        # logger.critical('')
        self.pbar.setValue(0)
        self.setPbarText('Preparing Multiprocessing Tasks...')
        self.pbar_widget.show()
        self.pbar_widget.repaint()
        self.repaint()


    def back_callback(self):
        logger.info("Returning Home...")
        self.main_stack_widget.setCurrentIndex(0)
        self.viewer_stack_widget.setCurrentIndex(0)


    def eventFilter(self, source, event):
        if event.type() == QEvent.ContextMenu and source is self._hstry_listWidget:
            menu = QMenu()
            self.history_view_action = QAction('View')
            self.history_view_action.setStatusTip('View this alignment as a tree view')
            self.history_view_action.triggered.connect(self.view_historical_alignment)
            self.history_swap_action = QAction('Swap')
            self.history_swap_action.setStatusTip('Swap the settings of this historical alignment '
                                                  'with your current s settings')
            self.history_swap_action.triggered.connect(self.swap_historical_alignment)
            self.history_rename_action = QAction('Rename')
            self.history_rename_action.setStatusTip('Rename this file')
            self.history_rename_action.triggered.connect(self.rename_historical_alignment)
            self.history_delete_action = QAction('Delete')
            self.history_delete_action.setStatusTip('Delete this file')
            self.history_delete_action.triggered.connect(self.remove_historical_alignment)
            menu.addAction(self.history_view_action)
            menu.addAction(self.history_rename_action)
            menu.addAction(self.history_swap_action)
            menu.addAction(self.history_delete_action)
            if menu.exec_(event.globalPos()):
                item = source.itemAt(event.pos())
                logger.info(f'Item Text: {item.text()}')
            return True
        return super().eventFilter(source, event)


    def store_var(self, name, var):
        setattr(cfg, name, var)

__all__ = ['CustomWebEnginePage']

class CustomWebEnginePage(QWebEnginePage):
    """ Custom WebEnginePage to customize how we handle link navigation
    Depends on QWebEnginePage / QWebEnginePage since Qt5.4"""
    # Store external windows.
    external_windows = []

    def acceptNavigationRequest(self, url, _type, isMainFrame):
        if (_type == QWebEnginePage.NavigationTypeLinkClicked and url.host() != 'github.com'):
            # Pop up external links into a new window.
            w = QWebEngineView()
            w.setUrl(url)
            w.show()

            # Keep reference to external window, so it isn't cleared up.
            self.external_windows.append(w)
            return False
        return super().acceptNavigationRequest(url, _type, isMainFrame)

def render(source_html):
    """Fully render HTML, JavaScript and all."""

    class Render(QWebEngineView):
        def __init__(self, html):
            self.html = None
            QWebEngineView.__init__(self)
            self.loadFinished.connect(self._loadFinished)
            self.setHtml(html)
            while self.html is None:
                self.app.processEvents(QEventLoop.ExcludeUserInputEvents | QEventLoop.ExcludeSocketNotifiers | QEventLoop.WaitForMoreEvents)
            self.app.quit()

        def _callable(self, data):
            self.html = data

        def _loadFinished(self, result):
            self.page().toHtml(self._callable)

    return Render(source_html).html

import requests
sample_html = requests.get("https://github.com/google/neuroglancer").text
print(render(sample_html))
def import_images_dialog():
    '''Dialog for importing images. Returns list of filenames.'''
    dialog = QFileDialogPreview()
    dialog.setOption(QFileDialog.DontUseNativeDialog)
    # dialog.setWindowTitle('Import Images - %s' % cfg.datamodel.name())
    dialog.setWindowTitle('New Project - Import Images (2/3)')
    dialog.setNameFilter('Images (*.tif *.tiff)')
    dialog.setFileMode(QFileDialog.ExistingFiles)
    dialog.setModal(True)
    urls = dialog.sidebarUrls()
    urls.append(QUrl.fromLocalFile(QDir.homePath()))
    if is_tacc():
        urls.append(QUrl.fromLocalFile(os.getenv('HOME')))
        urls.append(QUrl.fromLocalFile(os.getenv('WORK')))
        urls.append(QUrl.fromLocalFile(os.getenv('SCRATCH')))
        # urls.append(QUrl.fromLocalFile('/work/08507/joely/ls6/HarrisLabShared'))
    else:
        if os.path.exists('/Volumes'):
            urls.append(QUrl.fromLocalFile('/Volumes'))
        if is_joel():
            if os.path.exists('/Volumes/3dem_data'):
                urls.append(QUrl.fromLocalFile('/Volumes/3dem_data'))


    dialog.setSidebarUrls(urls)
    cfg.main_window.set_status('Awaiting User Input...')
    logger.info('Awaiting user input...')
    if dialog.exec_() == QDialog.Accepted:
        # self.set_mainwindow_project_view()
        return dialog.selectedFiles()
    else:
        logger.warning('Import images dialog did not return a valid file list')
        cfg.main_window.warn('Import images dialog did not return a valid file list')
        return

class QFileDialogPreview(QFileDialog):
    def __init__(self, *args, **kwargs):
        QFileDialog.__init__(self, *args, **kwargs)
        self.setOption(QFileDialog.DontUseNativeDialog, True)
        self.setFixedSize(self.width() + 360, self.height())
        self.mpPreview = QLabel("Preview", self)
        self.mpPreview.setFixedSize(360, 360)
        self.mpPreview.setAlignment(Qt.AlignCenter)
        self.mpPreview.setObjectName("labelPreview")
        box = QVBoxLayout()
        box.addWidget(self.mpPreview)
        box.addStretch()
        self.layout().addLayout(box, 1, 3, 1, 1)
        self.currentChanged.connect(self.onChange)
        self.fileSelected.connect(self.onFileSelected)
        self.filesSelected.connect(self.onFilesSelected)
        self._fileSelected = None
        self._filesSelected = None

    def onChange(self, path):
        pixmap = QPixmap(path)
        if(pixmap.isNull()):
            self.mpPreview.setText('Preview')
        else:
            self.mpPreview.setPixmap(pixmap.scaled(self.mpPreview.width(),
                                                   self.mpPreview.height(),
                                                   Qt.KeepAspectRatio,
                                                   Qt.SmoothTransformation))

    def onFileSelected(self, file):
        self._fileSelected = file
    def onFilesSelected(self, files):
        self._filesSelected = files
    def getFileSelected(self):
        return self._fileSelected
    def getFilesSelected(self):
        return self._filesSelected

#
# class TestMend(QWidget):
#     def __init__(self):
#         super().__init__()
#         layout = QHBoxLayout(self)
#         self.pathEdit = QLineEdit(placeholderText='Select path...')
#         self.button = QToolButton(text='...')
#         layout.addWidget(self.pathEdit)
#         layout.addWidget(self.button)
#         self.button.clicked.connect(self.selectTarget)
#
#     def selectTarget(self):
#         dialog = QFileDialog(self)
#
#         if self.pathEdit.text():
#             dialog.setDirectory(self.pathEdit.text())
#
#         dialog.setFileMode(dialog.Directory)
#
#         # we cannot use the native dialog, because we need control over the UI
#         options = dialog.Options(dialog.DontUseNativeDialog | dialog.ShowDirsOnly)
#         dialog.setOptions(options)
#
#         def checkLineEdit(path):
#             if not path:
#                 return
#             if path.endswith(QDir.separator()):
#                 return checkLineEdit(path.rstrip(QDir.separator()))
#             path = QFileInfo(path)
#             if path.exists() or QFileInfo(path.absolutePath()).exists():
#                 button.setEnabled(True)
#                 return True
#
#         # get the "Open" button in the dialog
#         button = dialog.findChild(QDialogButtonBox).button(QDialogButtonBox.Open)
#
#         # get the line edit used for the path
#         lineEdit = dialog.findChild(QLineEdit)
#         lineEdit.textChanged.connect(checkLineEdit)
#
#         # override the existing accept() method, otherwise selectedFiles() will
#         # complain about selecting a non existing path
#         def accept():
#             if checkLineEdit(lineEdit.text()):
#                 # if the path is acceptable, call the base accept() implementation
#                 QDialog.accept(dialog)
#         dialog.accept = accept
#
#         if dialog.exec_() and dialog.selectedFiles():
#             path = QFileInfo(dialog.selectedFiles()[0]).absoluteFilePath()
#             self.pathEdit.setText(path)

def mendenhall_dialog() -> str:
    home = expanduser("~")
    dialog = QInputDialog()
    dialog.resize(200,500)
    dialog.setInputMode(QInputDialog.TextInput)
    dialog.setWindowTitle('Create Directory')
    dialog.setLabelText('Set Microscope Sink')
    lineEdit = dialog.findChild(QLineEdit)
    lineEdit.setPlaceholderText(home)
    cfg.main_window.set_status('Awaiting User Input...')
    if dialog.exec_():
        path = dialog.textValue()
        logger.info(f'Selected Path: {path}')
        if os.path.exists(path):
            cfg.main_window.hud.post('Path Already Exists', logging.WARNING)
            return
        else:
            try:
                os.mkdir(path)
            except:
                logger.warning(f"Unable to create path '{path}'")
                cfg.main_window.hud.post(f"Unable to create path '{path}'")
            else:
                logger.info(f"Directory Created: {path}")
                cfg.main_window.hud.post(f"Directory Created: {path}")
                return path


def export_affines_dialog() -> str:
    '''Dialog for saving a datamodel. Returns 'filename'.'''
    dialog = QFileDialog()
    dialog.setOption(QFileDialog.DontUseNativeDialog)
    dialog.setWindowTitle('Export Affine Data as .csv')
    dialog.setNameFilter("Text Files (*.csv)")
    dialog.setViewMode(QFileDialog.Detail)
    dialog.setAcceptMode(QFileDialog.AcceptSave)
    cfg.main_window.set_status('Awaiting User Input...')
    if dialog.exec() == QFileDialog.Accepted:
        cfg.main_window.hud.post('Exported: %s' % dialog.selectedFiles()[0])
        return dialog.selectedFiles()[0]


def open_project_dialog() -> str:
    '''Dialog for opening a datamodel. Returns 'filename'.'''
    dialog = QFileDialog()
    dialog.setOption(QFileDialog.DontUseNativeDialog)
    dialog.setWindowTitle('* Open Project *')
    dialog.setNameFilter("Text Files (*.swiftir)")
    dialog.setViewMode(QFileDialog.Detail)
    urls = dialog.sidebarUrls()
    if '.tacc.utexas.edu' in platform.node():
        urls.append(QUrl.fromLocalFile(os.getenv('WORK')))
        urls.append(QUrl.fromLocalFile('/work/08507/joely/ls6/HarrisLabShared'))
    dialog.setSidebarUrls(urls)
    cfg.main_window.set_status('Awaiting User Input...')
    if dialog.exec() == QFileDialog.Accepted:
        # self.hud.post("Loading Project '%s'" % os.path.basename(dialog.selectedFiles()[0]))
        return dialog.selectedFiles()[0]



def new_project_dialog() -> str:
    '''Dialog for saving a datamodel. Returns 'filename'.'''
    dialog = QFileDialog()
    dialog.setOption(QFileDialog.DontUseNativeDialog)
    dialog.setWindowTitle('New Project Name - Set Project Name (1/3)')
    dialog.setNameFilter("Text Files (*.swiftir)")
    dialog.setLabelText(QFileDialog.Accept, "Create")
    dialog.setViewMode(QFileDialog.Detail)
    dialog.setAcceptMode(QFileDialog.AcceptSave)
    dialog.setModal(True)
    # dialog.setFilter(QDir.Hidden)
    dialog.setOptions(dialog.DontUseNativeDialog)
    dialog.setFilter(QDir.AllEntries | QDir.Hidden)
    urls = dialog.sidebarUrls()
    if '.tacc.utexas.edu' in platform.node():
        urls.append(QUrl.fromLocalFile(os.getenv('HOME')))
        urls.append(QUrl.fromLocalFile(os.getenv('WORK')))
        urls.append(QUrl.fromLocalFile(os.getenv('SCRATCH')))
        # urls.append(QUrl(os.getenv('HOME')))
        # urls.append(QUrl(os.getenv('WORK')))
        # urls.append(QUrl(os.getenv('SCRATCH')))
        # urls.append(QUrl.fromLocalFile('/work/08507/joely/ls6/HarrisLabShared'))
    else:
        urls.append(QUrl.fromLocalFile('/tmp'))
        if os.path.exists('/Volumes'):
            urls.append(QUrl.fromLocalFile('/Volumes'))
        if is_joel():
            if os.path.exists('/Volumes/3dem_data'):
                urls.append(QUrl.fromLocalFile('/Volumes/3dem_data'))
    dialog.setSidebarUrls(urls)
    cfg.main_window.set_status('Awaiting User Input...')
    if dialog.exec() == QFileDialog.Accepted:
        logger.info('Save File Path: %s' % dialog.selectedFiles()[0])
        return dialog.selectedFiles()[0]


class AskContinueDialog(QDialog):
    '''Simple dialog to ask user if they wish to proceed. Usage:
        dlg = AskContinueDialog(self)
        if dlg.exec():
            # Do if accepted
        else:
            # Do if Rejected'''
    def __init__(self, title:str, msg:str, parent=None):
        self.parent = parent
        super(AskContinueDialog, self).__init__()

        self.setWindowTitle(title)
        QBtn = QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        self.buttonBox = QDialogButtonBox(QBtn)
        self.buttonBox.accepted.connect(self.accept)
        self.buttonBox.rejected.connect(self.reject)
        self.layout = QVBoxLayout()
        message = QLabel(msg)
        self.layout.addWidget(message)
        self.layout.addWidget(self.buttonBox)
        self.setLayout(self.layout)


# class RenameProject(QWidget):
#
#     def __init__(self):
#         super().__init__()
#         self.initUI()
#
#     def initUI(self):
#         self.btn = QPushButton('Dialog', self)
#         self.btn.move(20, 20)
#         self.btn.clicked.connect(self.showDialog)
#
#         self.le = QLineEdit(self)
#         self.le.move(130, 22)
#
#         self.setGeometry(300, 150, 450, 350)
#         self.setWindowTitle('Rename ProjectTab')
#         self.show()


class ConfigAppDialog(QDialog):
    def __init__(self, parent=None):  # parent=None allows passing in MainWindow if needed
        super().__init__()
        self.parent = parent
        logger.info('Showing Application Configuration Dialog:')
        self.initUI()
        cfg.main_window.set_status('Awaiting User Input...')

    def initUI(self):
        layout = QVBoxLayout()
        self.setLayout(layout)

        # tsWidget = QWidget()
        # tsLayout = QHBoxLayout()
        # tsLayout.setContentsMargins(4, 2, 4, 2)
        # tsWidget.setLayout(tsLayout)
        # self.tsCheckbox = QCheckBox()
        # self.tsCheckbox.setChecked(cfg.USE_TENSORSTORE)
        # tsLayout.addWidget(QLabel('Enable Tensorstore Backend: '))
        # tsLayout.addWidget(self.tsCheckbox, alignment=Qt.AlignRight)

        headlessWidget = QWidget()
        headlessLayout = QHBoxLayout()
        headlessLayout.setContentsMargins(4, 2, 4, 2)
        headlessWidget.setLayout(headlessLayout)
        self.headlessCheckbox = QCheckBox()
        self.headlessCheckbox.setChecked(cfg.HEADLESS)
        headlessLayout.addWidget(QLabel('Enable Neuroglancer Headless Mode: '))
        headlessLayout.addWidget(self.headlessCheckbox, alignment=Qt.AlignRight)

        ngdebugWidget = QWidget()
        ngdebugLayout = QHBoxLayout()
        ngdebugLayout.setContentsMargins(4, 2, 4, 2)
        ngdebugWidget.setLayout(ngdebugLayout)
        self.ngdebugCheckbox = QCheckBox()
        self.ngdebugCheckbox.setChecked(cfg.DEBUG_NEUROGLANCER)
        ngdebugLayout.addWidget(QLabel('Enable Neuroglancer Server Debugging: '))
        ngdebugLayout.addWidget(self.ngdebugCheckbox, alignment=Qt.AlignRight)

        mpdebugWidget = QWidget()
        mpdebugLayout = QHBoxLayout()
        mpdebugLayout.setContentsMargins(4, 2, 4, 2)
        mpdebugWidget.setLayout(mpdebugLayout)
        self.mpdebugCheckbox = QCheckBox()
        self.mpdebugCheckbox.setChecked(cfg.DEBUG_MP)
        mpdebugLayout.addWidget(QLabel('Enable Python Multiprocessing Debugging: '))
        mpdebugLayout.addWidget(self.mpdebugCheckbox, alignment=Qt.AlignRight)

        # useprofilerWidget = QWidget()
        # useprofilerLayout = QHBoxLayout()
        # useprofilerLayout.setContentsMargins(4, 2, 4, 2)
        # useprofilerWidget.setLayout(useprofilerLayout)
        # self.useprofilerCheckbox = QCheckBox()
        # self.useprofilerCheckbox.setChecked(cfg.PROFILER)
        # useprofilerLayout.addWidget(QLabel('Enable Scalene Profiler: '))
        # useprofilerLayout.addWidget(self.useprofilerCheckbox, alignment=Qt.AlignRight)

        faultWidget = QWidget()
        faultLayout = QHBoxLayout()
        faultLayout.setContentsMargins(4, 2, 4, 2)
        faultWidget.setLayout(faultLayout)
        self.faultCheckbox = QCheckBox()
        self.faultCheckbox.setChecked(cfg.FAULT_HANDLER)
        faultLayout.addWidget(QLabel('Enable Fault Handler: '))
        faultLayout.addWidget(self.faultCheckbox, alignment=Qt.AlignRight)

        cancelButton = QPushButton('Cancel')
        cancelButton.setDefault(False)
        cancelButton.setAutoDefault(False)
        cancelButton.clicked.connect(self.on_cancel)
        applyButton = QPushButton('Apply')
        applyButton.setDefault(True)
        applyButton.clicked.connect(self.on_apply)
        buttonLayout = QHBoxLayout()
        buttonLayout.addWidget(cancelButton)
        buttonLayout.addWidget(applyButton)
        buttonWidget = QWidget()
        buttonWidget.setLayout(buttonLayout)

        if 'CONDA_DEFAULT_ENV' in os.environ:
            environLabel = QLabel(f"Conda Environment:  {os.environ['CONDA_DEFAULT_ENV']}\n")
            layout.addWidget(environLabel)


        # layout.addWidget(tsWidget)
        layout.addWidget(headlessWidget)
        layout.addWidget(ngdebugWidget)
        layout.addWidget(mpdebugWidget)
        # layout.addWidget(useprofilerWidget)
        layout.addWidget(faultWidget)
        layout.addWidget(buttonWidget)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(0)


    @Slot()
    def on_apply(self):
        try:
            cfg.main_window.hud('Applying Application Settings...')
            # cfg.USE_TENSORSTORE = self.tsCheckbox.isChecked()
            cfg.HEADLESS = self.headlessCheckbox.isChecked()
            if cfg.HEADLESS:
                if cfg.project_tab:
                    cfg.main_window._tabs.setTabVisible(0, False)
                cfg.main_window.external_hyperlink.show()
            else:
                if cfg.project_tab:
                    cfg.main_window._tabs.setTabVisible(0, True)
                cfg.main_window.external_hyperlink.hide()
            cfg.DEBUG_NEUROGLANCER = self.ngdebugCheckbox.isChecked()
            if ng.is_server_running():
                logger.info(f'Setting Neuroglancer Server Debugging: {cfg.DEBUG_NEUROGLANCER}')
                ng.server.debug = cfg.DEBUG_NEUROGLANCER

            cfg.DEBUG_MP = self.mpdebugCheckbox.isChecked()
            cfg.FAULT_HANDLER = self.faultCheckbox.isChecked()
            if cfg.FAULT_HANDLER:
                if not faulthandler.is_enabled():
                    file=sys.stderr
                    all_threads=True
                    logger.info(f'Enabling faulthandler (file={file}, all_threads={all_threads})...')
                    faulthandler.enable(file=sys.stderr, all_threads=True)
            else:
                if faulthandler.is_enabled():
                    logger.info('Disabling faulthandler...')
                    faulthandler.disable()

        except Exception as e:
            logger.warning(e)
        finally:
            self.accept()

    @Slot()
    def on_cancel(self):
        logger.warning("ConfigProjectDialog Exiting On 'Cancel'...")
        self.close()



class ConfigProjectDialog(QDialog):
    def __init__(self, parent=None): # parent=None allows passing in MainWindow if needed
        super().__init__()
        self.parent = parent
        self.setModal(True)
        logger.info('Showing Project Configuration Dialog:')
        self.cancelButton = QPushButton('Cancel')
        self.cancelButton.setDefault(False)
        self.cancelButton.setAutoDefault(False)
        self.cancelButton.clicked.connect(self.on_cancel)
        self.applyButton = QPushButton('Apply')
        self.applyButton.setDefault(True)
        self.applyButton.clicked.connect(self.on_apply)
        self.buttonLayout = QHBoxLayout()
        self.buttonLayout.addWidget(self.cancelButton)
        self.buttonLayout.addWidget(self.applyButton)
        self.buttonWidget = QWidget()
        self.buttonWidget.setLayout(self.buttonLayout)
        self.tab_widget = QTabWidget()
        self.tab1 = QWidget()
        self.tab2 = QWidget()
        self.tab_widget.addTab(self.tab1, "Main")
        self.tab_widget.addTab(self.tab2, "Storage")
        self.initUI_tab1()
        self.initUI_tab2()
        self.main_layout = QVBoxLayout()
        self.main_layout.addWidget(self.tab_widget)
        self.main_layout.addWidget(self.buttonWidget)
        self.setLayout(self.main_layout)
        self.setWindowTitle("New Project - Project Configuration (3/3)")
        cfg.main_window.hud('Set Scales and Configure:')
        self.show()
        cfg.main_window.set_status('Awaiting User Input...')

    @Slot()
    def on_apply(self):
        try:
            cfg.main_window.hud('Applying Project Settings...')
            cfg.data.set_scales_from_string(self.scales_input.text())
            cfg.data.set_method_options()
            cfg.data.set_use_bounding_rect(self.bounding_rectangle_checkbox.isChecked())
            cfg.data['data']['initial_scale'] = float(self.initial_scale_input.text())
            cfg.data['data']['initial_rotation'] = float(self.initial_rotation_input.text())
            cfg.data['data']['clevel'] = int(self.clevel_input.text())
            cfg.data['data']['cname'] = self.cname_combobox.currentText()
            cfg.data['data']['chunkshape'] = (int(self.chunk_z_lineedit.text()),
                                              int(self.chunk_y_lineedit.text()),
                                              int(self.chunk_x_lineedit.text()))
            for scale in cfg.data.scales():
                scale_val = get_scale_val(scale)
                res_x = int(self.res_x_lineedit.text()) * scale_val
                res_y = int(self.res_y_lineedit.text()) * scale_val
                res_z = int(self.res_z_lineedit.text())
                cfg.data.set_resolution(s=scale, res_x=res_x, res_y=res_y, res_z=res_z)
        except Exception as e:
            logger.warning(e)
        finally:
            cfg.main_window.hud.done()
            self.accept()


    @Slot()
    def on_cancel(self):
        logger.warning("ConfigProjectDialog Exiting On 'Cancel'...")
        self.close()

    def initUI_tab2(self):
        tip = 'Zarr Compression Level\n(default=5)'
        self.clevel_label = QLabel('Compression Level (1-9):')
        self.clevel_label.setToolTip('\n'.join(textwrap.wrap(tip, width=35)))
        self.clevel_input = QLineEdit(self)
        self.clevel_input.setAlignment(Qt.AlignCenter)
        self.clevel_input.setText(str(cfg.data.clevel()))
        self.clevel_input.setFixedWidth(70)
        self.clevel_valid = QIntValidator(1, 9, self)
        self.clevel_input.setValidator(self.clevel_valid)
        self.clevel_layout = QHBoxLayout()
        self.clevel_layout.addWidget(self.clevel_label, alignment=Qt.AlignLeft)
        self.clevel_layout.addWidget(self.clevel_input, alignment=Qt.AlignRight)

        tip = 'Zarr Compression Type\n(default=zstd)'
        self.cname_label = QLabel('Compression Option:')
        self.cname_label.setToolTip('\n'.join(textwrap.wrap(tip, width=35)))
        self.cname_combobox = QComboBox(self)
        # self.cname_combobox.addItems(["zstd", "zlib", "gzip", "none"])
        self.cname_combobox.addItems(["none", "zstd", "zlib"])
        self.cname_combobox.setCurrentText(cfg.data.cname())
        self.cname_combobox.setFixedWidth(78)
        self.cname_layout = QHBoxLayout()
        self.cname_layout.addWidget(self.cname_label, alignment=Qt.AlignLeft)
        self.cname_layout.addWidget(self.cname_combobox, alignment=Qt.AlignRight)

        '''Chunk Shape'''
        self.chunk_shape_label = QLabel("Chunk Shape:")
        self.chunk_x_label = QLabel("x:")
        self.chunk_y_label = QLabel("y:")
        self.chunk_z_label = QLabel("z:")
        self.chunk_x_lineedit = QLineEdit(self)
        self.chunk_y_lineedit = QLineEdit(self)
        self.chunk_z_lineedit = QLineEdit(self)
        # self.chunk_z_lineedit.setEnabled(False)
        self.chunk_x_lineedit.setFixedWidth(40)
        self.chunk_y_lineedit.setFixedWidth(40)
        self.chunk_z_lineedit.setFixedWidth(40)
        chunkshape = cfg.data.chunkshape()
        self.chunk_x_lineedit.setText(str(chunkshape[2]))
        self.chunk_y_lineedit.setText(str(chunkshape[1]))
        self.chunk_z_lineedit.setText(str(chunkshape[0]))
        self.chunk_x_lineedit.setValidator(QIntValidator())
        self.chunk_y_lineedit.setValidator(QIntValidator())
        self.chunk_z_lineedit.setValidator(QIntValidator())
        self.chunk_x_layout = QHBoxLayout()
        self.chunk_y_layout = QHBoxLayout()
        self.chunk_z_layout = QHBoxLayout()
        self.chunk_x_layout.addWidget(self.chunk_x_label, alignment=Qt.AlignRight)
        self.chunk_y_layout.addWidget(self.chunk_y_label, alignment=Qt.AlignRight)
        self.chunk_z_layout.addWidget(self.chunk_z_label, alignment=Qt.AlignRight)
        self.chunk_x_layout.addWidget(self.chunk_x_lineedit, alignment=Qt.AlignLeft)
        self.chunk_y_layout.addWidget(self.chunk_y_lineedit, alignment=Qt.AlignLeft)
        self.chunk_z_layout.addWidget(self.chunk_z_lineedit, alignment=Qt.AlignLeft)
        self.chunk_shape_layout = QHBoxLayout()
        self.chunk_shape_layout.addLayout(self.chunk_z_layout)
        self.chunk_shape_layout.addLayout(self.chunk_y_layout)
        self.chunk_shape_layout.addLayout(self.chunk_x_layout)
        self.chunk_shape_widget = QWidget()
        self.chunk_shape_widget.setLayout(self.chunk_shape_layout)
        self.chunk_layout = QHBoxLayout()
        self.chunk_layout.addWidget(self.chunk_shape_label, alignment=Qt.AlignLeft)
        self.chunk_layout.addWidget(self.chunk_shape_widget, alignment=Qt.AlignRight)

        txt = "AlignEM-SWiFT uses a chunked and compressed N-dimensional file format called Zarr for rapid viewing of " \
              "volumetric datamodel in Neuroglancer. These settings determine the way volumetric datamodel is " \
              "stored and retrieved from disk storage."
        txt = '\n'.join(textwrap.wrap(txt, width=55))
        self.storage_info_label = QLabel(txt)

        self.export_settings_layout = QGridLayout()
        self.export_settings_layout.addLayout(self.cname_layout, 0, 0)
        self.export_settings_layout.addLayout(self.clevel_layout, 1, 0)
        self.export_settings_layout.addLayout(self.chunk_layout, 2, 0)
        self.export_settings_layout.addWidget(self.storage_info_label, 3, 0)

        self.tab2.setLayout(self.export_settings_layout)


    def initUI_tab1(self):
        '''Scales Field'''
        # if not cfg.datamodel.is_mendenhall(): #0103-

        if do_scales_exist():
            scales_lst = [str(v) for v in
                              sorted([get_scale_val(s) for s in cfg.data['data']['scales'].keys()])]
        else:
            width, height = cfg.data.image_size(s='scale_1')
            if (width*height) > 400_000_000:
                scales_lst = ['24 6 2 1']
            elif (width*height) > 200_000_000:
                scales_lst = ['16 6 2 1']
            elif (width * height) > 100_000_000:
                scales_lst = ['8 2 1']
            elif (width * height) > 10_000_000:
                scales_lst = ['4 2 1']
            else:
                scales_lst = ['4 1']

        scales_str = ' '.join(scales_lst)
        self.scales_label = QLabel("Scale Factors:")
        self.scales_input = QLineEdit(self)
        self.scales_input.setFixedWidth(130)
        self.scales_input.setText(scales_str)
        self.scales_input.setAlignment(Qt.AlignCenter)
        tip = "Scale factors, separated by spaces.\n(example) To generate 4x 2x and 1x/full scales, type: 4 2 1"
        self.scale_instructions_label = QLabel(tip)
        self.scale_instructions_label.setStyleSheet("font-size: 11px;")
        self.scales_label.setToolTip(tip)
        self.scales_input.setToolTip(tip)
        self.scales_layout = QHBoxLayout()
        self.scales_layout.addWidget(self.scales_label, alignment=Qt.AlignLeft)
        self.scales_layout.addWidget(self.scales_input, alignment=Qt.AlignRight)

        '''Resolution Fields'''
        tip = "Resolution or size of each voxel (nm)"
        self.resolution_label = QLabel("Voxel Size (nm):")
        self.resolution_label.setToolTip(tip)
        self.res_x_label = QLabel("x:")
        self.res_x_label.setToolTip('X-dimension of each pixel')
        self.res_y_label = QLabel("y:")
        self.res_x_label.setToolTip('Y-dimension of each pixel')
        self.res_z_label = QLabel("z:")
        self.res_x_label.setToolTip('Tissue thickness, usually')
        self.res_x_lineedit = QLineEdit(self)
        self.res_y_lineedit = QLineEdit(self)
        self.res_z_lineedit = QLineEdit(self)
        self.res_x_lineedit.setFixedWidth(40)
        self.res_y_lineedit.setFixedWidth(40)
        self.res_z_lineedit.setFixedWidth(40)
        # self.res_x_lineedit.setText(str(cfg.datamodel['data']['resolution_x']))
        # self.res_y_lineedit.setText(str(cfg.datamodel['data']['resolution_y']))
        # self.res_z_lineedit.setText(str(cfg.datamodel['data']['resolution_z']))
        self.res_x_lineedit.setText(str(cfg.DEFAULT_RESX))
        self.res_y_lineedit.setText(str(cfg.DEFAULT_RESY))
        self.res_z_lineedit.setText(str(cfg.DEFAULT_RESZ))
        self.res_x_lineedit.setValidator(QIntValidator())
        self.res_y_lineedit.setValidator(QIntValidator())
        self.res_z_lineedit.setValidator(QIntValidator())
        self.res_x_layout = QHBoxLayout()
        self.res_y_layout = QHBoxLayout()
        self.res_z_layout = QHBoxLayout()
        self.res_x_layout.addWidget(self.res_x_label, alignment=Qt.AlignRight)
        self.res_y_layout.addWidget(self.res_y_label, alignment=Qt.AlignRight)
        self.res_z_layout.addWidget(self.res_z_label, alignment=Qt.AlignRight)
        self.res_x_layout.addWidget(self.res_x_lineedit, alignment=Qt.AlignLeft)
        self.res_y_layout.addWidget(self.res_y_lineedit, alignment=Qt.AlignLeft)
        self.res_z_layout.addWidget(self.res_z_lineedit, alignment=Qt.AlignLeft)
        self.resolution_layout = QHBoxLayout()
        self.resolution_layout.addLayout(self.res_x_layout)
        self.resolution_layout.addLayout(self.res_y_layout)
        self.resolution_layout.addLayout(self.res_z_layout)
        self.resolution_widget = QWidget()
        self.resolution_widget.setToolTip(tip)
        self.resolution_widget.setLayout(self.resolution_layout)
        self.resolution_layout = QHBoxLayout()
        self.resolution_layout.addWidget(self.resolution_label, Qt.AlignLeft)
        self.resolution_layout.addWidget(self.resolution_widget, Qt.AlignRight)

        if not cfg.data.is_mendenhall():
            '''Initial Rotation Field'''
            tip = "Initial rotation is sometimes needed to prevent alignment from " \
                  "aligning to unseen artifacts (default=0.0000)"
            self.initial_rotation_label = QLabel("Initial Rotation:")
            self.initial_rotation_input = QLineEdit(self)
            self.initial_rotation_input.setFixedWidth(70)
            self.initial_rotation_input.setText(str(cfg.DEFAULT_INITIAL_ROTATION))
            self.initial_rotation_input.setValidator(QDoubleValidator(0.0000, 5.0000, 4, self))
            self.initial_rotation_input.setAlignment(Qt.AlignCenter)
            self.initial_rotation_layout = QHBoxLayout()
            self.initial_rotation_layout.addWidget(self.initial_rotation_label, alignment=Qt.AlignLeft)
            self.initial_rotation_layout.addWidget(self.initial_rotation_input, alignment=Qt.AlignRight)
            self.initial_rotation_input.setToolTip("\n".join(textwrap.wrap(tip, width=35)))

            '''Initial Scale Field'''
            self.initial_scale_label = QLabel("Initial Scale:")
            self.initial_scale_input = QLineEdit(self)
            self.initial_scale_input.setFixedWidth(70)
            self.initial_scale_input.setText(str(cfg.DEFAULT_INITIAL_SCALE))
            self.initial_scale_input.setValidator(QDoubleValidator(0.0000, 5.0000, 4, self))
            self.initial_scale_input.setAlignment(Qt.AlignCenter)
            self.initial_scale_layout = QHBoxLayout()
            self.initial_scale_layout.addWidget(self.initial_scale_label, alignment=Qt.AlignLeft)
            self.initial_scale_layout.addWidget(self.initial_scale_input, alignment=Qt.AlignRight)

        '''Bounding Box Field'''
        self.bounding_rectangle_label = QLabel("Bounding Box:")
        self.bounding_rectangle_checkbox = QCheckBox()
        # self.bounding_rectangle_checkbox.setChecked(cfg.DEFAULT_BOUNDING_BOX)
        self.bounding_rectangle_checkbox.setChecked(cfg.main_window._bbToggle.isChecked())
        # ^ after much thought, may be best to init this from a default when the application is opened,
        # then let it always represent its true value regardless if new projects are opened, etc. Most intuitive (?).
        self.bounding_rectangle_layout = QHBoxLayout()
        self.bounding_rectangle_layout.addWidget(self.bounding_rectangle_label, alignment=Qt.AlignLeft)
        self.bounding_rectangle_layout.addWidget(self.bounding_rectangle_checkbox, alignment=Qt.AlignRight)

        '''Groupbox QFormLayout'''
        layout = QGridLayout()
        if not cfg.data.is_mendenhall():
            layout.addLayout(self.scales_layout , 0, 0)
            layout.addWidget(self.scale_instructions_label , 1, 0)
        layout.addLayout(self.resolution_layout, 2, 0)
        if not cfg.data.is_mendenhall():
            layout.addLayout(self.initial_rotation_layout, 3, 0)
            layout.addLayout(self.initial_scale_layout, 4, 0)
        layout.addLayout(self.bounding_rectangle_layout, 5, 0)
        self.tab1.setLayout(layout)




class RechunkDialog(QDialog):
    def __init__(self, parent=None, target=None): # parent=None allows passing in MainWindow if needed
        super().__init__()
        self.parent = parent
        self.target=target
        self.setModal(True)
        self.setFixedSize(400, 240)
        logger.info('Showing Project Configuration Dialog:')

        self.initUI()
        self.setWindowTitle("Rechunk - Select Chunk Shape")
        cfg.main_window.hud('Select Chunk Shape:')
        self.show()
        cfg.main_window.set_status('Awaiting User Input...')

    @Slot()
    def on_apply(self):

        logger.info('Setting chunk shape for rechunking...')
        z = min(int(self.chunk_z_lineedit.text()), len(cfg.data))
        y = int(self.chunk_y_lineedit.text())
        x = int(self.chunk_x_lineedit.text())
        try:

            cfg.data['data']['chunkshape'] = (z, y, x)
            self.chunkshape = (z, y, x)

        except Exception as e:
            logger.warning(e)

        finally:
            self.accept()


    @Slot()
    def on_cancel(self):
        logger.warning("Exiting On 'Cancel'...")
        self.close()

    def initUI(self):


        '''Chunk Shape'''
        self.chunk_shape_label = QLabel("Chunk Shape:")
        self.chunk_x_label = QLabel("x:")
        self.chunk_y_label = QLabel("y:")
        self.chunk_z_label = QLabel("z:")
        self.chunk_x_lineedit = QLineEdit(self)
        self.chunk_y_lineedit = QLineEdit(self)
        self.chunk_z_lineedit = QLineEdit(self)
        # self.chunk_z_lineedit.setEnabled(False)
        self.chunk_x_lineedit.setFixedWidth(40)
        self.chunk_y_lineedit.setFixedWidth(40)
        self.chunk_z_lineedit.setFixedWidth(40)
        chunkshape = cfg.data.chunkshape()
        self.chunk_x_lineedit.setText(str(chunkshape[2]))
        self.chunk_y_lineedit.setText(str(chunkshape[1]))
        self.chunk_z_lineedit.setText(str(chunkshape[0]))
        img_size = cfg.data.image_size()
        # self.chunk_x_lineedit.setValidator(QIntValidator(0, img_size[0]))
        # self.chunk_y_lineedit.setValidator(QIntValidator(0, img_size[1]))
        # self.chunk_z_lineedit.setValidator(QIntValidator(0, len(cfg.data)))
        self.chunk_x_lineedit.setValidator(QIntValidator(0, img_size[0]))
        self.chunk_y_lineedit.setValidator(QIntValidator(0, img_size[1]))
        self.chunk_z_lineedit.setValidator(QIntValidator(0, cfg.data.nSections))
        self.chunk_x_layout = QHBoxLayout()
        self.chunk_x_layout.setContentsMargins(4,4,4,4)
        self.chunk_y_layout = QHBoxLayout()
        self.chunk_y_layout.setContentsMargins(4,4,4,4)
        self.chunk_z_layout = QHBoxLayout()
        self.chunk_z_layout.setContentsMargins(4,4,4,4)
        self.chunk_x_layout.addWidget(self.chunk_x_label, alignment=Qt.AlignRight)
        self.chunk_y_layout.addWidget(self.chunk_y_label, alignment=Qt.AlignRight)
        self.chunk_z_layout.addWidget(self.chunk_z_label, alignment=Qt.AlignRight)
        self.chunk_x_layout.addWidget(self.chunk_x_lineedit, alignment=Qt.AlignLeft)
        self.chunk_y_layout.addWidget(self.chunk_y_lineedit, alignment=Qt.AlignLeft)
        self.chunk_z_layout.addWidget(self.chunk_z_lineedit, alignment=Qt.AlignLeft)
        self.chunk_shape_layout = QHBoxLayout()
        self.chunk_shape_layout.setContentsMargins(4,4,4,4)
        self.chunk_shape_layout.addLayout(self.chunk_z_layout)
        self.chunk_shape_layout.addLayout(self.chunk_y_layout)
        self.chunk_shape_layout.addLayout(self.chunk_x_layout)
        w = QWidget()
        w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.chunk_shape_layout.addWidget(w)
        self.chunk_shape_widget = QWidget()
        self.chunk_layout = QHBoxLayout()
        self.chunk_layout.addWidget(self.chunk_shape_label, alignment=Qt.AlignLeft)
        self.chunk_layout.addWidget(self.chunk_shape_widget, alignment=Qt.AlignRight)
        self.chunk_shape_widget.setLayout(self.chunk_shape_layout)

        txt = "AlignEM-SWiFT uses a chunked and compressed N-dimensional file format called Zarr for " \
              "rapid viewing of volumetric datamodel in Neuroglancer. These settings determine the way " \
              "volumetric datamodel is stored on disk."
        txt = '\n'.join(textwrap.wrap(txt, width=55))
        self.storage_info_label = QLabel(txt)

        txt = "Rechunk '%s'..." %self.target
        txt = '\n'.join(textwrap.wrap(txt, width=55))
        self.main_text = QLabel(txt)

        self.cancelButton = QPushButton('Cancel')
        self.cancelButton.setDefault(False)
        self.cancelButton.setAutoDefault(False)
        self.cancelButton.clicked.connect(self.on_cancel)
        self.applyButton = QPushButton('Apply')
        self.applyButton.setDefault(True)
        self.applyButton.clicked.connect(self.on_apply)
        hbl = QHBoxLayout()
        hbl.addWidget(self.cancelButton)
        hbl.addWidget(self.applyButton)
        self.buttonWidget = QWidget()
        self.buttonWidget.setLayout(hbl)

        vbl = QVBoxLayout()
        vbl.setContentsMargins(4,4,4,4)
        vbl.addWidget(self.main_text)
        vbl.addWidget(self.chunk_shape_widget)
        vbl.addWidget(self.buttonWidget)
        vbl.addWidget(self.storage_info_label)

        self.setLayout(vbl)




class ScaleProjectDialog(QDialog):
    def __init__(self, parent=None): # parent=None allows passing in MainWindow if needed
        super().__init__()
        self.parent = parent
        self.setModal(True)
        logger.info('Showing Project Configuration Dialog:')
        # self.cancelButton = QPushButton('Cancel')
        # self.cancelButton.setDefault(False)
        # self.cancelButton.setAutoDefault(False)
        # self.cancelButton.clicked.connect(self.on_cancel)
        # self.applyButton = QPushButton('Apply')
        self.applyButton = QPushButton('Scale && Configure')
        self.applyButton.setDefault(True)
        self.applyButton.clicked.connect(self.on_apply)
        self.buttonLayout = QHBoxLayout()
        # self.buttonLayout.addWidget(self.cancelButton)
        self.buttonLayout.addWidget(self.applyButton)
        self.buttonWidget = QWidget()
        self.buttonWidget.setLayout(self.buttonLayout)
        self.tab_widget = QTabWidget()
        self.tab1 = QWidget()
        self.tab2 = QWidget()
        self.tab_widget.addTab(self.tab1, "Main")
        self.tab_widget.addTab(self.tab2, "Storage")
        self.initUI_tab1()
        self.initUI_tab2()
        self.main_layout = QVBoxLayout()
        self.main_layout.addWidget(self.tab_widget)
        self.main_layout.addWidget(self.buttonWidget)
        self.setLayout(self.main_layout)
        self.setWindowTitle("New Project - Project Configuration (3/3)")
        cfg.main_window.hud('Set Scales and Configure:')
        self.show()
        cfg.main_window.set_status('Awaiting User Input...')

    @Slot()
    def on_apply(self):
        try:
            cfg.main_window.hud('Applying Project Settings...')
            cfg.data.set_scales_from_string(self.scales_input.text())
            cfg.data.set_method_options()
            cfg.data.set_use_bounding_rect(self.bounding_rectangle_checkbox.isChecked())
            cfg.data['data']['initial_scale'] = float(self.initial_scale_input.text())
            cfg.data['data']['initial_rotation'] = float(self.initial_rotation_input.text())
            cfg.data['data']['clevel'] = int(self.clevel_input.text())
            cfg.data['data']['cname'] = self.cname_combobox.currentText()
            cfg.data['data']['chunkshape'] = (int(self.chunk_z_lineedit.text()),
                                              int(self.chunk_y_lineedit.text()),
                                              int(self.chunk_x_lineedit.text()))
            for scale in cfg.data.scales():
                scale_val = get_scale_val(scale)
                res_x = int(self.res_x_lineedit.text()) * scale_val
                res_y = int(self.res_y_lineedit.text()) * scale_val
                res_z = int(self.res_z_lineedit.text())
                cfg.data.set_resolution(s=scale, res_x=res_x, res_y=res_y, res_z=res_z)
        except Exception as e:
            logger.warning(e)
        finally:
            cfg.main_window.hud.done()
            self.accept()


    @Slot()
    def on_cancel(self):
        logger.warning("ConfigProjectDialog Exiting On 'Cancel'...")
        self.close()

    def initUI_tab2(self):
        tip = 'Zarr Compression Level\n(default=5)'
        self.clevel_label = QLabel('Compression Level (1-9):')
        self.clevel_label.setToolTip('\n'.join(textwrap.wrap(tip, width=35)))
        self.clevel_input = QLineEdit(self)
        self.clevel_input.setAlignment(Qt.AlignCenter)
        self.clevel_input.setText(str(cfg.data.clevel()))
        self.clevel_input.setFixedWidth(70)
        self.clevel_valid = QIntValidator(1, 9, self)
        self.clevel_input.setValidator(self.clevel_valid)
        self.clevel_layout = QHBoxLayout()
        self.clevel_layout.addWidget(self.clevel_label, alignment=Qt.AlignLeft)
        self.clevel_layout.addWidget(self.clevel_input, alignment=Qt.AlignRight)

        tip = 'Zarr Compression Type\n(default=zstd)'
        self.cname_label = QLabel('Compression Option:')
        self.cname_label.setToolTip('\n'.join(textwrap.wrap(tip, width=35)))
        self.cname_combobox = QComboBox(self)
        # self.cname_combobox.addItems(["zstd", "zlib", "gzip", "none"])
        self.cname_combobox.addItems(["none", "zstd", "zlib"])
        self.cname_combobox.setCurrentText(cfg.data.cname())
        self.cname_combobox.setFixedWidth(78)
        self.cname_layout = QHBoxLayout()
        self.cname_layout.addWidget(self.cname_label, alignment=Qt.AlignLeft)
        self.cname_layout.addWidget(self.cname_combobox, alignment=Qt.AlignRight)

        '''Chunk Shape'''
        self.chunk_shape_label = QLabel("Chunk Shape:")
        self.chunk_x_label = QLabel("x:")
        self.chunk_y_label = QLabel("y:")
        self.chunk_z_label = QLabel("z:")
        self.chunk_x_lineedit = QLineEdit(self)
        self.chunk_y_lineedit = QLineEdit(self)
        self.chunk_z_lineedit = QLineEdit(self)
        # self.chunk_z_lineedit.setEnabled(False)
        self.chunk_x_lineedit.setFixedWidth(40)
        self.chunk_y_lineedit.setFixedWidth(40)
        self.chunk_z_lineedit.setFixedWidth(40)
        chunkshape = cfg.data.chunkshape()
        self.chunk_x_lineedit.setText(str(chunkshape[2]))
        self.chunk_y_lineedit.setText(str(chunkshape[1]))
        self.chunk_z_lineedit.setText(str(chunkshape[0]))
        self.chunk_x_lineedit.setValidator(QIntValidator())
        self.chunk_y_lineedit.setValidator(QIntValidator())
        self.chunk_z_lineedit.setValidator(QIntValidator())
        self.chunk_x_layout = QHBoxLayout()
        self.chunk_y_layout = QHBoxLayout()
        self.chunk_z_layout = QHBoxLayout()
        self.chunk_x_layout.addWidget(self.chunk_x_label, alignment=Qt.AlignRight)
        self.chunk_y_layout.addWidget(self.chunk_y_label, alignment=Qt.AlignRight)
        self.chunk_z_layout.addWidget(self.chunk_z_label, alignment=Qt.AlignRight)
        self.chunk_x_layout.addWidget(self.chunk_x_lineedit, alignment=Qt.AlignLeft)
        self.chunk_y_layout.addWidget(self.chunk_y_lineedit, alignment=Qt.AlignLeft)
        self.chunk_z_layout.addWidget(self.chunk_z_lineedit, alignment=Qt.AlignLeft)
        self.chunk_shape_layout = QHBoxLayout()
        self.chunk_shape_layout.addLayout(self.chunk_z_layout)
        self.chunk_shape_layout.addLayout(self.chunk_y_layout)
        self.chunk_shape_layout.addLayout(self.chunk_x_layout)
        self.chunk_shape_widget = QWidget()
        self.chunk_shape_widget.setLayout(self.chunk_shape_layout)
        self.chunk_layout = QHBoxLayout()
        self.chunk_layout.addWidget(self.chunk_shape_label, alignment=Qt.AlignLeft)
        self.chunk_layout.addWidget(self.chunk_shape_widget, alignment=Qt.AlignRight)

        txt = "AlignEM-SWiFT uses a chunked and compressed N-dimensional file format called Zarr for " \
              "rapid viewing of volumetric datamodel in Neuroglancer. These settings determine the way " \
              "volumetric datamodel is stored on disk."
        txt = '\n'.join(textwrap.wrap(txt, width=55))
        self.storage_info_label = QLabel(txt)

        self.export_settings_layout = QGridLayout()
        self.export_settings_layout.addLayout(self.cname_layout, 0, 0)
        self.export_settings_layout.addLayout(self.clevel_layout, 1, 0)
        self.export_settings_layout.addLayout(self.chunk_layout, 2, 0)
        self.export_settings_layout.addWidget(self.storage_info_label, 3, 0)

        self.tab2.setLayout(self.export_settings_layout)


    def initUI_tab1(self):
        '''Scales Field'''
        # if not cfg.datamodel.is_mendenhall(): #0103-

        if do_scales_exist():
            scales_lst = [str(v) for v in
                              sorted([get_scale_val(s) for s in cfg.data['data']['scales'].keys()])]
        else:
            width, height = cfg.data.image_size(s='scale_1')
            if (width*height) > 400_000_000:
                scales_lst = ['24 6 2 1']
            elif (width*height) > 200_000_000:
                scales_lst = ['16 6 2 1']
            elif (width * height) > 100_000_000:
                scales_lst = ['8 2 1']
            elif (width * height) > 10_000_000:
                scales_lst = ['4 2 1']
            else:
                scales_lst = ['4 1']

        scales_str = ' '.join(scales_lst)
        self.scales_label = QLabel("Scale Factors:")
        self.scales_input = QLineEdit(self)
        self.scales_input.setFixedWidth(130)
        self.scales_input.setText(scales_str)
        self.scales_input.setAlignment(Qt.AlignCenter)
        tip = "Scale factors, separated by spaces.\n(example) To generate 4x 2x and 1x/full scales, type: 4 2 1"
        self.scale_instructions_label = QLabel(tip)
        self.scale_instructions_label.setStyleSheet("font-size: 11px;")
        self.scales_label.setToolTip(tip)
        self.scales_input.setToolTip(tip)
        self.scales_layout = QHBoxLayout()
        self.scales_layout.addWidget(self.scales_label, alignment=Qt.AlignLeft)
        self.scales_layout.addWidget(self.scales_input, alignment=Qt.AlignRight)

        '''Resolution Fields'''
        tip = "Resolution or size of each voxel (nm)"
        self.resolution_label = QLabel("Voxel Size (nm):")
        self.resolution_label.setToolTip(tip)
        self.res_x_label = QLabel("x:")
        self.res_x_label.setToolTip('X-dimension of each pixel')
        self.res_y_label = QLabel("y:")
        self.res_x_label.setToolTip('Y-dimension of each pixel')
        self.res_z_label = QLabel("z:")
        self.res_x_label.setToolTip('Tissue thickness, usually')
        self.res_x_lineedit = QLineEdit(self)
        self.res_y_lineedit = QLineEdit(self)
        self.res_z_lineedit = QLineEdit(self)
        self.res_x_lineedit.setFixedWidth(40)
        self.res_y_lineedit.setFixedWidth(40)
        self.res_z_lineedit.setFixedWidth(40)
        # self.res_x_lineedit.setText(str(cfg.datamodel['data']['resolution_x']))
        # self.res_y_lineedit.setText(str(cfg.datamodel['data']['resolution_y']))
        # self.res_z_lineedit.setText(str(cfg.datamodel['data']['resolution_z']))
        self.res_x_lineedit.setText(str(cfg.DEFAULT_RESX))
        self.res_y_lineedit.setText(str(cfg.DEFAULT_RESY))
        self.res_z_lineedit.setText(str(cfg.DEFAULT_RESZ))
        self.res_x_lineedit.setValidator(QIntValidator())
        self.res_y_lineedit.setValidator(QIntValidator())
        self.res_z_lineedit.setValidator(QIntValidator())
        self.res_x_layout = QHBoxLayout()
        self.res_y_layout = QHBoxLayout()
        self.res_z_layout = QHBoxLayout()
        self.res_x_layout.addWidget(self.res_x_label, alignment=Qt.AlignRight)
        self.res_y_layout.addWidget(self.res_y_label, alignment=Qt.AlignRight)
        self.res_z_layout.addWidget(self.res_z_label, alignment=Qt.AlignRight)
        self.res_x_layout.addWidget(self.res_x_lineedit, alignment=Qt.AlignLeft)
        self.res_y_layout.addWidget(self.res_y_lineedit, alignment=Qt.AlignLeft)
        self.res_z_layout.addWidget(self.res_z_lineedit, alignment=Qt.AlignLeft)
        self.resolution_layout = QHBoxLayout()
        self.resolution_layout.addLayout(self.res_x_layout)
        self.resolution_layout.addLayout(self.res_y_layout)
        self.resolution_layout.addLayout(self.res_z_layout)
        self.resolution_widget = QWidget()
        self.resolution_widget.setToolTip(tip)
        self.resolution_widget.setLayout(self.resolution_layout)
        self.resolution_layout = QHBoxLayout()
        self.resolution_layout.addWidget(self.resolution_label, Qt.AlignLeft)
        self.resolution_layout.addWidget(self.resolution_widget, Qt.AlignRight)

        if not cfg.data.is_mendenhall():
            '''Initial Rotation Field'''
            tip = "Initial rotation is sometimes needed to prevent alignment from " \
                  "aligning to unseen artifacts (default=0.0000)"
            self.initial_rotation_label = QLabel("Initial Rotation:")
            self.initial_rotation_input = QLineEdit(self)
            self.initial_rotation_input.setFixedWidth(70)
            self.initial_rotation_input.setText(str(cfg.DEFAULT_INITIAL_ROTATION))
            self.initial_rotation_input.setValidator(QDoubleValidator(0.0000, 5.0000, 4, self))
            self.initial_rotation_input.setAlignment(Qt.AlignCenter)
            self.initial_rotation_layout = QHBoxLayout()
            self.initial_rotation_layout.addWidget(self.initial_rotation_label, alignment=Qt.AlignLeft)
            self.initial_rotation_layout.addWidget(self.initial_rotation_input, alignment=Qt.AlignRight)
            self.initial_rotation_input.setToolTip("\n".join(textwrap.wrap(tip, width=35)))

            '''Initial Scale Field'''
            self.initial_scale_label = QLabel("Initial Scale:")
            self.initial_scale_input = QLineEdit(self)
            self.initial_scale_input.setFixedWidth(70)
            self.initial_scale_input.setText(str(cfg.DEFAULT_INITIAL_SCALE))
            self.initial_scale_input.setValidator(QDoubleValidator(0.0000, 5.0000, 4, self))
            self.initial_scale_input.setAlignment(Qt.AlignCenter)
            self.initial_scale_layout = QHBoxLayout()
            self.initial_scale_layout.addWidget(self.initial_scale_label, alignment=Qt.AlignLeft)
            self.initial_scale_layout.addWidget(self.initial_scale_input, alignment=Qt.AlignRight)

        '''Bounding Box Field'''
        self.bounding_rectangle_label = QLabel("Bounding Box:")
        self.bounding_rectangle_checkbox = QCheckBox()
        # self.bounding_rectangle_checkbox.setChecked(cfg.DEFAULT_BOUNDING_BOX)
        self.bounding_rectangle_checkbox.setChecked(cfg.main_window._bbToggle.isChecked())
        # ^ after much thought, may be best to init this from a default when the application is opened,
        # then let it always represent its true value regardless if new projects are opened, etc. Most intuitive (?).
        self.bounding_rectangle_layout = QHBoxLayout()
        self.bounding_rectangle_layout.addWidget(self.bounding_rectangle_label, alignment=Qt.AlignLeft)
        self.bounding_rectangle_layout.addWidget(self.bounding_rectangle_checkbox, alignment=Qt.AlignRight)

        '''Groupbox QFormLayout'''
        layout = QGridLayout()
        if not cfg.data.is_mendenhall():
            layout.addLayout(self.scales_layout , 0, 0)
            layout.addWidget(self.scale_instructions_label , 1, 0)
        layout.addLayout(self.resolution_layout, 2, 0)
        if not cfg.data.is_mendenhall():
            layout.addLayout(self.initial_rotation_layout, 3, 0)
            layout.addLayout(self.initial_scale_layout, 4, 0)
        layout.addLayout(self.bounding_rectangle_layout, 5, 0)
        self.tab1.setLayout(layout)




def show_ng_commands():
    msgBox = QMessageBox()
    msgBox.setIcon(QMessageBox.Information)
    msgBox.setText('pop up text')
    msgBox.setWindowTitle('title')
    # msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
    msgBox.setStandardButtons(QMessageBox.Ok)
    # msgBox.buttonClicked.connect(msgButtonClick)
    # returnValue = msgBox.exec()
    # if returnValue == QMessageBox.Ok:
    #     print('OK clicked')


class DefaultsModel(QAbstractListModel):
    def __init__(self, data, parent=None):
        QAbstractListModel.__init__(self, parent)
        self.lst = data

    # def columnCount(self, parent=QModelIndex()):
    #     return len(self.lst[0])

    def rowCount(self, parent=QModelIndex()):
        return len(self.lst)

    def data(self, index, role=Qt.DisplayRole):
        row = index.column()
        if role == Qt.EditRole:       return self.lst[row]
        elif role == Qt.DisplayRole:  return self.lst[row]

    def flags(self, index):
        flags = super(DefaultsModel, self).flags(index)

        if index.isValid():
            flags |= Qt.ItemIsEditable
            flags |= Qt.ItemIsDragEnabled
        else:
            flags = Qt.ItemIsDropEnabled

        return flags

    def setData(self, index, value, role=Qt.EditRole):
        if not index.isValid() or role != Qt.EditRole:  return False
        self.lst[index.row()] = value
        self.dataChanged.emit(index, index, list())
        return True

__all__ = ['FileBrowser']

logger = logging.getLogger(__name__)


class FileBrowser(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.treeview = QTreeView()
        self.treeview.setStyleSheet('border-width: 0px;')
        self.treeview.expandsOnDoubleClick()
        self.treeview.setAnimated(True)
        self.treeview.setAlternatingRowColors(True)
        self.treeview.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.fileSystemModel = QFileSystemModel(self.treeview)
        self.fileSystemModel.setReadOnly(False)
        self.fileSystemModel.setFilter(QDir.AllEntries | QDir.Hidden)
        self.treeview.setModel(self.fileSystemModel)
        # root = self.fileSystemModel.setRootPath(os.path.expanduser('~'))
        root = self.fileSystemModel.setRootPath('/')
        self.treeview.setRootIndex(root)

        self.path_scratch = os.getenv('SCRATCH')
        self.path_work = os.getenv('WORK')
        self.path_special = '/Volumes/3dem_data'

        self.treeview.setColumnWidth(0, 600)
        self.initUI()
        self.treeview.selectionModel().selectionChanged.connect(self.selectionChanged)

    def setRootHome(self):
        try:    self.treeview.setRootIndex(self.fileSystemModel.index(os.path.expanduser('~')))
        except: cfg.main_window.warn('Directory cannot be accessed')

    def setRootRoot(self):
        try:    self.treeview.setRootIndex(self.fileSystemModel.index('/'))
        except: cfg.main_window.warn('Directory cannot be accessed')

    def setRootWork(self):
        try:   self.treeview.setRootIndex(self.fileSystemModel.index(self.path_work))
        except: cfg.main_window.warn('Directory cannot be accessed')

    def setRootScratch(self):
        try:    self.treeview.setRootIndex(self.fileSystemModel.index(self.path_scratch))
        except: cfg.main_window.warn('Directory cannot be accessed')

    def setRootSpecial(self):
        try:    self.treeview.setRootIndex(self.fileSystemModel.index(self.path_special))
        except: cfg.main_window.warn('Directory cannot be accessed')


    def initUI(self):
        with open('src/styles/controls.qss', 'r') as f:
            style = f.read()

        self._btn_showFileBrowser = QPushButton('Hide Files')
        self._btn_showFileBrowser.setFixedSize(86, 18)
        self._btn_showFileBrowser.setStyleSheet(style)
        self._btn_showFileBrowser.hide()
        self._btn_showFileBrowser.clicked.connect(self._showHideFb)

        hbl = QHBoxLayout()
        hbl.setContentsMargins(4, 2, 4, 2)
        hbl.addWidget(self._btn_showFileBrowser, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addStretch()
        self.controls = QWidget()
        self.controls.setFixedHeight(24)
        self.controls.setLayout(hbl)
        self.controls.hide()

        self.buttonSetRootRoot = QPushButton('Root')
        self.buttonSetRootRoot.setFixedSize(64, 20)
        self.buttonSetRootRoot.clicked.connect(self.setRootRoot)

        self.buttonSetRootHome = QPushButton('Home')
        self.buttonSetRootHome.setFixedSize(64, 20)
        self.buttonSetRootHome.clicked.connect(self.setRootHome)

        self.buttonSetRootWork = QPushButton('Work')
        self.buttonSetRootWork.setFixedSize(64, 20)
        self.buttonSetRootWork.clicked.connect(self.setRootWork)

        self.buttonSetRootScratch = QPushButton('Scratch')
        self.buttonSetRootScratch.setFixedSize(64, 20)
        self.buttonSetRootScratch.clicked.connect(self.setRootScratch)

        self.buttonSetRootSpecial = QPushButton('SanDisk')
        self.buttonSetRootSpecial.setFixedSize(64, 20)
        self.buttonSetRootSpecial.clicked.connect(self.setRootSpecial)

        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        if not is_tacc(): hbl.addWidget(self.buttonSetRootRoot)
        hbl.addWidget(self.buttonSetRootHome)

        if self.path_work: hbl.addWidget(self.buttonSetRootWork)
        if self.path_scratch: hbl.addWidget(self.buttonSetRootScratch)
        if is_joel():
            if os.path.exists(self.path_special):
                hbl.addWidget(self.buttonSetRootSpecial)

        self.controlsNavigation = QWidget()
        self.controlsNavigation.setFixedHeight(24)
        self.controlsNavigation.setLayout(hbl)
        self.controlsNavigation.hide()

        vbl = QVBoxLayout(self)
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.treeview)
        vbl.addWidget(self.controls, alignment=Qt.AlignmentFlag.AlignLeft)
        vbl.addWidget(self.controlsNavigation, alignment=Qt.AlignmentFlag.AlignLeft)
        # vbl.setStretch(1,0)
        self.setLayout(vbl)

    def selectionChanged(self):
        cfg.selected_file = self.getSelectionPath()
        logger.info(f'Project Selection Changed! {cfg.selected_file}')
        cfg.main_window.setSelectionPathText(cfg.selected_file)

    def showSelection(self):
        logger.info('showSelection:')
        try:
            selection = self.fileSystemModel.itemData(self.treeview.selectedIndexes()[0])
            logger.info(selection)
        except:
            logger.warning('Is Any File Selected?')

    def getSelection(self):
        try:
            selection = self.fileSystemModel.itemData(self.treeview.selectedIndexes()[0])
            return selection
        except:
            logger.warning('Is Any File Selected?')

    def getSelectionPath(self):
        try:
            index = self.treeview.selectedIndexes()[0]
            info = self.treeview.model().fileInfo(index)
            path = info.absoluteFilePath()
            print(f'getSelectionPath: {path}')
            return path
        except:
            logger.warning('No Path Selected.')



    def _showHideFb(self):
        if self.treeview.isHidden():
            self.treeview.show()
            self._btn_showFileBrowser.setText('Hide Files')
        else:
            self.treeview.hide()
            self._btn_showFileBrowser.setText('File Browser')

logger = logging.getLogger("hud")
logger.propagate = False # attempt to disable propogation to the root handler

class Signaller(QObject):
    signal = Signal(str, logging.LogRecord)


class QtHandler(logging.Handler):
    def __init__(self, slotfunc, *args, **kwargs):
        super(QtHandler, self).__init__(*args, **kwargs)
        self.signaller = Signaller()
        self.signaller.signal.connect(slotfunc)

    def emit(self, record):
        s = self.format(record)
        self.signaller.signal.emit(s, record)


class HudWorker(QObject):
    @Slot()
    def start(self):
        extra = {'qThreadName': ctname()}
        logger.info('Started work', extra=extra)
        i = 1
        # Let the thread run until interrupted. This allows reasonably clean thread termination.
        while not QThread.currentThread().isInterruptionRequested():
            delay = 0.5 + random.random() * 2
            time.sleep(delay)
            level = logging.INFO
            logger.log(level, 'Message after delay of %3.1f: %d', delay, i, extra=extra)
            i += 1

class HeadupDisplay(QWidget):

    COLORS = {
        logging.DEBUG: '#F3F6FB',
        logging.INFO: '#1b1e23',
        logging.WARNING: '#8B4000',
        logging.ERROR: '#FD001B',
        logging.CRITICAL: '#decfbe',
    }

    COLORS_OVERLAY = {
        logging.DEBUG: '#F3F6FB',
        logging.INFO: '#f3f6fb',
        logging.WARNING: '#8B4000',
        logging.ERROR: '#FD001B',
        logging.CRITICAL: '#decfbe',
    }

    def __init__(self, app, overlay=False):
        super(HeadupDisplay, self).__init__()
        self.app = app
        self._overlay = overlay
        self.setFocusPolicy(Qt.NoFocus)
        # self.setMinimumHeight(64)
        self.textedit = te = QPlainTextEdit(self)
        # f = QFont()
        # f.setStyleHint(QFont.Monospace)
        # te.setFont(f)
        if overlay:
            self.textedit.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.textedit.setReadOnly(True)
        self.handler = h = QtHandler(self.update_status)
        fs = '%(asctime)s [%(levelname)s] %(message)s'
        formatter = logging.Formatter(fs, datefmt='%H:%M:%S')
        h.setFormatter(formatter)
        logger.addHandler(h)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(te)
        self.start_thread()

    def __call__(self, message, level=logging.INFO):
        logger.log(level, message)
        self.textedit.moveCursor(QTextCursor.End)

    def start_thread(self):
        self.hud_worker = HudWorker()
        self.hud_worker_thread = QThread()
        self.hud_worker.setObjectName('HudWorker')
        self.hud_worker_thread.setObjectName('AlignEMLogger')  # for qThreadName
        self.hud_worker.moveToThread(self.hud_worker_thread)
        self.hud_worker_thread.start()

    def kill_thread(self):
        self.hud_worker_thread.requestInterruption()
        if self.hud_worker_thread.isRunning():
            self.hud_worker_thread.quit()
            self.hud_worker_thread.wait()
        else:
            print('worker has already exited.')

    def force_quit(self):
        if self.hud_worker_thread.isRunning():
            self.kill_thread()

    @Slot(str, logging.LogRecord)
    def update_status(self, status, record):
        if self._overlay:
            color = self.COLORS_OVERLAY.get(record.levelno, 'black')
        else:
            color = self.COLORS.get(record.levelno, 'black')
        s = '<pre><font color="%s">%s</font></pre>' % (color, status)
        self.textedit.appendHtml(s)
        self.textedit.moveCursor(QTextCursor.End)
        self.update()

    @Slot()
    def manual_update(self):
        level = logging.INFO
        extra = {'qThreadName': ctname()}
        logger.log(level, 'Manually logged!', extra=extra)
        self.textedit.moveCursor(QTextCursor.End)
        self.update()

    @Slot()
    def post(self, message, level=logging.INFO):
        # extra = {'qThreadName': ctname()}
        # logger.log(level, message, extra=extra)
        logger.log(level, message)
        self.textedit.moveCursor(QTextCursor.End)
        self.update()

    @Slot()
    def warn(self, message):
        logger.log(logging.WARNING, message)
        self.textedit.moveCursor(QTextCursor.End)
        self.update()
import src.config as cfg

logger = logging.getLogger(__name__)

'''
cfg.project_tab.project_table.updateTableDimensions(100)
'''


class ProjectTable(QWidget):
    def __init__(self, parent):
        super().__init__(parent)
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        # self.INITIAL_ROW_HEIGHT = 128
        self.INITIAL_ROW_HEIGHT = 100
        self.data = None
        self.table = QTableWidget()
        # self.model = TableModel(data='')
        # self.table.setModel(self.model)
        self.table.verticalHeader().hide()
        self.table.setWordWrap(True)
        self.table.setSortingEnabled(True)
        self.table.setShowGrid(False)
        self.row_height_slider = Slider(self)
        self.initUI()
        self.table.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        # self.table.itemClicked.connect(self.userSelectionChanged)
        self.table.itemSelectionChanged.connect(self.selection_changed)
        # self.table.itemClicked.connect(lambda: print('itemClicked was CALLED!'))
        # self.table.itemSelectionChanged.connect(lambda: print('itemselectionChange was CALLED!')) #Works!
        # self.table.cellChanged.connect(lambda: print('cellChanged was CALLED!'))
        # self.table.itemChanged.connect(lambda: print('itemChanged was CALLED!'))

        # self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch) # Fails on TACC for some reason

        # self.updateTableDimensions(self.INITIAL_ROW_HEIGHT)
        # self.initUI()

    # def onDoubleClick(self, item=None):
    #     print(type(item))
        # userSelectionChanged
        # cfg.main_window.open_project_selected()

    def selection_changed(self):
        caller = inspect.stack()[1].function
        # logger.info(f'caller: {caller}')
        if caller != 'setScaleData':
            if cfg.project_tab._tabs.currentIndex() == 1:
                row = self.table.currentIndex().row()
                # cfg.main_window.tell('Section #%d' % row)
                cfg.data.set_layer(row)
                cfg.main_window.dataUpdateWidgets()


    def set_column_headers(self):
        if cfg.data.is_aligned():
            labels = [ 'Img\nName','Index', 'SNR', 'Img', 'Reference', 'Aligned',
                       # 'Q0', 'Q1', 'Q2', 'Q3',
                       'Top,\nLeft', 'Top,\nRight', 'Bottom,\nLeft', 'Bottom,\nRight', 'Last\nAligned',
                       'Scale', 'Skip?', 'Method', 'SNR Report']
        else:
            labels = [ 'Img\nName','Index','Img', 'Reference', 'Scale', 'Skip?', 'Method' ]
        self.table.setHorizontalHeaderLabels(labels)
        self.table.setColumnCount(len(labels))

    def setScaleRowData(self):
        pass


    def setScaleData(self):
        t = time.time()
        caller = inspect.stack()[1].function
        logger.info('Setting Table Data (caller: %s)...' % caller)
        cur_selection = self.table.currentIndex().row()
        cur_scroll_pos = self.table.verticalScrollBar().value()
        self.setUpdatesEnabled(False)
        self.table.clearContents()
        self.table.clear()
        self.table.setRowCount(0)
        self.set_column_headers() #Critical
        try:
            self.get_data()
        except:
            print_exception()
        try:
            if cfg.data.is_aligned_and_generated():
                for i, row in enumerate(self.data):
                    # logger.info('Inserting row %d' % i)
                    self.table.insertRow(i)
                    snr_4x = cfg.data.snr_components(l=i)
                    for j, item in enumerate(row):
                        if j == 0:
                            # item = '<h4>' + item + '</h4>'
                            # lab = QLabel('\n'.join(textwrap.wrap(item, 20)))
                            # lab.setWordWrap(True)
                            # self.table.setCellWidget(i, j, lab)
                            self.table.setItem(i, j, QTableWidgetItem('\n'.join(textwrap.wrap(str(item), 20))))
                        elif j == 1:
                            # item = '<h3>' + str(item).zfill(5) + '</h3>'
                            # lab = QLabel('\n'.join(textwrap.wrap(item, 20)))
                            # self.table.setCellWidget(i, j, lab)
                            self.table.setItem(i, j, QTableWidgetItem('\n'.join(textwrap.wrap(str(item), 20))))
                        elif j == 2:
                            # item = '<h3>' + ('%.3f' % item).zfill(5) + '</h3>'
                            # lab = QLabel('\n'.join(textwrap.wrap(item, 20)))
                            # self.table.setCellWidget(i, j, lab)
                            self.table.setItem(i, j, QTableWidgetItem('\n'.join(textwrap.wrap(str(item), 20))))
                        elif j in (3, 4):
                            # tn = Thumbnail(self, path=item)
                            tn = ThumbnailFast(self, path=item)
                            self.table.setCellWidget(i, j, tn)
                        elif j == 5:
                            # tn = Thumbnail(self, path=item)
                            # tn = ThumbnailFast(self, path=item, extra=cfg.data.datetime(l=i))
                            tn = ThumbnailFast(self, path=item)
                            self.table.setCellWidget(i, j, tn)
                        elif j in (6, 7, 8, 9):
                            # logger.info(f'j={j}, item={str(item)}')
                            try:
                                # tn = SnrThumbnail(self, path=item, snr=snr_4x[j - 6])
                                tn = CorrSignalThumbnail(self, path=item, snr=snr_4x[j - 6])
                                self.table.setCellWidget(i, j, tn)
                            except:
                                tn = CorrSignalThumbnail(self)
                                tn.set_no_image()
                                self.table.setCellWidget(i, j, tn)
                        else:
                            self.table.setItem(i, j, QTableWidgetItem(str(item)))
            else:
                for i, row in enumerate(self.data):
                    self.table.insertRow(i)
                    for j, item in enumerate(row):
                        if j == 0:
                            # item = '<h4>' + item + '</h4>'
                            # lab = QLabel('\n'.join(textwrap.wrap(item, 20)))
                            # lab.setWordWrap(True)
                            # self.table.setCellWidget(i, j, lab)
                            self.table.setItem(i, j, QTableWidgetItem('\n'.join(textwrap.wrap(str(item), 20))))
                        elif j == 1:
                            # item = '<h3>' + str(item).zfill(5) + '</h3>'
                            # lab = QLabel('\n'.join(textwrap.wrap(item, 20)))
                            # self.table.setCellWidget(i, j, lab)
                            self.table.setItem(i, j, QTableWidgetItem('\n'.join(textwrap.wrap(str(item), 20))))
                        elif j in (2, 3):
                            # thumbnail = Thumbnail(self, path=item)
                            thumbnail = ThumbnailFast(self, path=item)
                            self.table.setCellWidget(i, j, thumbnail)
                        else:
                            self.table.setItem(i, j, QTableWidgetItem(str(item)))
        except:
            print_exception()
        finally:
            self.setUpdatesEnabled(True)
            self.setColumnWidths()
            self.updateTableDimensions(self.INITIAL_ROW_HEIGHT)
            self.set_column_headers()

            if cur_selection != -1:
                self.table.selectRow(cur_selection)
            self.table.verticalScrollBar().setValue(cur_scroll_pos)
            # logger.info(f'cur_selection={cur_selection}, cur_scroll_pos={cur_scroll_pos}')
            # cur_selection = self.table.currentIndex().row()
            self.table.update()

            dt = time.time() - t
            logger.info('Table Load Time %s' %str(dt))


    def setColumnWidths(self):
        if cfg.data.is_aligned_and_generated():
            self.table.setColumnWidth(0, 128)  # 0 index
            self.table.setColumnWidth(1, 60)   # 1 Filename
            self.table.setColumnWidth(2, 60)   # 2 SNR
            self.table.setColumnWidth(3, 100)  # 3 Current
            self.table.setColumnWidth(4, 100)  # 4 Reference
            self.table.setColumnWidth(5, 100)  # 5 Aligned
            self.table.setColumnWidth(6, 100)  # 6 Q0
            self.table.setColumnWidth(7, 100)  # 7 Q1
            self.table.setColumnWidth(8, 100)  # 8 Q2
            self.table.setColumnWidth(9, 100) # 9 Q3
            self.table.setColumnWidth(10, 80) # 10 Last Aligned datetime
            self.table.setColumnWidth(11, 50) # 11 Scale
            self.table.setColumnWidth(12, 50)  # 12 Skip
            self.table.setColumnWidth(13, 120)  # 13 Method
            self.table.setColumnWidth(14, 120) # 14 SNR_report
        else:
            self.table.setColumnWidth(0, 128)
            self.table.setColumnWidth(1, 60)
            self.table.setColumnWidth(2, 100)
            self.table.setColumnWidth(3, 100)
            self.table.setColumnWidth(4, 50)
            self.table.setColumnWidth(5, 50)
            self.table.setColumnWidth(6, 80)

    def updateTableDimensions(self, h):
        # logger.info(f'Updating table dimensions...')
        # logger.info('')
        parentVerticalHeader = self.table.verticalHeader()
        for section in range(parentVerticalHeader.count()):
            parentVerticalHeader.resizeSection(section, h)

        if cfg.data.is_aligned_and_generated():
            self.table.setColumnWidth(3, h)
            self.table.setColumnWidth(4, h)
            self.table.setColumnWidth(5, h)
            self.table.setColumnWidth(6, h)
            self.table.setColumnWidth(7, h)
            self.table.setColumnWidth(8, h)
            self.table.setColumnWidth(9, h)
        else:
            self.table.setColumnWidth(2, h)
            self.table.setColumnWidth(3, h)


    def get_data(self):
        # logger.info('')
        is_aligned = cfg.data.is_aligned_and_generated()
        # logger.critical('is aligned? %r' % is_aligned)
        try:
            try:     scale = [cfg.data.scale_pretty()] * cfg.data.nSections
            except:  scale = ['Unknown'] * cfg.data.nSections; print_exception()
            try:     ref = cfg.data.thumbnails_ref()
            except:  ref = ['Unknown'] * cfg.data.nSections; print_exception()
            indexes, skips, base, method, snr_report, test, datetime = [], [], [], [], [], [], []
            for i, l in enumerate(cfg.data.alstack()):
                indexes.append(i)
                try:     skips.append(l['skipped'])
                except:  skips.append('?'); print_exception()
                try:
                    m = l['alignment']['selected_method']
                    if m == 'Auto-SWIM': m = 'Automatic SWIM Alignment'
                    method.append(m)
                except:
                    method.append('Unknown')
                if is_aligned:
                    try:     snr_report.append(l['alignment']['method_results']['snr_report'])
                    except:  snr_report.append('<No SNR Report>')
                    try:     datetime.append(l['alignment']['method_results']['datetime'])
                    except:  datetime.append('N/A')


            if is_aligned:
                self.data = list(zip(cfg.data.basefilenames(), indexes, cfg.data.snr_list(),
                                  cfg.data.thumbnails(), ref, cfg.data.thumbnails_aligned(),
                                  cfg.data.corr_spots_q0(), cfg.data.corr_spots_q1(),
                                  cfg.data.corr_spots_q2(), cfg.data.corr_spots_q3(), datetime,
                                  scale, skips, method, snr_report))
            else:
                self.data = list(zip(cfg.data.basefilenames(), indexes, cfg.data.thumbnails(),
                                  ref, scale, skips, method))
            # print(str(list(zipped)))
            # return self.data
        except:
            print_exception()


    # def updateSliderMaxVal(self):
    #     if cfg.data.is_aligned():
    #         thumb_path = os.path.join(cfg.data.dest(), cfg.data.scale(), 'thumbnails_aligned')
    #     else:
    #         thumb_path = os.path.join(cfg.data.dest(), 'thumbnails')
    #     max_val = max(ImageSize(next(absFilePaths(thumb_path))))
    #     # self.row_height_slider.setMaximum(max_val)


    def initUI(self):
        logger.info('Initializing Table UI...')

        self.table.setStyleSheet('font-size: 10px;')
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.SingleSelection)
        # self.project_table.verticalHeader().setVisible(False)
        self.table.verticalHeader().setTextElideMode(Qt.ElideMiddle)
        self.table.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
        self.row_height_slider.setValue(self.INITIAL_ROW_HEIGHT)
        self.row_height_slider.valueChanged.connect(self.updateTableDimensions)
        self.row_height_slider.setMaximumWidth(128)

        # self.row_height_slider.valueChanged.connect(self.updateFontSize)
        # self.row_height_widget = QWidget()
        # self.thumbnailPixelsLabel = QLabel()
        # self.row_height_hlayout = QHBoxLayout()
        # self.row_height_hlayout.setContentsMargins(2, 2, 2, 2)
        # self.row_height_hlayout.addWidget(QLabel('Thumbnail Size:'))
        # self.row_height_hlayout.addWidget(self.row_height_slider, alignment=Qt.AlignmentFlag.AlignLeft)
        # self.row_height_hlayout.addWidget(self.thumbnailPixelsLabel, alignment=Qt.AlignmentFlag.AlignLeft)
        # self.row_height_widget.setLayout(self.row_height_hlayout)

        logger.info('Initializing Table Controls...')

        self.controls = QWidget()
        self.controls.setObjectName('controls')
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.row_height_slider, alignment=Qt.AlignLeft)
        # self.controls_hlayout.addWidget(self.font_size_widget)
        hbl.addStretch()
        self.controls.setLayout(hbl)

        logger.info('Initializing Table Layout...')

        layout =QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(self.table)
        layout.addWidget(self.controls)

        self.setLayout(layout)
#
#
# class SnrThumbnail(QWidget):
#
#     def __init__(self, parent, path, snr='<SNR>'):
#         super().__init__(parent)
#         # thumbnail = QLabel(self)
#         thumbnail = ScaledPixmapLabel(self)
#         try:
#             pixmap = QPixmap(path)
#             thumbnail.setPixmap(pixmap)
#             thumbnail.setScaledContents(True)
#             snr = QLabel(snr)
#             snr.setStyleSheet('color: #ff0000')
#         except:
#             snr = QLabel('<h5>' + str(snr) + '</h5>')
#             snr.setStyleSheet('background-color: #141414')
#             print_exception()
#             logger.warning(f'WARNING path={path}, snr={snr}')
#         layout = QGridLayout()
#         layout.setContentsMargins(1, 1, 1, 1)
#         layout.addWidget(thumbnail, 0, 0)
#         layout.addWidget(snr, 0, 0, alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignBottom)
#         self.setLayout(layout)
#
#
# class Thumbnail(QWidget):
#
#     def __init__(self, parent, path):
#         super().__init__(parent)
#         self.thumbnail = ScaledPixmapLabel(self)
#         self.pixmap = QPixmap(path)
#         self.thumbnail.setPixmap(self.pixmap)
#         self.thumbnail.setScaledContents(True)
#         self.layout = QGridLayout()
#         self.layout.setContentsMargins(1, 1, 1, 1)
#         self.layout.addWidget(self.thumbnail, 0, 0)
#         self.setLayout(self.layout)
#
#
# class ScaledPixmapLabel(QLabel):
#     def __init__(self, parent):
#         super().__init__(parent)
#         self.setScaledContents(True)
#
#     def paintEvent(self, event):
#         if self.pixmap():
#             pm = self.pixmap()
#             try:
#                 originalRatio = pm.width() / pm.height()
#                 currentRatio = self.width() / self.height()
#                 if originalRatio != currentRatio:
#                     qp = QPainter(self)
#                     pm = self.pixmap().scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
#                     rect = QRect(0, 0, pm.width(), pm.height())
#                     rect.moveCenter(self.rect().center())
#                     qp.drawPixmap(rect, pm)
#                     return
#             except ZeroDivisionError:
#                 # logger.warning('Cannot divide by zero')
#                 # print_exception()
#                 pass
#         super().paintEvent(event)


class Slider(QSlider):
    def __init__(self, parent):
        super().__init__(parent)
        self.setOrientation(Qt.Horizontal)
        self.setMinimum(16)
        self.setMaximum(512)
        self.setSingleStep(1)
        self.setPageStep(2)
        self.setTickInterval(1)





# class ThumbnailDelegate(QStyledItemDelegate):
#
#     def paint(self, painter, option, index):
#         data = index.model().data(index, Qt.DisplayRole)
#         if data is None:
#             return
#         thumbnail = QImage(data)
#         width = option.rect.width()
#         height = option.rect.height()
#         scaled = thumbnail.scaled(width, height, aspectRatioMode=Qt.KeepAspectRatio)
#         painter.drawImage(option.rect.x(), option.rect.y(), scaled)

# class CorrSpotDelegate(QStyledItemDelegate):
#
#     def paint(self, painter, option, index):
#
#         data = index.model().data(index, Qt.DisplayRole)
#         if data is None:
#             return
#
#         cfg.a = index.model().data
#         cfg.b = index.model().itemData
#         cfg.i = index
#         # cfg.i.data()  # !!! This gives the path
#         cfg.d = data
#         thumbnail = QImage(data)
#         width = option.rect.width()
#         height = option.rect.height()
#         scaled = thumbnail.scaled(width, height, aspectRatioMode=Qt.KeepAspectRatio)
#         painter.drawImage(option.rect.x(), option.rect.y(), scaled)
#         painter.setPen(QColor('#FF0000'))
#         if cfg.data.is_aligned_and_generated():
#             painter.drawText(option.rect.x(), option.rect.y() - 5, '<SNR>')


class TableModel(QAbstractTableModel):
    def __init__(self, data):
        super().__init__()
        self._data = data

    def data(self, index, role):
        if role == Qt.DisplayRole:
            return self._data[index.row()][index.column()]

    def rowCount(self, parent=None):
        return len(self._data)

    def columnCount(self, parent=None):
        return len(self._data[0])
class PythonConsole(RichJupyterWidget):

    def __init__(self, customBanner=None, *args, **kwargs):
        super(PythonConsole, self).__init__(*args, **kwargs)
        self.set_default_style(colors='nocolor')
        self.prompt_to_top()

        if customBanner is not None:
            self.banner = customBanner

        self.kernel_manager = QtInProcessKernelManager()
        self.kernel_manager.start_kernel(show_banner=False)
        self.kernel_manager.kernel.gui = 'qt'
        self.kernel_client = self._kernel_manager.client()
        self.kernel_client.start_channels()
        self.setFocusPolicy(Qt.NoFocus)
        # if not is_tacc():
        if 1:
            self.execute_command('import src.config as cfg')
            self.execute_command('from src.config import main_window')
            self.execute_command('import src.helpers')
            self.execute_command('from src.helpers import find_allocated_widgets, count_widgets, obj_to_string')
            self.execute_command('import os, sys, copy, json, stat')
            self.execute_command('import zarr')
            self.execute_command('import neuroglancer as ng')
            self.execute_command('from qtpy.QtCore import QUrl, Qt')
            self.execute_command('from qtpy import QtCore, QtGui, QtWidgets')
            self.execute_command('from qtpy.QtWidgets import *')
            self.execute_command('from qtpy.QtCore import *')
            self.execute_command('from qtpy.QtGui import *')
            self.execute('clear')
            # self.out_prompt = 'AlignEM [<span class="out-prompt-number">%i</span>]: '

            import IPython; IPython.get_ipython().execution_count = 0
            self.print_text('AlignEM [<span class="out-prompt-number">%i</span>]: ')

        def stop():
            self.kernel_client.stop_channels()
            self.kernel_manager.shutdown_kernel()
            # guisupport.get_app_qt().exit()

        self.exit_requested.connect(stop)

    def push_vars(self, variableDict):
        """Push dictionary variables to the Jupyter console widget"""
        self.kernel_manager.kernel.shell.push(variableDict)

    def clear(self):
        """Clears the terminal"""
        self._control.clear()
        # self.kernel_manager

    def print_text(self, text):
        """Print to the console"""
        self._append_plain_text(text)

    def execute_command(self, command):
        """Execute a command in the frame of the console widget"""
        self._execute(command, False)

    def set_color_none(self):
        """Set no color scheme"""
        self.set_default_style(colors='nocolor')

    def set_color_linux(self):
        """Set linux color scheme"""
        self.set_default_style(colors='linux')

    def sizeHint(self):
        return QSize(200, 100)
logger = logging.getLogger(__name__)

class DoubleSlider(QSlider):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.decimals = 5
        self._max_int = 10 ** self.decimals

        super().setMinimum(0)
        super().setMaximum(self._max_int)

        self._min_value = 0.0
        self._max_value = 1.0

    @property
    def _value_range(self):
        return self._max_value - self._min_value

    def value(self):
        return float(super().value()) / self._max_int * self._value_range + self._min_value

    def setValue(self, value):
        super().setValue(int((value - self._min_value) / self._value_range * self._max_int))

    def setMinimum(self, value):
        if value > self._max_value:
            raise ValueError("Minimum limit cannot be higher than maximum")

        self._min_value = value
        self.setValue(self.value())

    def setMaximum(self, value):
        if value < self._min_value:
            raise ValueError("Minimum limit cannot be higher than maximum")

        self._max_value = value
        self.setValue(self.value())

    def minimum(self):
        return self._min_value

    def maximum(self):
        return self._max_value


'''Source:
https://stackoverflow.com/questions/47342158/porting-range-slider-widget-to-pyqt5'''

DEFAULT_CSS = """
RangeSlider * { border: 0px; padding: 0px; font-size: 7px; }
RangeSlider #Head { background: #ffffff; }
RangeSlider #Tail { background: #f3f6fb; }
RangeSlider #Span { background: #daebfe; }
RangeSlider #Span:active { background: #daebfe; }
RangeSlider > QSplitter::handle { background: #1b1e23; }
RangeSlider > QSplitter::handle:vertical { height: 4px; }
RangeSlider > QSplitter::handle:pressed { background: #969696; }
"""

def scale(val, src, dst):
    try:
        return int(((val - src[0]) / float(src[1]-src[0])) * (dst[1]-dst[0]) + dst[0])
    except ZeroDivisionError:
        logger.warning('cannot divide by 0')


class Ui_Form(object):
    def setupUi(self, Form):
        Form.setObjectName("RangeSlider")
        Form.resize(300, 30)
        Form.setStyleSheet(DEFAULT_CSS)
        self.gridLayout = QtWidgets.QGridLayout(Form)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setSpacing(0)
        self.gridLayout.setObjectName("gridLayout")
        self._splitter = QtWidgets.QSplitter(Form)
        self._splitter.setMinimumSize(QtCore.QSize(0, 0))
        self._splitter.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self._splitter.setOrientation(QtCore.Qt.Horizontal)
        self._splitter.setObjectName("splitter")
        self._head = QtWidgets.QGroupBox(self._splitter)
        self._head.setTitle("")
        self._head.setObjectName("Head")
        self._handle = QtWidgets.QGroupBox(self._splitter)
        self._handle.setTitle("")
        self._handle.setObjectName("Span")
        self._tail = QtWidgets.QGroupBox(self._splitter)
        self._tail.setTitle("")
        self._tail.setObjectName("Tail")
        self.gridLayout.addWidget(self._splitter, 0, 0, 1, 1)
        self.retranslateUi(Form)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("RangeSlider", "RangeSlider"))


class Element(QtWidgets.QGroupBox):
    def __init__(self, parent, main):
        super(Element, self).__init__(parent)
        self.main = main

    def setStyleSheet(self, style):
        self.parent().setStyleSheet(style)

    def textColor(self):
        return getattr(self, '__textColor', QtGui.QColor('#969696'))

    def setTextColor(self, color):
        if type(color) == tuple and len(color) == 3:
            color = QtGui.QColor(color[0], color[1], color[2])
        elif type(color) == int:
            color = QtGui.QColor(color, color, color)
        setattr(self, '__textColor', color)

    def paintEvent(self, event):
        qp = QtGui.QPainter()
        qp.begin(self)
        if self.main.drawValues():
            self.drawText(event, qp)
        qp.end()


class Head(Element):
    def __init__(self, parent, main):
        super(Head, self).__init__(parent, main)

    def drawText(self, event, qp):
        qp.setPen(self.textColor())
        qp.setFont(QtGui.QFont('Arial', 10))
        qp.drawText(event.rect(), QtCore.Qt.AlignLeft | QtCore.Qt.AlignBottom, str(self.main.min()))


class Tail(Element):
    def __init__(self, parent, main):
        super(Tail, self).__init__(parent, main)

    def drawText(self, event, qp):
        qp.setPen(self.textColor())
        qp.setFont(QtGui.QFont('Arial', 10))
        qp.drawText(event.rect(), QtCore.Qt.AlignRight | QtCore.Qt.AlignBottom, str(self.main.max()))


class Handle(Element):
    def __init__(self, parent, main):
        super(Handle, self).__init__(parent, main)

    def drawText(self, event, qp):
        qp.setPen(self.textColor())
        qp.setFont(QtGui.QFont('Arial', 10))
        qp.drawText(event.rect(), QtCore.Qt.AlignLeft  | QtCore.Qt.AlignTop, str(self.main.start()))
        qp.drawText(event.rect(), QtCore.Qt.AlignRight  | QtCore.Qt.AlignBottom, str(self.main.end()))

    def mouseMoveEvent(self, event):
        event.accept()
        mx = event.globalX()
        _mx = getattr(self, '__mx', None)
        if not _mx:
            setattr(self, '__mx', mx)
            dx = 0
        else:
            dx = mx - _mx
        setattr(self, '__mx', mx)
        if dx == 0:
            event.ignore()
            return
        elif dx > 0:
            dx = 1
        elif dx < 0:
            dx = -1
        s = self.main.start() + dx
        e = self.main.end() + dx
        if s >= self.main.min() and e <= self.main.max():
            self.main.setRange(s, e)


class RangeSlider(QtWidgets.QWidget, Ui_Form):
    endValueChanged = QtCore.Signal(int)
    maxValueChanged = QtCore.Signal(int)
    minValueChanged = QtCore.Signal(int)
    startValueChanged = QtCore.Signal(int)

    _SPLIT_START = 1
    _SPLIT_END = 2

    def __init__(self, parent=None):
        super(RangeSlider, self).__init__(parent)
        self.setupUi(self)
        self.setMouseTracking(False)
        self._splitter.splitterMoved.connect(self._handleMoveSplitter)
        self._head_layout = QtWidgets.QHBoxLayout()
        self._head_layout.setSpacing(0)
        self._head_layout.setContentsMargins(0, 0, 0, 0)
        self._head.setLayout(self._head_layout)
        self.head = Head(self._head, main=self)
        self._head_layout.addWidget(self.head)
        self._handle_layout = QtWidgets.QHBoxLayout()
        self._handle_layout.setSpacing(0)
        self._handle_layout.setContentsMargins(0, 0, 0, 0)
        self._handle.setLayout(self._handle_layout)
        self.handle = Handle(self._handle, main=self)
        # self.handle.setTextColor(QtGui.QColor('#1b1e23'))
        self.handle.setTextColor(QtGui.QColor('#f3f6fb'))
        self._handle_layout.addWidget(self.handle)
        self._tail_layout = QtWidgets.QHBoxLayout()
        self._tail_layout.setSpacing(0)
        self._tail_layout.setContentsMargins(0, 0, 0, 0)
        self._tail.setLayout(self._tail_layout)
        self.tail = Tail(self._tail, main=self)
        self._tail_layout.addWidget(self.tail)
        self.setMin(0)
        self.setMax(99)
        self.setStart(0)
        self.setEnd(99)
        self.setDrawValues(True)

    def min(self):
        return getattr(self, '__min', None)

    def max(self):
        return getattr(self, '__max', None)

    def setMin(self, value):
        setattr(self, '__min', value)
        self.minValueChanged.emit(value)

    def setMax(self, value):
        setattr(self, '__max', value)
        self.maxValueChanged.emit(value)

    def start(self):
        return getattr(self, '__start', None)

    def end(self):
        return getattr(self, '__end', None)

    def _setStart(self, value):
        setattr(self, '__start', value)
        self.startValueChanged.emit(value)

    def setStart(self, value):
        v = self._valueToPos(value)
        self._splitter.splitterMoved.disconnect()
        self._splitter.moveSplitter(v, self._SPLIT_START)
        self._splitter.splitterMoved.connect(self._handleMoveSplitter)
        self._setStart(value)

    def _setEnd(self, value):
        setattr(self, '__end', value)
        self.endValueChanged.emit(value)

    def setEnd(self, value):
        v = self._valueToPos(value)
        self._splitter.splitterMoved.disconnect()
        self._splitter.moveSplitter(v, self._SPLIT_END)
        self._splitter.splitterMoved.connect(self._handleMoveSplitter)
        self._setEnd(value)

    def drawValues(self):
        return getattr(self, '__drawValues', None)

    def setDrawValues(self, draw):
        setattr(self, '__drawValues', draw)

    def getRange(self):
        return (self.start(), self.end())

    def setRange(self, start, end):
        self.setStart(start)
        self.setEnd(end)

    def keyPressEvent(self, event):
        key = event.key()
        if key == QtCore.Qt.Key_Left:
            s = self.start()-1
            e = self.end()-1
        elif key == QtCore.Qt.Key_Right:
            s = self.start()+1
            e = self.end()+1
        else:
            event.ignore()
            return
        event.accept()
        if s >= self.min() and e <= self.max():
            self.setRange(s, e)

    def setBackgroundStyle(self, style):
        self._tail.setStyleSheet(style)
        self._head.setStyleSheet(style)

    def setSpanStyle(self, style):
        self._handle.setStyleSheet(style)

    def _valueToPos(self, value):
        return scale(value, (self.min(), self.max()), (0, self.width()))

    def _posToValue(self, xpos):
        return scale(xpos, (0, self.width()), (self.min(), self.max()))

    def _handleMoveSplitter(self, xpos, index):
        hw = self._splitter.handleWidth()
        def _lockWidth(widget):
            width = widget.size().width()
            widget.setMinimumWidth(width)
            widget.setMaximumWidth(width)
        def _unlockWidth(widget):
            widget.setMinimumWidth(0)
            widget.setMaximumWidth(16777215)
        # v = self._posToValue(xpos)
        if index == 1:
            v = self._posToValue(xpos)
        elif index == 2:
            v = self._posToValue(xpos + hw)

        if index == self._SPLIT_START:
            _lockWidth(self._tail)
            if v >= self.end():
                return
            offset = -20
            w = xpos + offset
            self._setStart(v)
        elif index == self._SPLIT_END:
            _lockWidth(self._head)
            if v <= self.start():
                return
            offset = -40
            w = self.width() - xpos + offset
            self._setEnd(v)
        _unlockWidth(self._tail)
        _unlockWidth(self._head)
        _unlockWidth(self._handle)
logger = logging.getLogger(__name__)


class SnrPlot(QWidget):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # cfg.data = None
        self.app = pg.mkQApp()
        self.view = pg.GraphicsLayoutWidget()
        # self.view.setBackground('#ffffff')
        self.view.setBackground('#1b1e23')

        # drafting_blue = '#004060'
        # self.view.setBackground(drafting_blue)
        pg.setConfigOption('foreground', '#f3f6fb')


        pg.setConfigOptions(antialias=True)
        self.plot = self.view.addPlot()
        # self.vb = CustomViewBox()
        # self.snr =
        # self.label_value = pg.InfLineLabel('test', **{'color': '#FFF'})
        self._curLayerLine = pg.InfiniteLine(
            movable=False,
            angle=90,
            label='Section #{value:.0f}',
            # snr=self.label_value,
            labelOpts={'position': .1, 'color': (200, 200, 100), 'fill': (200, 200, 200, 50), 'movable': True})
        # self._snr_label = pg.InfLineLabel(self._curLayerLine, '', position=0.95, rotateAxis=(1, 0),
        #                                  anchor=(1, 1))
        self._snr_label = pg.InfLineLabel(self._curLayerLine, '', position=0.92, anchor=(1, 1), color='#f3f6fb')
        self._mp_lines = []
        self._mp_labels = []
        self._skip_lines = []
        self._skip_labels = []
        self._error_bars = {}
        f = QFont()
        f.setBold(True)
        f.setPointSize(12)
        self._snr_label.setFont(f)
        self.plot.addItem(self._curLayerLine)
        # self.spw = pg.ScatterPlotWidget() #Todo switch to scatter plot widget for greater interactivity
        # pg.setConfigOptions(antialias=True)
        self._plot_colors = ['#FEFE62', '#40B0A6', '#D41159',
                             '#E66100', '#1AFF1A', '#FFC20A',
                             '#66FF00', '#8c001a', '#08E8DE',
                             '#56768e', '#2CBFF7', '#c7b286',
                             '#FF007F', '#376d58', '#f46c60',
                             '#c9cbd0', '#fbd771', '#ff9a00'
                             ]

        self._plot_brushes = [pg.mkBrush(c) for c in self._plot_colors]

        # self.plot.scene().sigMouseClicked.connect(self.mouse_clicked)

        # self.plot.setAspectLocked(True)
        self.plot.showGrid(x=False, y=True, alpha=120)  # alpha: 0-255
        # self.plot.getPlotItem().enableAutoRange()
        self.plot.hoverable = True
        self.plot.hoverSize = 15
        # self.plot.setFocusPolicy(Qt.NoFocus)
        # font = QFont()
        # font.setPixelSize(14)
        # self.plot.getAxis("bottom").tickFont = font
        # self.plot.getAxis("bottom").setStyle(tickFont=font)
        # self.plot.getAxis("left").setStyle(tickFont=font)
        # self.plot.getAxis("bottom").setHeight(12)
        # self.plot.getAxis("left").setWidth(12)
        self.plot.getAxis("left").setStyle(tickTextOffset=4)
        # style = {'color': '#f3f6fb;', 'font-size': '14px'}

        self.plot.setCursor(Qt.CrossCursor)
        # self.plot.setAspectLocked()

        self.snr_points = {}
        self.snr_errors = {}
        self.selected_scale = None

        self.checkboxes_widget = QWidget()
        self.checkboxes_hlayout = QHBoxLayout()
        self.checkboxes_hlayout.setContentsMargins(0, 0, 0, 0)
        self.checkboxes_widget.setLayout(self.checkboxes_hlayout)

        self.layout = QGridLayout()
        self.layout.addWidget(self.view, 0, 0, 0, 0)
        self.layout.addWidget(self.checkboxes_widget, 0, 0, 0, 0, alignment=Qt.AlignmentFlag.AlignRight)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.setLayout(self.layout)

        self.plot.scene().sigMouseClicked.connect(self.mouse_clicked)



    def updateLayerLinePos(self):
        caller = inspect.stack()[1].function
        # logger.info(f'caller={caller}')
        if cfg.data:
            offset = self._getScaleOffset(s=cfg.data.scale())
            pos = [cfg.data.layer() + offset, 1]
            # logger.info(f'pos = {pos}')
            self._curLayerLine.setPos(pos)
            # snr = pg.InfLineLabel(self._curLayerLine, "region 1", position=0.95, rotateAxis=(1, 0), anchor=(1, 1))
            lab = 'SNR: %.2f\n%s' % (cfg.data.snr(), cfg.data.scale_pretty())
            # logger.info(f'lab = {lab}')
            self._snr_label.setText(lab)
        else:
            logger.warning(f'Cant update layer line caller={caller}')



    def updateSpecialLayerLines(self):
        logger.debug('')
        offset = self._getScaleOffset(s=cfg.data.scale())
        layers_mp = cfg.data.find_layers_with_matchpoints()
        for line in self._mp_lines:   self.plot.removeItem(line)
        for label in self._mp_labels: self.plot.removeItem(label)
        self._mp_lines = []
        self._mp_labels = []
        for layer in layers_mp:
            line = pg.InfiniteLine(
                movable=False,
                angle=90,
                pen='#32CD32',
                # snr='Match Point #{value:.0f}',
                # # snr=self.label_value,
                labelOpts={'position': .1, 'color': (255, 225, 53), 'fill': (200, 200, 200, 50), 'movable': True}
            )
            self._mp_lines.append(line)
            label = pg.InfLineLabel(line, f'Match Point', position=0.32, color='#32CD32',rotateAxis=(1, 0), anchor=(1, 1))
            self._mp_labels.append(label)
            line.setPos([layer[0] + offset, 1])
            self.plot.addItem(line)

        for line in self._skip_lines:   self.plot.removeItem(line)
        for label in self._skip_labels: self.plot.removeItem(label)

        self._skip_lines = []
        self._skip_labels = []

        for layer in cfg.data.skips_list():
            line = pg.InfiniteLine(
                movable=False,
                angle=90,
                pen='#ff0000',
                # snr='Skip #{value:.0f}',
                # # snr=self.label_value,
                labelOpts={'position': .1, 'color': (255,250,250), 'fill': (255, 0, 0, 75), 'movable': True}
            )
            self._skip_lines.append(line)
            label = pg.InfLineLabel(line, f'Skip', position=0.08, color='#ff0000', rotateAxis=(1, 0), anchor=(1, 1))
            self._skip_labels.append(label)
            line.setPos([layer[0] + offset, 1])
            self.plot.addItem(line)

        # for scale in cfg.data.scalesAlignedAndGenerated:
        #     self.updateErrBars(s=scale)





    def callableFunction(x, y):
        return str(cfg.data.snr())
        # logger.info()
        # return f"Square Values: ({x ** 2:.4f}, {y ** 2:.4f})"


    def initSnrPlot(self, s=None):
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        if not cfg.data:
            logger.warning(f'initSnrPlot was called by {inspect.stack()[1].function} but data does not exist.')
            return
        try:
            if caller != 'initUI_plot':
                self.wipePlot()

            n_aligned = 0
            for s in cfg.data.scales():
                if cfg.data.is_aligned(s=s):
                    n_aligned += 1
            if n_aligned == 0:
                logger.info('0 scales are aligned, Nothing to Plot - Returning')
                return

            self._snr_checkboxes = dict()

            for i in reversed(range(self.checkboxes_hlayout.count())):
                self.checkboxes_hlayout.itemAt(i).widget().setParent(None)

            for i, s in enumerate(cfg.data.scales()):
                if cfg.data.is_aligned(s=s):
                    self._snr_checkboxes[s] = QCheckBox()
                    self._snr_checkboxes[s].setText(cfg.data.scale_pretty(s=s))
                    self.checkboxes_hlayout.addWidget(self._snr_checkboxes[s],
                                                      alignment=Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignTop)
                    self._snr_checkboxes[s].setChecked(True)
                    self._snr_checkboxes[s].clicked.connect(self.plotData)
                    self._snr_checkboxes[s].setStatusTip('On/Off SNR Plot %s' % cfg.data.scale_pretty(s=s))
                    color = self._plot_colors[cfg.data.scales()[::-1].index(s)]
                    self._snr_checkboxes[s].setStyleSheet(
                        f'background-color: #F3F6FB;'
                        f'border-color: {color}; '
                        f'border-width: 3px; '
                        f'border-style: outset;')
                # if cfg.data.is_aligned(s=s):
                #     self._snr_checkboxes[s].show()
                # else:
                #     self._snr_checkboxes[s].hide()

            # self.checkboxes_hlayout.addStretch()

            self.updateLayerLinePos()
            styles = {'color': '#f3f6fb', 'font-size': '14px', 'font-weight': 'bold'}
            # cfg.project_tab.snr_plot.plot.setTitle(cfg.data.base_image_name())
            self.plot.setLabel('top', cfg.data.base_image_name(), **styles)
        except:
            print_exception()
        try:
            self.plotData()
        except:
            print_exception()


    def get_axis_data(self, s=None) -> tuple:
        if s == None: s = cfg.data.curScale
        x_axis, y_axis = [], []
        for layer, snr in enumerate(cfg.data.snr_list(s=s)):
            if cfg.data.skipped(s=s, l=layer):
                x_axis.append(layer)
                y_axis.append(0)
            else:
                x_axis.append(layer)
                y_axis.append(snr)
        return x_axis, y_axis


    def plotData(self):
        '''Update SNR plot widget based on checked/unchecked state of checkboxes'''
        caller = inspect.stack()[1].function
        logger.debug(f'caller: {caller}')
        if cfg.data:
            self.plot.clear()
            self.plot.addItem(self._curLayerLine)
            for s in cfg.data.scales()[::-1]:
                if cfg.data.is_aligned(s=s):
                    if self._snr_checkboxes[s].isChecked():
                        self.plotSingleScale(s=s)
            max_snr = cfg.data.snr_max_all_scales()
            if not max_snr:
                logger.warning('No max SNR, Nothing to plot - Returning')
                return
            xmax = cfg.data.nSections + 1
            ymax = ceil(max_snr) + 5
            self.plot.setLimits(
                minXRange=1,
                xMin=0,
                xMax=xmax,
                maxXRange=xmax,
                yMin=0,
                yMax=ymax,
                minYRange=ymax,
                maxYRange=ymax,
            )
            ax = self.plot.getAxis('bottom')  # This is the trick
            dx = [(value, str(value)) for value in list((range(0, xmax - 1)))]
            ax.setTicks([dx, []])

            self.updateSpecialLayerLines()
            self.plot.autoRange() # !!!

    def _getScaleOffset(self, s):
        return cfg.data.scales()[::-1].index(s) * (.5/len(cfg.data.scales()))


    def plotSingleScale(self, s=None):
        logger.info(f'plotSingleScale (scale: {s}):')
        if s == None: scale = cfg.data.scale()
        x_axis, y_axis = self.get_axis_data(s=s)
        offset = self._getScaleOffset(s=s)
        x_axis = [x+offset for x in x_axis]

        brush = self._plot_brushes[cfg.data.scales()[::-1].index(s)]
        self.snr_points[s] = pg.ScatterPlotItem(
            size=11,
            pen=pg.mkPen(None),
            brush=brush,
            hoverable=True,
            # hoverSymbol='s',
            hoverSize=14,
            # hoverPen=pg.mkPen('r', width=2),
            hoverBrush=pg.mkBrush('#ffffff'),
            # pxMode=False # points transform with zoom
        )
        self.snr_points[s].addPoints(x_axis[1:], y_axis[1:])
        # logger.info('self.snr_points.toolTip() = %s' % self.snr_points.toolTip())
        # value = self.snr_points.setToolTip('Test')
        self.last_snr_click = None
        self.plot.addItem(self.snr_points[s])
        # self.snr_points[s].sigClicked.connect(lambda: self.onSnrClick2(s))
        self.snr_points[s].sigClicked.connect(self.onSnrClick)

        self.updateErrBars(s=s)


    def updateErrBars(self, s):
        # logger.info('')
        offset = self._getScaleOffset(s=s)
        errbars = cfg.data.snr_errorbars(s=s)
        n = cfg.data.nSections
        deltas = np.zeros(n)
        y = np.zeros(n)
        x = np.arange(0, n ) + offset

        if s in self._error_bars:
            self.plot.removeItem(self._error_bars[s])
            self._error_bars[s] = None

        try:
            skip_list = list(zip(*cfg.data.skips_list()))[0]
        except:
            skip_list = [-1]


        for i, err in enumerate(errbars):
            if i not in skip_list:
                deltas[i] = err
                y[i]      = cfg.data.snr(s=s, l=i)
            else:
                logger.debug(f'skipping errbars for layer {i}')

        err_bar = pg.ErrorBarItem(x=x, y=y,
                                  top=deltas,
                                  bottom=deltas,
                                  beam=0.20,
                                  pen={'color': '#ff0000', 'width': 2})
        self._error_bars[s] = err_bar
        self.plot.addItem(err_bar)


    def wipePlot(self):
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        try:
            for i in reversed(range(self.checkboxes_hlayout.count())):
                self.checkboxes_hlayout.removeItem(self.checkboxes_hlayout.itemAt(i))
            # try:
            #     del self._snr_checkboxes
            # except:
            #     pass
            #0123 !!!!!!!
            self.plot.clear()
            self.plot.addItem(self._curLayerLine)
            for eb in self._error_bars:
                self.plot.removeItem(eb)
            # self.updateSpecialLayerLines()
            # try:
            #     del self._snr_checkboxes
            # except:
            #     print_exception()
        except:
            print_exception()
            logger.warning('Unable To Wipe SNR Plot')


    def mouse_clicked(self, mouseClickEvent):
        if cfg.data:
            try:
                # mouseClickEvent is a pyqtgraph.GraphicsScene.mouseEvents.MouseClickEvent
                print('clicked plot 0x{:x}, event: {}'.format(id(self), mouseClickEvent))
                pos_click = int(mouseClickEvent.pos()[0])
                print('Position Clicked: %d' % pos_click)
                cfg.data.set_layer(pos_click)
                self.updateLayerLinePos()
                cfg.main_window.dataUpdateWidgets()
            except:
                pass

    def onSnrClick2(self, scale):
        logger.info(f'onSnrClick2 ({scale}):')
        self.selected_scale = scale
        cfg.main_window._changeScaleCombo.setCurrentText(scale)


    def onSnrClick(self, plot, points, scale):
        logger.info(f'onSnrClick ({scale}):')
        index = int(points[0].pos()[0])
        snr = float(points[0].pos()[1])
        pt = points[0] # just allow one point clicked
        cfg.main_window.hud.post('Jump to Section #%d (SNR: %.3f)' % (index, snr))
        clickedPen = pg.mkPen({'background-color': "#FF0000", 'width': 1})
        # for p in self.last_snr_click:
        #     p.resetPen()
        #     p.resetBrush()
        # for p in points:
        #     p.setBrush(pg.mkBrush('#ffffff'))
        #     p.setPen(clickedPen)
        if self.last_snr_click:
            self.last_snr_click.resetPen()
            self.last_snr_click.resetBrush()
        pt.setBrush(pg.mkBrush('#ffffff'))
        pt.setPen(clickedPen)
        # self.last_snr_click = points
        self.last_snr_click = pt
        cfg.main_window.jump_to(index)

    def sizeHint(self):
        if cfg.main_window:
            width = int(cfg.main_window.width() / 2)
        else:
            width = int(cfg.WIDTH / 2)
        return QSize(width, 100)


class CustomViewBox(pg.ViewBox):
    def __init__(self, *args, **kwds):
        kwds['enableMenu'] = False
        pg.ViewBox.__init__(self, *args, **kwds)
        self.setMouseMode(self.RectMode)

    ## reimplement right-click to zoom out
    def mouseClickEvent(self, ev):
        if ev.button() == Qt.MouseButton.RightButton:
            self.autoRange()

    ## reimplement mouseDragEvent to disable continuous axis zoom
    def mouseDragEvent(self, ev, axis=None):
        if axis is not None and ev.button() == Qt.MouseButton.RightButton:
            ev.ignore()
        else:
            pg.ViewBox.mouseDragEvent(self, ev, axis=axis)
logger = logging.getLogger(__name__)

__all__ = ['WebBrowser']

class WebEnginePage(QWebEnginePage):
    def __init__(self, *args, **kwargs):
        QWebEnginePage.__init__(self, *args, **kwargs)


class WebBrowser(QWidget):

    def __init__(self, parent=None):
        super().__init__(parent)

        self.browser = QWebEngineView()
        self.browser.loadFinished.connect(self.updateTabLabel)
        self.browser.urlChanged.connect(self.updateUrlBar)
        self.page = WebEnginePage()

        def browser_backward():
            self.browser.page().triggerAction(QWebEnginePage.Back)

        def browser_forward():
            self.browser.page().triggerAction(QWebEnginePage.Forward)

        def browser_reload():
            self.browser.page().triggerAction(QWebEnginePage.Reload)

        def browser_view_source():
            self.browser.page().triggerAction(QWebEnginePage.ViewSource)

        def browser_copy():
            self.browser.page().triggerAction(QWebEnginePage.Copy)

        def browser_paste():
            self.browser.page().triggerAction(QWebEnginePage.Paste)

        def browser_3dem_community():
            self.browser.setUrl(
                QUrl('https://3dem.org/workbench/data/tapis/community/data-3dem-community/'))

        def browser_documentation():
            self.browser.setUrl(
                QUrl('https://github.com/mcellteam/swift-ir/blob/development_ng/README_SWIFTIR.md'))

        def browser_wolframalpha():
            self.browser.setUrl(QUrl('https://www.wolframalpha.com/'))

        buttonBrowserBack = QPushButton()
        buttonBrowserBack.setStatusTip('Go Back')
        buttonBrowserBack.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserBack.clicked.connect(browser_backward)
        buttonBrowserBack.setFixedSize(QSize(20, 20))
        buttonBrowserBack.setIcon(qta.icon('fa.arrow-left', color=cfg.ICON_COLOR))

        buttonBrowserForward = QPushButton()
        buttonBrowserForward.setStatusTip('Go Forward')
        buttonBrowserForward.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserForward.clicked.connect(browser_forward)
        buttonBrowserForward.setFixedSize(QSize(20, 20))
        buttonBrowserForward.setIcon(qta.icon('fa.arrow-right', color=cfg.ICON_COLOR))

        buttonBrowserRefresh = QPushButton()
        buttonBrowserRefresh.setStatusTip('Refresh')
        buttonBrowserRefresh.setIcon(qta.icon("ei.refresh", color=cfg.ICON_COLOR))
        buttonBrowserRefresh.setFixedSize(QSize(20, 20))
        buttonBrowserRefresh.clicked.connect(browser_reload)

        # buttonBrowserViewSource = QPushButton()
        # buttonBrowserViewSource.setStatusTip('View Source')
        # buttonBrowserViewSource.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        # buttonBrowserViewSource.clicked.connect(browser_view_source)
        # buttonBrowserViewSource.setFixedSize(QSize(20, 20))
        # buttonBrowserViewSource.setIcon(qta.icon('ri.code-view', color=cfg.ICON_COLOR))

        buttonBrowserCopy = QPushButton('Copy')
        buttonBrowserCopy.setStyleSheet('font-size: 10px;')
        buttonBrowserCopy.setStatusTip('Copy Text')
        buttonBrowserCopy.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserCopy.clicked.connect(browser_copy)
        buttonBrowserCopy.setFixedSize(QSize(40, 20))

        buttonBrowserPaste = QPushButton('Paste')
        buttonBrowserPaste.setStyleSheet('font-size: 10px;')
        buttonBrowserPaste.setStatusTip('Paste Text')
        buttonBrowserPaste.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonBrowserPaste.clicked.connect(browser_paste)
        buttonBrowserPaste.setFixedSize(QSize(40, 20))

        button3demCommunity = QPushButton('3DEM Community Data')
        button3demCommunity.setStyleSheet('font-size: 9px;')
        button3demCommunity.setStatusTip('Vist the 3DEM Community Workbench')
        button3demCommunity.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        button3demCommunity.clicked.connect(browser_3dem_community)
        button3demCommunity.setFixedSize(QSize(110, 20))

        buttonDocumentation = QPushButton('AlignEM-SWiFT Docs')
        buttonDocumentation.setStyleSheet('font-size: 9px;')
        buttonDocumentation.setStatusTip('View AlignEM-SWiFT Documentation')
        buttonDocumentation.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        buttonDocumentation.clicked.connect(browser_documentation)
        buttonDocumentation.setFixedSize(QSize(110, 20))

        # buttonWolframAlpha = QPushButton('WolframAlpha')
        # buttonWolframAlpha.setStyleSheet('font-size: 9px;')
        # buttonWolframAlpha.setStatusTip('Go to WolframAlpha')
        # buttonWolframAlpha.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        # buttonWolframAlpha.clicked.connect(browser_wolframalpha)
        # buttonWolframAlpha.setFixedSize(QSize(90, 20))

        self.urlBar = QLineEdit()
        self.urlBar.setMinimumWidth(400)
        self.urlBar.returnPressed.connect(self.navigateToUrl)

        self.httpsicon = QLabel()  # Yes, really!
        self.httpsicon.setPixmap(QPixmap(os.path.join('icons', 'lock-nossl.png')))

        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 2, 0, 0)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserBack, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(buttonBrowserForward, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserRefresh, alignment=Qt.AlignmentFlag.AlignLeft)
        # hbl.addWidget(QLabel(' '))
        # hbl.addWidget(buttonBrowserViewSource, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserCopy, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonBrowserPaste, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(QLabel('   |   '))
        hbl.addWidget(button3demCommunity, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(QLabel(' '))
        hbl.addWidget(buttonDocumentation, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(QLabel(' '))
        # hbl.addWidget(buttonWolframAlpha, alignment=Qt.AlignmentFlag.AlignRight)
        # hbl.addWidget(QLabel(' '))
        hbl.addWidget(self.urlBar, alignment=Qt.AlignmentFlag.AlignCenter)

        browser_controls_widget = QWidget()
        browser_controls_widget.setFixedHeight(22)
        browser_controls_widget.setLayout(hbl)

        self.layout = QVBoxLayout()
        self.layout.setContentsMargins(0, 2, 0, 0)
        self.layout.addWidget(browser_controls_widget, alignment=Qt.AlignmentFlag.AlignLeft)
        self.layout.addWidget(self.browser)

        self.setLayout(self.layout)


    def urlChangeed(self):
        pass


    def open(self, url='https://www.google.com/'):
        self.page.profile().clearHttpCache()
        self.browser.setPage(self.page)
        self.browser.load(QUrl(url))
        self.browser.show()


    def setUrl(self, url):
        logger.info('Setting URL to %s' % url)
        self.browser.setUrl(QUrl(url))


    def navigateToUrl(self):
        try:
            q = QUrl(self.urlBar.text())
            if q.scheme() == "":
                q.setScheme("http")
            self.browser.setUrl(q)
        except:
            print_exception()
            logger.warning('Unable to navigate to the requested URL')


    def updateUrlBar(self, q):
        if q.scheme() == 'https':
            # Secure padlock icon
            self.httpsicon.setPixmap(QPixmap(os.path.join('icons', 'lock-ssl.png')))

        else:
            # Insecure padlock icon
            self.httpsicon.setPixmap(QPixmap(os.path.join('icons', 'lock-nossl.png')))

        self.urlBar.setText(q.toString())
        self.urlBar.setCursorPosition(0)


    def updateTabLabel(self):
        if cfg.main_window._getTabType() == 'WebBrowser':
            try:
                tab_index = cfg.main_window.globTabs.indexOf(cfg.main_window.browser)
                tab_text = cfg.main_window.globTabs.currentWidget().browser.title()
                if tab_text == 'https://www.google.com':
                    tab_text = 'Google'
                elif tab_text == 'https://www.wolframalpha.com/':
                    tab_text = 'WolframAlpha'
                logger.info('Setting tab text: %s' % tab_text)
                cfg.main_window.globTabs.setTabText(tab_index, tab_text)
            except:
                logger.warning('There was a problem updating the web browser tab text')
__all__ = ['OpenProject']

logger = logging.getLogger(__name__)


class OpenProject(QWidget):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.setMinimumHeight(200)
        self.filebrowser = FileBrowser(parent=self)
        self.filebrowser.setStyleSheet('border-width: 0px;')
        self.filebrowser.controlsNavigation.show()
        self.user_projects = UserProjects(parent=self)
        self.initUI()

    def initUI(self):
        # User Projects Widget
        self.userProjectsWidget = QWidget()
        lab = QLabel('<h3>Saved AlignEM-SWiFT Projects:</h3>')


        self.row_height_slider = Slider(self)
        self.row_height_slider.valueChanged.connect(self.user_projects.updateRowHeight)
        # self.row_height_slider.setValue(self.initial_row_height)
        # self.updateRowHeight(self.initial_row_height)



        self.fetchSizesCheckbox = QCheckBox('Fetch Sizes')
        self.fetchSizesCheckbox.setChecked(getOpt(lookup='ui,FETCH_PROJECT_SIZES'))
        self.fetchSizesCheckbox.toggled.connect(
            lambda: setOpt('ui,FETCH_PROJECT_SIZES', self.fetchSizesCheckbox.isChecked()))

        self.fetchSizesCheckbox.toggled.connect(self.user_projects.set_data)

        w = QWidget()
        w.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)

        controls = QWidget()
        controls.setFixedHeight(18)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(4, 0, 4, 0)
        hbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(w)
        hbl.addWidget(self.row_height_slider, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self.fetchSizesCheckbox, alignment=Qt.AlignmentFlag.AlignRight)
        controls.setLayout(hbl)

        vbl = QVBoxLayout()
        vbl.setContentsMargins(4, 4, 4, 4)
        vbl.addWidget(controls)
        vbl.addWidget(self.user_projects)
        self.userProjectsWidget.setLayout(vbl)



        # User Files Widget
        self.userFilesWidget = QWidget()
        lab = QLabel('<h3>Open (Project or Zarr):</h3>')
        vbl = QVBoxLayout()
        vbl.setContentsMargins(4, 4, 4, 4)



        w = QWidget()
        w.setContentsMargins(0, 0, 0, 0)
        hbl = QHBoxLayout()
        hbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignLeft)
        hbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignRight)

        vbl.addWidget(self.filebrowser)
        self.userFilesWidget.setLayout(vbl)

        self._buttonOpen = QPushButton('Open')
        self._buttonOpen.clicked.connect(self.open_project_selected)
        self._buttonOpen.setFixedSize(64, 20)

        self._buttonDelete = QPushButton('Delete')
        self._buttonDelete.clicked.connect(self.delete_project)
        self._buttonDelete.setFixedSize(64, 20)

        self._buttonNew = QPushButton('New')
        self._buttonNew.clicked.connect(self.new_project)
        self._buttonNew.setFixedSize(64, 20)

        # self._buttonNew = QPushButton('Remember')
        # self._buttonNew.setStyleSheet("font-size: 9px;")
        # self._buttonNew.clicked.connect(self.new_project)
        # self._buttonNew.setFixedSize(64, 20)
        # # self._buttonNew.setStyleSheet(style)

        self.selectionReadout = QLineEdit()

        self.selectionReadout.textChanged.connect(self.validate_path)
        self.selectionReadout.returnPressed.connect(self.open_project_selected)
        # self.selectionReadout.textEdited.connect(self.validateUserEnteredPath)

        self.selectionReadout.setFixedHeight(22)
        self.selectionReadout.setMinimumWidth(700)

        self.validity_label = QLabel('Invalid')
        self.validity_label.setObjectName('validity_label')
        self.validity_label.setFixedHeight(20)
        self.validity_label.hide()

        hbl = QHBoxLayout()
        hbl.setContentsMargins(6, 2, 6, 2)
        hbl.addWidget(self._buttonNew)
        hbl.addWidget(self.selectionReadout)
        hbl.addWidget(self.validity_label)
        hbl.addWidget(self._buttonOpen)
        hbl.addWidget(self._buttonDelete)
        self.spacer_item_docs = QSpacerItem(0, 0, QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Minimum)
        hbl.addSpacerItem(self.spacer_item_docs)

        self._buttonOpen.setEnabled(False)
        self._buttonDelete.setEnabled(False)

        self._actions_widget = QWidget()
        self._actions_widget.setFixedHeight(26)
        self._actions_widget.setLayout(hbl)


        self._splitter = QSplitter()
        self._splitter.addWidget(self.userProjectsWidget)
        self._splitter.addWidget(self.userFilesWidget)
        self._splitter.setSizes([650, 350])

        self.layout = QVBoxLayout()
        self.layout.setContentsMargins(4, 0, 4, 0)
        self.layout.addWidget(self._splitter)
        self.layout.addWidget(self._actions_widget)
        self.setLayout(self.layout)

    def validate_path(self):
        # logger.info(f'caller:{inspect.stack()[1].function}')
        path = self.selectionReadout.text()
        if validate_project_selection(path) or validate_zarr_selection(path):
            self.validity_label.hide()
            self._buttonOpen.setEnabled(True)
            self._buttonDelete.setEnabled(True)
        else:
            self.validity_label.show()
            self._buttonOpen.setEnabled(False)
            self._buttonDelete.setEnabled(False)

    def userSelectionChanged(self):
        caller = inspect.stack()[1].function
        # if caller == 'setScaleData':
        #     return
        row = self.user_projects.table.currentIndex().row()
        try:
            path = self.user_projects.table.item(row, 9).text()
        except:
            path = ''
            logger.warning(f'No file path at project_table.currentIndex().row()! '
                           f'caller: {caller} - Returning...')
            return
        logger.info(f'path: {path}')
        self.selected_file = path
        self.setSelectionPathText(path)

        # logger.info(f'counter1={self.counter1}, counter2={self.counter2}')



    # def new_project(self):
    #     cfg.main_window.new_project()



    def new_project(self, mendenhall=False):
        logger.critical('Starting A New Project...')
        cfg.main_window.tell('Starting A New Project...')
        cfg.main_window.stopPlaybackTimer()
        if cfg.project_tab:
            logger.info('Data is not None. Asking user to confirm new data...')
            msg = QMessageBox(QMessageBox.Warning,
                              'Confirm New Project',
                              'Please confirm create new project.',
                              buttons=QMessageBox.Cancel | QMessageBox.Ok)
            msg.setIcon(QMessageBox.Question)
            msg.setDefaultButton(QMessageBox.Cancel)
            reply = msg.exec_()
            if reply == QMessageBox.Ok:
                logger.info("Response was 'OK'")
            else:
                logger.info("Response was not 'OK' - Returning")
                self.warn('New Project Canceled.')
                return

        cfg.main_window.tell('New Project Path:')
        filename = new_project_dialog()
        if filename in ['', None]:
            logger.info('New Project Canceled.')
            cfg.main_window.warn("New Project Canceled.")
            return
        if not filename.endswith('.swiftir'):
            filename += ".swiftir"
        if os.path.exists(filename):
            logger.warning("The file '%s' already exists." % filename)
            cfg.main_window.warn("The file '%s' already exists." % filename)
            path_proj = os.path.splitext(filename)[0]
            cfg.main_window.tell(f"Removing Extant Project Directory '{path_proj}'...")
            logger.info(f"Removing Extant Project Directory '{path_proj}'...")
            shutil.rmtree(path_proj, ignore_errors=True)
            cfg.main_window.tell(f"Removing Extant Project File '{path_proj}'...")
            logger.info(f"Removing Extant Project File '{path_proj}'...")
            os.remove(filename)

        path, extension = os.path.splitext(filename)
        cfg.data = DataModel(name=path, mendenhall=mendenhall)

        cfg.project_tab = ProjectTab(self, path=path, datamodel=cfg.data)
        cfg.dataById[id(cfg.project_tab)] = cfg.data

        # makedirs_exist_ok(path, exist_ok=True)

        if not mendenhall:
            try:
                cfg.main_window.import_multiple_images()
            except:
                logger.warning('Import Images Dialog Was Canceled - Returning')
                cfg.main_window.warn('Canceling New Project')
                print_exception()
                return

            recipe_dialog = ScaleProjectDialog(parent=self)
            if recipe_dialog.exec():
                logger.info('ConfigProjectDialog - Passing...')
                pass
            else:
                logger.info('ConfigProjectDialog - Returning...')
                return


            makedirs_exist_ok(path, exist_ok=True)
            cfg.main_window._autosave(silently=True)
            cfg.main_window.autoscale()
            cfg.main_window.globTabs.addTab(cfg.project_tab, os.path.basename(path) + '.swiftir')
            cfg.main_window._setLastTab()
            cfg.main_window.onStartProject()
        else:
            create_project_structure_directories(cfg.data.dest(), ['scale_1'])
            # self.onStartProject(mendenhall=True)
            # turn OFF onStartProject for Mendenhall

        logger.critical(f'Appending {filename} to .swift_cache...')
        userprojectspath = os.path.join(os.path.expanduser('~'), '.swift_cache')
        with open(userprojectspath, 'a') as f:
            f.write(filename + '\n')
        cfg.main_window._autosave()


    def setSelectionPathText(self, path):
        # logger.info(f'caller:{inspect.stack()[1].function}')
        self.selectionReadout.setText(path)
        logger.info('Evaluating whether path is AlignEM-SWiFT Project...')

        if validate_project_selection(path) or validate_zarr_selection(path):
            self.validity_label.hide()
            self._buttonOpen.setEnabled(True)
            self._buttonDelete.setEnabled(True)
        else:
            self.validity_label.show()
            self._buttonOpen.setEnabled(False)
            self._buttonDelete.setEnabled(False)


    def open_zarr_selected(self):
        # path = self.selected_file
        path = self.selectionReadout.text()
        logger.info("Opening Zarr '%s'..." % path)
        try:
            with open(os.path.join(path, '.zarray')) as j:
                self.zarray = json.load(j)
        except:
            print_exception()
            return
        tab = ZarrTab(self, path=path)
        cfg.main_window.globTabs.addTab(tab, os.path.basename(path))
        cfg.main_window._setLastTab()

    def open_project_selected(self):
        # caller = inspect.stack()[1].function
        # logger.info(f'caller: {caller}')
        logger.info('')
        cfg.main_window.stopPlaybackTimer()
        path = self.selectionReadout.text()
        if validate_zarr_selection(path):
            self.open_zarr_selected()
            return
        elif validate_project_selection(path):
            # filename = self.selected_file
            filename = self.selectionReadout.text()
            logger.critical(f'Opening Project {filename}...')
            cfg.main_window.tell('Loading Project "%s"' % filename)
            try:
                with open(filename, 'r') as f:
                    cfg.data = DataModel(data=json.load(f))
                cfg.main_window._autosave()
            except:
                cfg.main_window.warn(f'No Such File Found: {filename}')
                logger.warning(f'No Such File Found: {filename}')
                print_exception()
                return
            else:
                logger.info(f'Project Opened!')
            append_project_path(filename)
            cfg.data.set_paths_absolute(filename=filename)
            cfg.project_tab = ProjectTab(self, path=cfg.data.dest() + '.swiftir', datamodel=cfg.data)
            cfg.dataById[id(cfg.project_tab)] = cfg.data
            cfg.main_window.onStartProject()
            cfg.main_window.globTabs.addTab(cfg.project_tab, os.path.basename(cfg.data.dest()) + '.swiftir')
            cfg.main_window._setLastTab()
        else:
            cfg.main_window.warn("Invalid Path")




    def delete_project(self):
        logger.critical('')
        # project_file = self.selected_file
        project_file = self.selectionReadout.text()
        project = os.path.splitext(project_file)[0]
        if not validate_project_selection(project_file):
            logger.warning('Invalid Project For Deletion (!)\n%s' % project)
            return
        cfg.main_window.warn("Delete the following project?\nProject: %s" % project)
        txt = "Are you sure you want to PERMANENTLY DELETE " \
              "the following project?\n\n" \
              "Project: %s" % project
        msgbox = QMessageBox(QMessageBox.Warning,
                             'Confirm Delete Project',
                             txt,
                             buttons=QMessageBox.Abort | QMessageBox.Yes
                             )
        msgbox.setIcon(QMessageBox.Critical)
        msgbox.setMaximumWidth(350)
        msgbox.setDefaultButton(QMessageBox.Cancel)
        reply = msgbox.exec_()
        if reply == QMessageBox.Abort:
            cfg.main_window.tell('Aborting Delete Project Permanently Instruction...')
            logger.warning('Aborting Delete Project Permanently Instruction...')
            return
        if reply == QMessageBox.Ok:
            logger.info('Deleting Project File %s...' % project_file)
            cfg.main_window.tell('Reclaiming Disk Space. Deleting Project File %s...' % project_file)
            logger.warning('Executing Delete Project Permanently Instruction...')

        logger.critical(f'Deleting Project File: {project_file}...')
        cfg.main_window.warn(f'Deleting Project File: {project_file}...')
        try:
            os.remove(project_file)
        except:
            print_exception()
        else:
            cfg.main_window.hud.done()

        logger.info('Deleting Project Directory %s...' % project)
        cfg.main_window.warn('Deleting Project Directory %s...' % project)
        try:

            delete_recursive(dir=project)
            # shutil.rmtree(project, ignore_errors=True, onerror=handleError)
            # shutil.rmtree(project, ignore_errors=True, onerror=handleError)
        except:
            cfg.main_window.warn('An Error Was Encountered During Deletion of the Project Directory')
            print_exception()
        else:
            cfg.main_window.hud.done()

        cfg.main_window.tell('Wrapping up...')
        configure_project_paths()
        if cfg.main_window.globTabs.currentWidget().__class__.__name__ == 'OpenProject':
            logger.critical('Reloading table of projects data...')
            try:
                cfg.main_window.globTabs.currentWidget().user_projects.set_data()
            except:
                logger.warning('There was a problem updating the project list')
                print_exception()

        self.selectionReadout.setText('')

        cfg.main_window.tell('Deletion Complete!')
        logger.info('Deletion Complete')



class UserProjects(QWidget):
    def __init__(self, parent, **kwargs):
        super().__init__(**kwargs)
        self.parent = parent

        # self.initial_row_height = 64
        self.ROW_HEIGHT = 64

        self.counter1 = 0
        self.counter2 = 0
        # self.counter3 = 0
        self.setFocusPolicy(Qt.StrongFocus)

        self.table = QTableWidget()
        self.table.setShowGrid(False)
        self.table.setSortingEnabled(True)
        self.table.setWordWrap(True)
        self.table.setStyleSheet('font-size: 10px;')
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.SingleSelection)
        self.table.verticalHeader().setVisible(False)
        self.table.verticalHeader().setTextElideMode(Qt.ElideMiddle)
        self.table.horizontalHeader().setDefaultAlignment(Qt.AlignLeft)
        def countCurrentItemChangedCalls(): self.counter2 += 1
        self.table.currentItemChanged.connect(countCurrentItemChangedCalls)
        self.table.currentItemChanged.connect(self.parent.userSelectionChanged)
        def countItemClickedCalls(): self.counter1 += 1
        self.table.itemClicked.connect(countItemClickedCalls)
        self.table.itemClicked.connect(self.parent.userSelectionChanged)
        # def onDoubleClick(): self.parent.open_project_selected()
        self.table.itemDoubleClicked.connect(self.parent.open_project_selected)
        self.table.setStyleSheet("border-radius: 12px; border-width: 3px;"
                                 "QPushButton{background-color: #ffe135;}")
        self.table.setColumnCount(10)
        self.set_headers()


        # self.row_height_slider = Slider(self)
        # self.row_height_slider.valueChanged.connect(self.updateRowHeight)
        # # self.row_height_slider.setValue(self.initial_row_height)
        # # self.updateRowHeight(self.initial_row_height)
        #
        # controls = QWidget()
        # controls.setFixedHeight(18)
        # hbl = QHBoxLayout()
        # hbl.setContentsMargins(4, 0, 4, 0)
        # hbl.addWidget(self.row_height_slider, alignment=Qt.AlignmentFlag.AlignLeft)
        # controls.setLayout(hbl)


        self.layout = QVBoxLayout()
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.addWidget(self.table)
        # self.layout.addWidget(controls)
        self.setLayout(self.layout)
        self.set_data()
        self.updateRowHeight(self.ROW_HEIGHT)


    def updateRowHeight(self, h):
        for section in range(self.table.verticalHeader().count()):
            self.table.verticalHeader().resizeSection(section, h)
        self.table.setColumnWidth(1, h)
        self.table.setColumnWidth(2, h)


    # def userSelectionChanged(self):
    #     caller = inspect.stack()[1].function
    #     # if caller == 'setScaleData':
    #     #     return
    #     row = self.table.currentIndex().row()
    #     try:
    #         path = self.table.item(row,9).text()
    #     except:
    #         cfg.selected_file = ''
    #         logger.warning(f'No file path at project_table.currentIndex().row()! '
    #                        f'caller: {caller} - Returning...')
    #         return
    #     logger.info(f'path: {path}')
    #     cfg.selected_file = path
    #     cfg.main_window.setSelectionPathText(path)
    #     # logger.info(f'counter1={self.counter1}, counter2={self.counter2}')


    def set_headers(self):
        self.table.setHorizontalHeaderLabels([
            "Name",
            "First\nThumbnail",
            "Last\nThumbnail",
            "Created",
            "Last\nOpened",
            "#\nImgs",
            "Image\nSize (px)",
            "Disk Space\n(Bytes)",
            "Disk Space\n(Gigabytes)",
            "Location"])

        header = self.table.horizontalHeader()
        header.setFrameStyle(QFrame.Box | QFrame.Plain)
        header.setStyleSheet("QHeaderView::section { border-bottom: 1px solid gray; }");
        self.table.setHorizontalHeader(header)

    def set_data(self):
        caller = inspect.stack()[1].function
        # logger.info(f'caller: {caller}')
        self.table.clearContents()
        # self.set_column_headers()
        self.table.setRowCount(0)
        for i, row in enumerate(self.get_data()):
            self.table.insertRow(i)
            for j, item in enumerate(row):
                if j == 0:
                    item = '<h5>' + item + '</h5>'
                    lab = QLabel('\n'.join(textwrap.wrap(item, 20)))
                    lab.setWordWrap(True)
                    self.table.setCellWidget(i, j, lab)
                elif j in (1, 2):
                    thumbnail = Thumbnail(self, path=item)
                    self.table.setCellWidget(i, j, thumbnail)
                else:
                    table_item = QTableWidgetItem(str(item))
                    font = QFont()
                    font.setPointSize(10)
                    table_item.setFont(font)
                    self.table.setItem(i, j, table_item)
        self.table.setColumnWidth(0, 128)
        self.table.setColumnWidth(1, 80)
        self.table.setColumnWidth(2, 80)
        self.table.setColumnWidth(3, 70)
        self.table.setColumnWidth(4, 70)
        self.table.setColumnWidth(5, 50)
        self.table.setColumnWidth(6, 70)
        self.table.setColumnWidth(7, 90)
        self.table.setColumnWidth(8, 90)
        self.table.setColumnWidth(9, 120)
        # self.row_height_slider.setValue(self.initial_row_height)
        self.updateRowHeight(self.ROW_HEIGHT)


    def get_data(self):
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        self.project_paths = get_project_list()
        logger.info('Getting project data...')

        projects, thumbnail_first, thumbnail_last, created, modified, \
        n_sections, img_dimensions, bytes, gigabytes, location = \
            [], [], [], [], [], [], [], [], [], []
        for p in self.project_paths:
            try:
                with open(p, 'r') as f:
                    dm = DataModel(data=json.load(f), quitely=True)
            except:
                logger.error('Table view failed to load data model: %s' % p)
            try:    created.append(dm.created())
            except: created.append('Unknown')
            try:    modified.append(dm.modified())
            except: modified.append('Unknown')
            try:    n_sections.append(dm.n_sections())
            except: n_sections.append('Unknown')
            try:    img_dimensions.append(dm.full_scale_size())
            except: img_dimensions.append('Unknown')
            try:    projects.append(os.path.basename(p))
            except: projects.append('Unknown')
            project_dir = os.path.splitext(p)[0]
            try:
                if getOpt(lookup='ui,FETCH_PROJECT_SIZES'):
                    logger.info('Getting project size...')
                    _bytes = get_bytes(project_dir)
                    bytes.append(_bytes)
                    gigabytes.append('%.4f' % float(_bytes / 1073741824))
                else:
                    bytes.append('N/A')
                    gigabytes.append('N/A')
            except:
                bytes.append('Unknown')
                gigabytes.append('Unknown')
            thumb_path = os.path.join(project_dir, 'thumbnails')
            try:    thumbnail_first.append(list_paths_absolute(thumb_path)[0])
            except: thumbnail_first.append('No Thumbnail')
            try:    thumbnail_last.append(list_paths_absolute(thumb_path)[-1])
            except: thumbnail_last.append('No Thumbnail')
            # logger.info('Getting project location...')
            try:    location.append(p)
            except: location.append('Unknown')
        logger.info('<<<< get_data <<<<')
        return zip(projects, thumbnail_first, thumbnail_last, created, modified,
                   n_sections, img_dimensions, bytes, gigabytes, location)



class Thumbnail(QWidget):

    def __init__(self, parent, path):
        super().__init__(parent)
        self.thumbnail = ScaledPixmapLabel(self)
        self.pixmap = QPixmap(path)
        self.thumbnail.setPixmap(self.pixmap)
        self.thumbnail.setScaledContents(True)
        self.layout = QGridLayout()
        self.layout.setContentsMargins(1, 1, 1, 1)
        self.layout.addWidget(self.thumbnail, 0, 0)
        self.setLayout(self.layout)


def validate_project_selection(path) -> bool:
    # logger.info('Validating selection %s...' % cfg.selected_file)
    # called by setSelectionPathText
    path, extension = os.path.splitext(path)
    if extension != '.swiftir':
        return False
    else:
        return True

def validate_zarr_selection(path) -> bool:
    logger.info('Validating selection %s...' % cfg.selected_file)
    # called by setSelectionPathText
    if os.path.isdir(path):
        logger.info('Path IS a directory')
        if '.zarray' in os.listdir(path):
            logger.info('Directory DOES contain .zarray -> Returning True...')
            return True
    logger.info('Returning False...')
    return False

class Slider(QSlider):
    def __init__(self, parent):
        super().__init__(parent)
        self.setOrientation(Qt.Horizontal)
        self.setMinimum(16)
        self.setMaximum(256)
        self.setSingleStep(1)
        self.setPageStep(2)
        self.setTickInterval(1)


class ScaledPixmapLabel(QLabel):
    def __init__(self, parent):
        super().__init__(parent)
        self.setScaledContents(True)

    def paintEvent(self, event):
        if self.pixmap():
            pm = self.pixmap()
            try:
                originalRatio = pm.width() / pm.height()
                currentRatio = self.width() / self.height()
                if originalRatio != currentRatio:
                    qp = QPainter(self)
                    pm = self.pixmap().scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    rect = QRect(0, 0, pm.width(), pm.height())
                    rect.moveCenter(self.rect().center())
                    qp.drawPixmap(rect, pm)
                    return
            except ZeroDivisionError:
                # logger.warning('Cannot divide by zero')
                pass
        super().paintEvent(event)


class ImageWidget(QLabel):

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setScaledContents(True)

    def hasHeightForWidth(self):
        return self.pixmap() is not None

    def heightForWidth(self, w):
        if self.pixmap():
            return int(w * (self.pixmap().height() / self.pixmap().width()))
__all__ = ['ProjectTab']

logger = logging.getLogger(__name__)

class ProjectTab(QWidget):

    def __init__(self,
                 parent,
                 path=None,
                 datamodel=None):
        super().__init__(parent)
        logger.info('')
        # logger.info(f'Initializing Project Tab...\nID(datamodel): {id(datamodel)}, Path: {path}')
        self.parent = parent
        self.path = path
        self.viewer = None
        self.datamodel = datamodel
        self.setUpdatesEnabled(True)
        self.webengine = QWebEngineView()
        # self.webengine.setMouseTracking(True)
        # self.webengine.setFocusPolicy(Qt.StrongFocus)
        self.initUI_Neuroglancer()
        self.initUI_table()
        self.initUI_JSON()
        self.initUI_plot()
        self.initUI_tab_widget()
        self._tabs.currentChanged.connect(self._onTabChange)
        self.manAlignBufferRef = []
        self.manAlignBufferBase = []
        self.mp_colors = ['#f3e375', '#5c4ccc', '#800000',
                          '#aaa672', '#152c74', '#404f74',
                          '#f3e375', '#5c4ccc', '#d6acd6',
                          '#aaa672', '#152c74', '#404f74']

        self.bookmark_tab = 0
        self.MA_ref_cscale = None
        self.MA_ref_zoom = None
        self.MA_base_cscale = None
        self.MA_base_zoom = None

        h = self.MA_webengine_ref.geometry().height()
        self.MA_stageSplitter.setSizes([int(.5*h), int(.5*h)])

    def _onTabChange(self, index=None):
        if index == None:
            index = self._tabs.currentIndex()
        if index == 0:
            self.updateNeuroglancer() # Don't update neuroglancer -> maintain emViewer state
        if index == 1:
            # self.project_table.setScaleData()
            # self.project_table.setScaleData() #not sure why this is needed twice
            pass
        if index == 2:
            # self.updateTreeWidget()
            self.treeview_model.jumpToLayer()
        if index == 3:
            self.snr_plot.data = cfg.data
            self.snr_plot.initSnrPlot()
            self.updatePlotThumbnail()
        # QApplication.processEvents()
        # self.repaint()


    def shutdownNeuroglancer(self):
        logger.critical('')
        if cfg.USE_DELAY:
            time.sleep(cfg.DELAY_BEFORE)
        if ng.is_server_running():
            ng.server.stop()
            # time.sleep(.5)
        if cfg.USE_DELAY:
            time.sleep(cfg.DELAY_AFTER)


    def initNeuroglancer(self):
        logger.critical(f'Initializing Neuroglancer (caller: {inspect.stack()[1].function})...')

        caller = inspect.stack()[1].function
        if getData('state,MANUAL_MODE'):
            # cfg.main_window.comboboxNgLayout.setCurrentText('xy')
            self.MA_viewer_ref = MAViewer(index=max(cfg.data.layer() - 1, 0), role='ref', webengine=self.MA_webengine_ref)
            self.MA_viewer_base = MAViewer(index=cfg.data.layer(), role='base', webengine=self.MA_webengine_base)
            self.MA_viewer_stage = EMViewer(force_xy=True, webengine=self.MA_webengine_stage)

            self.MA_viewer_base.initViewer()
            self.MA_viewer_ref.initViewer()
            self.MA_viewer_stage.initViewer()

            self.MA_viewer_ref.signals.zoomChanged.connect(self.slotUpdateZoomSlider)
            self.MA_viewer_ref.signals.ptsChanged.connect(self.updateListWidgets)
            self.MA_viewer_base.signals.ptsChanged.connect(self.updateListWidgets)
            self.MA_viewer_ref.shared_state.add_changed_callback(self.updateMA_base_state)
            self.MA_viewer_base.shared_state.add_changed_callback(self.updateMA_ref_state)

            self.updateListWidgets()
        else:
            if caller != '_onGlobTabChange':
                self.viewer = cfg.emViewer = EMViewer(webengine=self.webengine)
                self.updateNeuroglancer()
                cfg.main_window.dataUpdateWidgets()  # 0204+
                self.viewer.signals.stateChanged.connect(lambda l: cfg.main_window.dataUpdateWidgets(ng_layer=l))
                self.viewer.signals.zoomChanged.connect(self.slotUpdateZoomSlider)



    def updateNeuroglancer(self):
        caller = inspect.stack()[1].function
        logger.info(f'Updating Neuroglancer Viewer (caller: {caller})')
        if getData('state,MANUAL_MODE'):
            self.MA_viewer_base.initViewer()
            self.MA_viewer_ref.initViewer()
            self.MA_viewer_stage.initViewer()
            self.updateListWidgets()
        else:
            self.viewer.initViewer()
            state = copy.deepcopy(self.viewer.state)
            for layer in state.layers:
                # layer.shaderControls['normalized'] = {'range': np.array(cfg.data.normalize())}
                layer.shaderControls['brightness'] = cfg.data.brightness()
                layer.shaderControls['contrast'] = cfg.data.contrast()
                # layer.volumeRendering = True

            self.viewer.set_state(state)
            url = self.viewer.get_viewer_url()
            logger.info('setting URL...\n%s' % url)
            self.webengine.setUrl(QUrl(url))



    def get_layout(self, requested=None):
        if requested == None:
            requested = cfg.data['ui']['ng_layout']
        mapping = {'xy': 'yz', 'yz': 'xy', 'xz': 'xz', 'xy-3d': 'yz-3d', 'yz-3d': 'xy-3d',
              'xz-3d': 'xz-3d', '4panel': '4panel', '3d': '3d'}
        return mapping[requested]


    def initUI_Neuroglancer(self):
        '''NG Browser'''
        logger.info('')

        self.webengine.loadFinished.connect(lambda: print('QWebengineView Load Finished!'))
        # this fixes detailsSection not displaying immediately on start project
        self.webengine.loadFinished.connect(cfg.main_window.dataUpdateWidgets)



        # self.webengine.loadFinished.connect(self.resetSliderZmag)
        # self.webengine.loadFinished.connect(self.slotUpdateZoomSlider)
        # self.webengine.loadFinished.connect(lambda val=21: self.setZmag(val=val))


        # self.webengine.loadProgress.connect(lambda progress: print(f'QWebengineView Load Progress: {progress}'))
        # self.webengine.urlChanged.connect(lambda terminationStatus:
        #                              print(f'QWebengineView Render Process Terminated!'
        #                                    f' terminationStatus:{terminationStatus}'))

        # self.webengine.settings().setAttribute(QWebEngineSettings.PluginsEnabled, True)
        # self.webengine.settings().setAttribute(QWebEngineSettings.JavascriptEnabled, True)
        # self.webengine.settings().setAttribute(QWebEngineSettings.AllowRunningInsecureContent, True)
        # self.webengine.settings().setAttribute(QWebEngineSettings.LocalContentCanAccessFileUrls, True)
        # self.webengine.settings().setAttribute(QWebEngineSettings.LocalContentCanAccessRemoteUrls, True)

        self.ng_browser_container = QWidget()
        self.ng_browser_container.setObjectName('ng_browser_container')
        self.ng_gl = QGridLayout()
        self.ng_gl.addWidget(self.webengine, 0, 0, 5, 5)
        self._overlayRect = QWidget()
        self._overlayRect.setObjectName('_overlayRect')
        self._overlayRect.setStyleSheet("""background-color: rgba(0, 0, 0, 0.5);""")
        self._overlayRect.setAttribute(Qt.WA_TransparentForMouseEvents)
        self._overlayRect.hide()
        self.ng_gl.addWidget(self._overlayRect, 0, 0, 5, 5)
        self._overlayLab = QLabel()
        self._overlayLab.setStyleSheet("""color: #FF0000; font-size: 28px;""")
        self._overlayLab.hide()

        self.hud_overlay = HeadupDisplay(cfg.main_window.app, overlay=True)
        self.hud_overlay.setFixedWidth(220)
        self.hud_overlay.setFixedHeight(60)
        self.hud_overlay.setSizePolicy(QSizePolicy.Policy.Minimum, QSizePolicy.Policy.Minimum)
        self.hud_overlay.setStyleSheet("""
                    font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
                    font-size: 7px;
                    background-color: rgba(0,0,0,0);
                    color: #ffe135;
                    padding: 1px;
                    """)

        w = QWidget()
        w.setWindowFlags(Qt.FramelessWindowHint)
        w.setAttribute(Qt.WA_TransparentForMouseEvents)
        # spcr = QWidget()
        # spcr.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        vbl = QVBoxLayout()
        # vbl.addWidget(spcr)
        vbl.addWidget(self.hud_overlay)
        w.setLayout(vbl)

        # self.ng_gl.addWidget(self.hud_overlay, 4, 0, 1, 1, alignment=Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignLeft)
        self.ng_gl.addWidget(w, 4, 2, 1, 3, alignment=Qt.AlignmentFlag.AlignBottom | Qt.AlignmentFlag.AlignRight)


        '''AFM/CAFM Widget'''
        self.afm_widget_ = QTextEdit()
        self.afm_widget_.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.afm_widget_.setObjectName('_tool_afmCafm')
        self.afm_widget_.setReadOnly(True)
        self._transformationWidget = QWidget()
        # self._transformationWidget.setFixedSize(180,80)
        self._transformationWidget.setFixedWidth(170)
        self._transformationWidget.setMaximumHeight(70)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.setSpacing(1)
        # vbl.addWidget(lab, alignment=Qt.AlignmentFlag.AlignBaseline)
        vbl.addWidget(self.afm_widget_)
        self._transformationWidget.setLayout(vbl)


        self._overlayBottomLeft = QLabel()
        self._overlayBottomLeft.setObjectName('_overlayBottomLeft')
        self._overlayBottomLeft.hide()
        self.ng_gl.addWidget(self._overlayLab, 0, 0, 5, 5,alignment=Qt.AlignLeft | Qt.AlignBottom)
        self.ng_gl.addWidget(self._overlayBottomLeft, 0, 0, 5, 5, alignment=Qt.AlignLeft | Qt.AlignBottom)
        # self.ng_gl.addWidget(cfg.main_window._tool_afmCafm, 0, 0, alignment=Qt.AlignRight | Qt.AlignBottom)
        self.ng_gl.setContentsMargins(0, 0, 0, 0)
        self.ngVertLab = VerticalLabel('Neuroglancer 3DEM View')
        self.ngVertLab.setObjectName('label_ng')

        dSize = 120

        self.DetailsContainer = QWidget()
        # self.DetailsContainer.setWindowFlags(Qt.FramelessWindowHint)
        # self.DetailsContainer.setAttribute(Qt.WA_TransparentForMouseEvents)
        # self.DetailsContainer.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.DetailsContainer.setAutoFillBackground(False)
        self.DetailsContainer.setAttribute(Qt.WA_TranslucentBackground, True)
        self.DetailsContainer.setStyleSheet("""background-color: rgba(255, 255, 255, 0);""")

        self.detailsCorrSpots = QWidget()
        # self.detailsCorrSpots.setWindowFlags(Qt.FramelessWindowHint)
        # self.detailsCorrSpots.setAttribute(Qt.WA_TransparentForMouseEvents)
        # self.detailsCorrSpots.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.corrSpotClabel = ClickLabel("<b>Corr.&nbsp;Spot</b>")
        self.corrSpotClabel.setStyleSheet("background-color: rgba(255, 255, 255, 0);color: #f3f6fb;")
        self.corrSpotClabel.setAutoFillBackground(False)
        self.corrSpotClabel.setAttribute(Qt.WA_TranslucentBackground, True)
        def fn():
            self.detailsCorrSpots.setVisible(self.detailsCorrSpots.isHidden())
            self.corrSpotClabel.setText(
                ("<b><span style='color: #ffe135;'>Corr.&nbsp;Spot</span></b>",
                 "<b>Corr.&nbsp;Spot</b>")[self.detailsCorrSpots.isHidden()])
            # if not cfg.data.is_aligned_and_generated():
            #     self.detailsCorrSpots.hide()
            #     self.corrSpotClabel.hide()
        self.corrSpotClabel.clicked.connect(fn)
        self.corrSpotClabel.clicked.connect(cfg.main_window.dataUpdateWidgets)

        # self.cs0 = SnrThumbnail(parent=self)
        # self.cs1 = SnrThumbnail(parent=self)
        # self.cs2 = SnrThumbnail(parent=self)
        # self.cs3 = SnrThumbnail(parent=self)
        self.cs0 = CorrSignalThumbnail(parent=self)
        self.cs1 = CorrSignalThumbnail(parent=self)
        self.cs2 = CorrSignalThumbnail(parent=self)
        self.cs3 = CorrSignalThumbnail(parent=self)
        self.cs0.setFixedSize(90,90)
        self.cs1.setFixedSize(90,90)
        self.cs2.setFixedSize(90,90)
        self.cs3.setFixedSize(90,90)

        gl = QGridLayout()
        gl.setSpacing(0)
        gl.setContentsMargins(0, 0, 0, 0)
        gl.addWidget(self.cs0, 0, 0)
        gl.addWidget(self.cs1, 0, 1)
        gl.addWidget(self.cs2, 1, 0)
        gl.addWidget(self.cs3, 1, 1)
        self.csALL = QWidget()
        # self.csALL.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.csALL.setLayout(gl)

        # self.cspotSlider = QSlider(Qt.Orientation.Vertical)
        # self.cspotSlider.setRange(36,256)
        # start_size = 120
        # self.cspotSlider.setValue(start_size)
        # self.cspotSlider.setFixedSize(QSize(16,56))
        # self.csALL.setFixedSize(start_size, start_size)
        #
        # self.cspotSlider.sliderReleased.connect(lambda: self.csALL.setFixedSize(
        #     QSize(self.cspotSlider.value(), self.cspotSlider.value())))
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.csALL, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        # hbl.addWidget(self.cspotSlider, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.detailsCorrSpots.setLayout(hbl)
        self.detailsCorrSpots.hide()

        self.detailsSection = QLabel()
        self.detailsSection.setWindowFlags(Qt.FramelessWindowHint)
        self.detailsSection.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.detailsSection.setMaximumHeight(100)
        self.detailsSection.setMinimumWidth(210)
        # self.detailsSection.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.detailsClabel = ClickLabel("<b><span style='color: #ffe135;'>Section</span></b>")
        self.detailsClabel.setStyleSheet("color: #f3f6fb;")
        self.detailsClabel.setAutoFillBackground(False)
        self.detailsClabel.setAttribute(Qt.WA_TranslucentBackground, True)
        self.detailsClabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        def fn():
            self.detailsSection.setVisible(self.detailsSection.isHidden())
            self.detailsClabel.setText(
                ("<b><span style='color: #ffe135;'>Section</span></b>",
                 "<b>Section</b>")[self.detailsSection.isHidden()])
            cfg.main_window.dataUpdateWidgets()
        self.detailsClabel.clicked.connect(fn)
        self.detailsSection.setWordWrap(True)
        self.detailsSection.setStyleSheet("""
            font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 10px;
            background-color: rgba(0,0,0,.24);
            color: #f3f6fb;
            padding: 3px;
            """)
        # self.detailsSection.hide()


        self.detailsAFM = QLabel()
        self.detailsAFM.setWindowFlags(Qt.FramelessWindowHint)
        self.detailsAFM.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.detailsAFM.setMaximumHeight(100)
        # self.detailsAFM.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.afmClabel = ClickLabel('<b>Affine</b>')
        self.afmClabel.setStyleSheet("background-color: rgba(255, 255, 255, 0); color: #f3f6fb;")
        self.afmClabel.setAutoFillBackground(False)
        self.afmClabel.setAttribute(Qt.WA_TranslucentBackground, True)
        self.afmClabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        def fn():
            self.detailsAFM.setVisible(self.detailsAFM.isHidden())
            self.afmClabel.setText(
                ("<b><span style='color: #ffe135;'>Affine</span></b>",
                 "<b>Affine</b>")[self.detailsAFM.isHidden()])
            cfg.main_window.dataUpdateWidgets()
        self.afmClabel.clicked.connect(fn)
        self.detailsAFM.setWordWrap(True)
        self.detailsAFM.setStyleSheet("""
            font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 10px;
            background-color: rgba(0,0,0,.24);
            color: #f3f6fb;
            padding: 3px;
            """)
        self.detailsAFM.hide()


        self.detailsSNR = QLabel()
        self.detailsSNR.setWindowFlags(Qt.FramelessWindowHint)
        self.detailsSNR.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.detailsSNR.setMaximumHeight(100)
        self.snrClabel = ClickLabel('<b>SNR</b>')
        self.snrClabel.setStyleSheet("background-color: rgba(255, 255, 255, 0); color: #f3f6fb;")
        self.snrClabel.setAutoFillBackground(False)
        self.snrClabel.setAttribute(Qt.WA_TranslucentBackground, True)
        self.snrClabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        def fn():
            self.detailsSNR.setVisible(not self.detailsSNR.isVisible())
            self.snrClabel.setText(
                ("<b><span style='color: #ffe135;'>SNR</span></b>",
                 "<b>SNR</b>")[self.detailsSNR.isHidden()])
            cfg.main_window.dataUpdateWidgets()
        self.snrClabel.clicked.connect(fn)
        self.detailsSNR.setWordWrap(True)
        self.detailsSNR.setStyleSheet("""
            font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 10px;
            background-color: rgba(0,0,0,.24);
            color: #f3f6fb;
            padding: 3px;
            """)
        self.detailsSNR.hide()


        self.detailsRuntime = QLabel()
        self.runtimeClabel = ClickLabel('<b>Runtimes</b>')
        self.runtimeClabel.setStyleSheet("background-color: rgba(255, 255, 255, 0); color: #f3f6fb;")
        self.runtimeClabel.setAutoFillBackground(False)
        self.runtimeClabel.setAttribute(Qt.WA_TranslucentBackground, True)
        self.runtimeClabel.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        def fn():
            self.detailsRuntime.setVisible(not self.detailsRuntime.isVisible())
            self.runtimeClabel.setText(
                ("<b><span style='color: #ffe135;'>Runtimes</span></b>",
                 "<b>Runtimes</b>")[self.detailsSNR.isHidden()])
        self.runtimeClabel.clicked.connect(fn)
        self.detailsRuntime.setWordWrap(True)
        self.detailsRuntime.setStyleSheet("""
                    font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;
                    font-size: 10px;
                    background-color: rgba(0,0,0,.24);
                    color: #f3f6fb;
                    padding: 3px;
                    """)
        self.detailsRuntime.hide()




        self.labelsWidget = QWidget()
        self.labelsWidget.setFixedHeight(20)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(8, 0, 8, 0)
        hbl.addWidget(self.detailsClabel)
        hbl.addWidget(QLabel("<span style='font-size: 15px; color: #f3f6fb; "
                             "font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;'>&#183;</span>"))
        hbl.addWidget(self.afmClabel)
        hbl.addWidget(QLabel("<span style='font-size: 15px; color: #f3f6fb; "
                             "font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;'>&#183;</span>"))
        hbl.addWidget(self.snrClabel)
        hbl.addWidget(QLabel("<span style='font-size: 15px; color: #f3f6fb; "
                             "font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;'>&#183;</span>"))
        hbl.addWidget(self.corrSpotClabel)
        hbl.addWidget(QLabel("<span style='font-size: 15px; color: #f3f6fb; "
                             "font-family: Consolas, 'Andale Mono', 'Ubuntu Mono', monospace;'>&#183;</span>"))
        hbl.addWidget(self.runtimeClabel)
        self.labelsWidget.setLayout(hbl)

        self.detailsDetailsWidget = QWidget()
        self.detailsDetailsWidget.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.detailsDetailsWidget.setWindowFlags(Qt.FramelessWindowHint)
        self.detailsDetailsWidget.show()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0,0,0,0)
        hbl.addWidget(self.detailsSection, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self.detailsAFM, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self.detailsSNR, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self.detailsCorrSpots, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        hbl.addWidget(self.detailsRuntime, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.detailsDetailsWidget.setLayout(hbl)

        vbl = QVBoxLayout()
        vbl.setAlignment(Qt.AlignmentFlag.AlignLeft)
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.setSpacing(0)
        vbl.addWidget(self.labelsWidget, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.DetailsContainer.setLayout(vbl)

        self.spreadW = QWidget()
        self.spreadW.setWindowFlags(Qt.FramelessWindowHint)
        self.spreadW.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.spreadW.setFixedSize(1,12)
        self.spreadW.setVisible(getOpt('neuroglancer,SHOW_UI_CONTROLS'))

        self.spreadW2 = QWidget()
        self.spreadW2.setWindowFlags(Qt.FramelessWindowHint)
        self.spreadW2.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.spreadW2.setFixedSize(96,1)

        self.spreadW3 = QWidget()
        self.spreadW3.setWindowFlags(Qt.FramelessWindowHint)
        self.spreadW3.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.spreadW3.setFixedSize(40,1)

        self.ng_gl.addWidget(self.labelsWidget, 0, 2, 1, 1, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.ng_gl.addWidget(self.spreadW3, 0, 4, 1, 1, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.ng_gl.addWidget(self.spreadW2, 1, 3, 2, 1, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.ng_gl.addWidget(self.spreadW, 1, 4, 1, 1, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.ng_gl.addWidget(self.detailsDetailsWidget, 2, 0, 1, 4, alignment=Qt.AlignmentFlag.AlignTop | Qt.AlignmentFlag.AlignRight)
        self.ng_gl.setRowStretch(0, 1)
        self.ng_gl.setRowStretch(1, 1)
        self.ng_gl.setRowStretch(2, 100)
        self.ng_gl.setRowStretch(3, 25)
        self.ng_gl.setRowStretch(4, 0)
        self.ng_gl.setColumnStretch(0, 24)
        self.ng_gl.setColumnStretch(1, 0)
        self.ng_gl.setColumnStretch(2, 5)
        self.ng_gl.setColumnStretch(3, 1)
        self.updateUISpacing()
        self.ng_browser_container.setLayout(self.ng_gl)

        self.zoomSlider = DoubleSlider(Qt.Orientation.Vertical, self)
        self.zoomSlider.setMaximum(4)
        self.zoomSlider.setMinimum(0.1)
        # self.zoomSlider.valueChanged.connect(self.onZoomSlider)
        self.zoomSlider.sliderMoved.connect(self.onZoomSlider)
        self.zoomSlider.setValue(4.0)

        # self.crossSectionOrientationSlider = DoubleSlider(Qt.Orientation.Vertical, self)
        # # self.zoomSlider.setMaximum(8.0)
        # # self.zoomSlider.setMaximum(100)
        # self.crossSectionOrientationSlider.setMaximum(5.0)
        # self.crossSectionOrientationSlider.setMinimum(-5.0)
        # self.crossSectionOrientationSlider.valueChanged.connect(self.onSliderCrossSectionOrientation)

        # self.crossSectionOrientationSliderAndLabel = QWidget()
        # self.crossSectionOrientationSliderAndLabel.setFixedWidth(24)
        # vbl = QVBoxLayout()
        # vbl.setContentsMargins(0, 0, 0, 0)
        # vbl.addWidget(self.crossSectionOrientationSlider)
        # vbl.addWidget(VerticalLabel('Rotation:'))
        # self.crossSectionOrientationSliderAndLabel.setLayout(vbl)

        self.zoomSliderAndLabel = QWidget()
        self.zoomSliderAndLabel.setFixedWidth(16)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.zoomSlider)
        vbl.addWidget(VerticalLabel('Zoom:'))
        self.zoomSliderAndLabel.setLayout(vbl)

        self.ZdisplaySlider = QSlider(Qt.Orientation.Vertical, self)
        self.ZdisplaySlider = DoubleSlider(Qt.Orientation.Vertical, self)
        self.ZdisplaySlider.setMaximum(20)
        self.ZdisplaySlider.setMinimum(1)
        self.ZdisplaySlider.valueChanged.connect(self.onSliderZmag)
        self.ZdisplaySlider.setValue(1.0)

        self.ZdisplaySliderAndLabel = QWidget()
        self.ZdisplaySliderAndLabel.setFixedWidth(16)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.ZdisplaySlider)
        vbl.addWidget(VerticalLabel('Z-Mag:'))
        self.ZdisplaySliderAndLabel.setLayout(vbl)

        self.MA_webengine_ref = QWebEngineView()
        self.MA_webengine_base = QWebEngineView()
        self.MA_webengine_stage = QWebEngineView()
        self.MA_webengine_ref.setMinimumWidth(200)
        self.MA_webengine_base.setMinimumWidth(200)
        self.MA_webengine_stage.setMinimumWidth(300)
        self.MA_webengine_stage.setMinimumHeight(200)
        # self.MA_webengine_ref.setMouseTracking(True)
        # self.MA_webengine_base.setMouseTracking(True)
        # self.MA_webengine_stage.setMouseTracking(True)
        self.MA_webengine_ref.setFocusPolicy(Qt.StrongFocus)
        self.MA_webengine_base.setFocusPolicy(Qt.StrongFocus)
        self.MA_webengine_stage.setFocusPolicy(Qt.StrongFocus)

        # NO CHANGE----------------------
        # self.MA_viewer_ref.signals.zoomChanged.connect(self.slotUpdateZoomSlider)
        # self.MA_viewer_ref.signals.ptsChanged.connect(self.updateMAlistRef)
        # self.MA_viewer_base.signals.ptsChanged.connect(self.updateMAlistBase)
        # self.MA_viewer_ref.shared_state.add_changed_callback(self.updateMA_base_state)
        # self.MA_viewer_base.shared_state.add_changed_callback(self.updateMA_ref_state)
        # NO CHANGE----------------------

        # MA Stage Buffer Widget
        self.MA_refTitle = QLabel('Reference')
        self.MA_refTitle.setStyleSheet('color: #1b1e23; font-weight: 500;font-size:16px;')
        self.MA_baseTitle = QLabel('Working')
        self.MA_baseTitle.setStyleSheet('color: #1b1e23; font-weight: 500;font-size:16px;')
        self.MA_refNextLab = QLabel('Next:')
        self.MA_refNextLab.setStyleSheet('color: #1b1e23; font-weight: 700;font-size:13px;')
        self.MA_baseNextLab = QLabel('Next:')
        self.MA_baseNextLab.setStyleSheet('color: #1b1e23; font-weight: 700;font-size:13px;')

        self.MA_refNextColorLab = QLabel('Next')
        self.MA_refNextColorLab.setFixedSize(100,16)
        self.MA_refNextColorLab.setStyleSheet('background-color: #ffe135;')
        self.MA_baseNextColorLab = QLabel('Next')
        self.MA_baseNextColorLab.setFixedSize(100,16)
        self.MA_baseNextColorLab.setStyleSheet('background-color: #ffe135;')


        self.MA_ptsListWidget_ref = QListWidget()
        self.MA_ptsListWidget_ref.installEventFilter(self)
        self.MA_ptsListWidget_ref.itemClicked.connect(self.refListItemClicked)

        self.MA_ptsListWidget_base = QListWidget()
        self.MA_ptsListWidget_base.installEventFilter(self)
        self.MA_ptsListWidget_base.itemClicked.connect(self.baseListItemClicked)


        # self.gb_actionsMA = QGroupBox('Actions')
        self.gb_actionsMA = QGroupBox()
        fl_actionsMA = QFormLayout()
        fl_actionsMA.setContentsMargins(0, 0, 0, 0)
        self.gb_actionsMA.setLayout(fl_actionsMA)

        lab = QLabel('Method: ')
        tip = 'Automatic Alignment using SWIM'
        self.rbAuto = QRadioButton('Automatic')
        self.rbAuto.setStatusTip(tip)
        # self.rbAuto.setChecked(True)
        self.rbAuto.setFocusPolicy(Qt.FocusPolicy.NoFocus)

        tip = 'Align by Manual-Hint Point Selection'
        self.rbManHint = QRadioButton('Manual, Hint')
        self.rbManHint.setStatusTip(tip)
        self.rbManHint.setFocusPolicy(Qt.FocusPolicy.NoFocus)

        tip = 'Align by Manual-Strict Point Selection'
        self.rbManStrict = QRadioButton('Manual, Strict')
        self.rbManStrict.setStatusTip(tip)
        self.rbManStrict.setFocusPolicy(Qt.FocusPolicy.NoFocus)

        self.rbAuto.setEnabled(False)
        self.rbManHint.setEnabled(False)
        self.rbManStrict.setEnabled(False)

        self.rbMethodGroup = QButtonGroup()
        self.rbMethodGroup.addButton(self.rbAuto)
        self.rbMethodGroup.addButton(self.rbManHint)
        self.rbMethodGroup.addButton(self.rbManStrict)
        self.rbMethodGroup.setExclusive(True)

        self.rbAuto.toggled.connect(self.updateListWidgets)
        self.rbManHint.toggled.connect(self.updateListWidgets)
        self.rbManStrict.toggled.connect(self.updateListWidgets)

        '''Alignment Method (displayed):
           Alignment Method (next run):
           '''

        w = QWidget()
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(lab)
        hbl.addWidget(self.rbAuto)
        hbl.addWidget(self.rbManHint)
        hbl.addWidget(self.rbManStrict)
        w.setLayout(hbl)
        fl_actionsMA.addWidget(w)

        self.btnClearMA = QPushButton('Clear Manual Points')
        self.btnClearMA.setMaximumHeight(20)
        def fn():
            self.deleteAllMp()
            self.initNeuroglancer()
        self.btnClearMA.clicked.connect(fn)

        self.btnResetAllMA = QPushButton('Set All To Automatic-SWIM && Realign')
        self.btnResetAllMA.setMaximumHeight(20)
        def fn():
            s = cfg.data.scale()
            for i in range(len(cfg.data)):
                cfg.data['data']['scales'][s]['alignment_stack'][i]['alignment']['selected_method'] = 'Auto-SWIM'
            cfg.main_window.alignAll()
            cfg.main_window.enterExitManAlignMode(force_exit=True)
        self.btnResetAllMA.clicked.connect(fn)

        self.btnSaveAndRealignMA = QPushButton('Save && Realign')
        self.btnSaveAndRealignMA.setMaximumHeight(20)
        def fn():
            self.applyMps()
            logger.critical('Aligning The Current Section...')
            cfg.main_window.alignOne()
            # cfg.main_window.alignAll()
            logger.critical('Regenerating...')
            cfg.main_window.regenerate(scale=cfg.data.scale())
        self.btnSaveAndRealignMA.clicked.connect(fn)

        self.btnSaveExitMA = QPushButton('Save && Exit Manual Alignment Mode')
        self.btnSaveExitMA.setMaximumHeight(20)
        def fn():
            self.applyMps()

            cfg.main_window.enterExitManAlignMode(force_exit=True)
        self.btnSaveExitMA.clicked.connect(fn)

        self.btnExitMA = QPushButton('Exit Manual Alignment Mode')
        # with open('src/styles/controls.qss', 'r') as f:
        #     self.btnExitMA.setStyleSheet(f.read())
        self.btnExitMA.setMaximumHeight(20)
        self.btnExitMA.clicked.connect(cfg.main_window.enterExitManAlignMode)

        fl_actionsMA.addWidget(self.btnClearMA)
        fl_actionsMA.addWidget(self.btnSaveAndRealignMA)
        fl_actionsMA.addWidget(self.btnResetAllMA)
        fl_actionsMA.addWidget(self.btnSaveExitMA)
        fl_actionsMA.addWidget(self.btnExitMA)


        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)

        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.MA_refTitle)
        vbl.addWidget(self.MA_ptsListWidget_ref)
        # vbl.addWidget(self.MA_refNextLab)
        vbl.addWidget(self.MA_refNextColorLab)
        w.setLayout(vbl)
        hbl.addWidget(w)

        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.MA_baseTitle)
        vbl.addWidget(self.MA_ptsListWidget_base)
        # vbl.addWidget(self.MA_baseNextLab)
        vbl.addWidget(self.MA_baseNextColorLab)
        w.setLayout(vbl)
        hbl.addWidget(w)

        self.MA_sbw = QWidget() # make the widget
        # self.MA_sbw.setMaximumHeight(500)
        self.MA_sbw.setLayout(hbl)


        self.MA_sbw_ext = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.MA_sbw)
        vbl.addWidget(self.gb_actionsMA)
        self.MA_sbw_ext.setLayout(vbl)

        txt = '⇧ + Click - Select at least 3 and up to 7 corresponding points'
        self.msg_MAinstruct = QLabel()
        self.msg_MAinstruct.setAttribute(Qt.WA_TransparentForMouseEvents)
        self.msg_MAinstruct.setAlignment(Qt.AlignCenter)
        # self.msg_MAinstruct.setStyleSheet('color: #1b1e23; font-weight: 400;font-size:12px;')
        self.msg_MAinstruct.setStyleSheet(
            """
            color: #ffe135;
            background-color: rgba(0,0,0,.24);
            font-weight: 600;
            text-align: center;
            padding: 3px;
            """)
        # self.afmClabel.setAutoFillBackground(False)
        # self.afmClabel.setAttribute(Qt.WA_TranslucentBackground, True)
        self.msg_MAinstruct.setText(txt)
        self.msg_MAinstruct.setFixedHeight(30)
        self.msg_MAinstruct.setFixedWidth(430)


        self.MA_stageSplitter = QSplitter(Qt.Orientation.Vertical)
        self.MA_stageSplitter.addWidget(self.MA_webengine_stage)
        self.MA_stageSplitter.addWidget(self.MA_sbw_ext)
        self.MA_stageSplitter.setCollapsible(0, False)
        self.MA_stageSplitter.setCollapsible(1, False)

        '''MA Stage area widgets'''
        # MA Stage Widget
        # self.MA_stageSplitter = QWidget()
        # self.MA_stageSplitter.setMinimumWidth(32)
        # self.MA_stageSplitter.setLayout(vbl)


        self.MA_gl = QGridLayout()
        self.MA_gl.setContentsMargins(0,0,0,0)

        pixmap = QPixmap('src/resources/cursor_circle.png')
        cursor = QCursor(pixmap)

        w = QWidget()

        # w.setCursor(cursor)
        # self.MA_webengine_ref.setCursor(cursor)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.MA_webengine_ref)
        w.setLayout(vbl)
        self.MA_gl.addWidget(w, 0, 0, 4, 2)

        w = QWidget()
        # w.setCursor(cursor)
        # self.MA_webengine_base.setCursor(cursor)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.MA_webengine_base)
        w.setLayout(vbl)
        self.MA_gl.addWidget(w, 0, 2, 4, 2)
        self.dum = QWidget()
        # dum.setAttribute(Qt.WA_TransparentForMouseEvents)
        # dum.setWindowFlags(w.windowFlags() | Qt.WindowTransparentForInput | Qt.X11BypassWindowManagerHint)
        # self.dum.setWindowFlags(Qt.WindowTransparentForInput)
        # self.dum.setAttribute(Qt.WA_TranslucentBackground)
        # QApplication.setOverrideCursor(cursor)

        # self.dum.setStyleSheet("""background-color: rgba(0, 0, 0, 0.5);""")
        # self.MA_gl.addWidget(self.dum, 0, 2, 2, 2)

        self.MA_gl.addWidget(self.msg_MAinstruct, 2, 1, 1, 2)

        # self.MA_gl.addWidget(self.MA_stageSplitter, alignment=Qt.AlignmentFlag.AlignBottom)

        self.MA_widget = QWidget()
        self.MA_widget.setCursor(cursor)
        self.MA_widget.setLayout(self.MA_gl)
        # self.MA_widget.hide()

        self.MA_splitter = QSplitter()
        self.MA_splitter.setHandleWidth(2)
        self.MA_splitter.addWidget(self.MA_widget)
        self.MA_splitter.addWidget(self.MA_stageSplitter)
        self.MA_splitter.setCollapsible(0, False)
        self.MA_splitter.setCollapsible(1, False)
        self.MA_splitter.setSizes([.70*cfg.WIDTH, .30*cfg.WIDTH])
        self.MA_splitter.hide()

        self.weSplitter = QSplitter(Qt.Orientation.Horizontal)
        self.weSplitter.addWidget(self.ng_browser_container)
        self.weSplitter.addWidget(self.MA_splitter)
        self.weSplitter.setCollapsible(0, False)
        self.weSplitter.setCollapsible(1, False)

        hbl = QHBoxLayout()
        hbl.setSpacing(1)
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.ngVertLab)
        hbl.addWidget(self.weSplitter)
        # hbl.addWidget(self.zoomSlider)
        # hbl.addWidget(self.crossSectionOrientationSliderAndLabel)
        hbl.addWidget(self.ZdisplaySliderAndLabel)
        hbl.addWidget(self.zoomSliderAndLabel)
        self.ng_browser_container_outer = QWidget()
        self.ng_browser_container_outer.setObjectName('ng_browser_container_outer')
        self.ng_browser_container_outer.setLayout(hbl)


    def refListItemClicked(self, qmodelindex):
        item = self.MA_ptsListWidget_ref.currentItem()
        logger.info(f"Selected {item.text()}")


    def baseListItemClicked(self, qmodelindex):
        item = self.MA_ptsListWidget_base.currentItem()
        logger.info(f"Selected {item.text()}")





    def checkMApoints(self):
        return (self.MA_viewer_ref.pts.keys() == self.MA_viewer_base.pts.keys()) and \
                                (len(self.MA_viewer_ref.pts.keys()) > 2)

    def updateListWidgets(self):
        self.updateMAlistRef()
        self.updateMAlistBase()
        isValid = self.checkMApoints()
        self.btnSaveExitMA.setEnabled(isValid)
        if isValid or self.rbAuto:
            self.btnSaveAndRealignMA.setEnabled(isValid)
        self.rbAuto.setEnabled(True)
        self.rbManHint.setEnabled(isValid)
        self.rbManStrict.setEnabled(isValid)


    def updateMAlistRef(self):
        logger.info('')
        self.MA_ptsListWidget_ref.clear()
        n = 0
        for key in self.MA_viewer_ref.pts.keys():
            p = self.MA_viewer_ref.pts[key]
            _, x, y = p.point.tolist()
            item = QListWidgetItem('(%.1f,  %.1f)' % (x, y))
            item.setBackground(QColor(self.mp_colors[n]))
            self.MA_ptsListWidget_ref.addItem(item)
            n += 1
        self.MA_refNextColorLab.setStyleSheet(
            f'''background-color: {self.MA_viewer_ref.getNextUnusedColor()}''')


    def updateMAlistBase(self):
        logger.info('')
        self.MA_ptsListWidget_base.clear()
        n = 0
        for key in self.MA_viewer_base.pts.keys():
            p = self.MA_viewer_base.pts[key]
            _, x, y = p.point.tolist()
            item = QListWidgetItem('(%.1f,  %.1f)' % (x, y))
            item.setBackground(QColor(self.mp_colors[n]))
            self.MA_ptsListWidget_base.addItem(item)
            n += 1
        self.MA_baseNextColorLab.setStyleSheet(
            f'''background-color: {self.MA_viewer_base.getNextUnusedColor()}''')


    def updateMA_ref_state(self):
        caller = inspect.stack()[1].function
        # curframe = inspect.currentframe()
        # calframe = inspect.getouterframes(curframe, 2)
        # calname = str(calframe[1][3])
        # logger.info('Caller: %s, calname: %s, sender: %s' % (caller, calname, self.sender()))
        if caller != 'on_state_change':
            if self.MA_webengine_ref.isVisible():
                if self.MA_viewer_base.state.cross_section_scale:
                    # if self.MA_viewer_base.state.cross_section_scale < 10_000:
                    #     if self.MA_viewer_base.state.cross_section_scale != 1.0:
                    pos = self.MA_viewer_base.state.position
                    zoom = self.MA_viewer_base.state.cross_section_scale
                    if isinstance(pos,np.ndarray) or isinstance(zoom,np.ndarray):
                        state = copy.deepcopy(self.MA_viewer_ref.state)
                        if isinstance(pos, np.ndarray):
                            state.position = self.MA_viewer_base.state.position
                        if isinstance(zoom, float):
                            if self.MA_viewer_base.state.cross_section_scale < 10_000:
                                if self.MA_viewer_base.state.cross_section_scale != 1.0:
                                    state.cross_section_scale = self.MA_viewer_base.state.cross_section_scale
                        self.MA_viewer_ref.set_state(state)


    def updateMA_base_state(self):
        caller = inspect.stack()[1].function
        # curframe = inspect.currentframe()
        # calframe = inspect.getouterframes(curframe, 2)
        # calname = str(calframe[1][3])
        # logger.info('Caller: %s, calname: %s, sender: %s' % (caller, calname, self.sender()))
        if caller != 'on_state_change':
            if self.MA_webengine_base.isVisible():
                if self.MA_viewer_ref.state.cross_section_scale:
                    # if self.MA_viewer_ref.state.cross_section_scale < 10_000:
                    #     if self.MA_viewer_ref.state.cross_section_scale != 1.0:
                    pos = self.MA_viewer_ref.state.position
                    zoom = self.MA_viewer_ref.state.cross_section_scale
                    if isinstance(pos, np.ndarray) or isinstance(zoom, np.ndarray):
                        state = copy.deepcopy(self.MA_viewer_base.state)
                        if isinstance(pos, np.ndarray):
                            state.position = self.MA_viewer_ref.state.position
                        if isinstance(zoom, float):
                            if self.MA_viewer_ref.state.cross_section_scale < 10_000:
                                if self.MA_viewer_ref.state.cross_section_scale != 1.0:
                                    state.cross_section_scale = self.MA_viewer_ref.state.cross_section_scale
                        self.MA_viewer_base.set_state(state)


    def deleteMpRef(self):
        logger.info('Deleting A Reference Image Manual Correspondence Point from Buffer...')
        cfg.main_window.hud.post('Deleting A Reference Image Manual Correspondence Point from Buffer...')
        for item in self.MA_ptsListWidget_ref.selectedItems():
            self.MA_ptsListWidget_ref.takeItem(self.MA_ptsListWidget_ref.row(item))
        if self.MA_ptsListWidget_ref.currentItem():
            del_key = self.MA_ptsListWidget_ref.currentItem().background().color().name()
            logger.info('del_key is %s' % del_key)
            self.MA_viewer_ref.pts.pop(del_key)
            self.MA_viewer_ref.update_annotations()
        self.updateListWidgets()
        self.updateNeuroglancer()



    def deleteMpBase(self):
        logger.info('Deleting A Base Image Manual Correspondence Point from Buffer...')
        cfg.main_window.hud.post('Deleting A Base Image Manual Correspondence Point from Buffer...')
        for item in self.MA_ptsListWidget_base.selectedItems():
            self.MA_ptsListWidget_base.takeItem(self.MA_ptsListWidget_base.row(item))
        if self.MA_ptsListWidget_base.currentItem():
            del_key = self.MA_ptsListWidget_base.currentItem().background().color().name()
            logger.info('del_key is %s' % del_key)
            self.MA_viewer_base.pts.pop(del_key)
            self.MA_viewer_base.update_annotations()
        self.updateListWidgets()
        self.updateNeuroglancer()


    def deleteAllMpRef(self):
        logger.info('Deleting All Reference Image Manual Correspondence Points from Buffer...')
        cfg.main_window.hud.post('Deleting All Reference Image Manual Correspondence Points from Buffer...')
        self.MA_viewer_ref.pts.clear()
        self.MA_ptsListWidget_ref.clear()
        self.MA_viewer_ref.update_annotations()
        self.updateListWidgets()
        self.updateNeuroglancer()


    def deleteAllMpBase(self):
        logger.info('Deleting All Base Image Manual Correspondence Points from Buffer...')
        cfg.main_window.hud.post('Deleting All Base Image Manual Correspondence Points from Buffer...')
        self.MA_viewer_base.pts.clear()
        self.MA_ptsListWidget_base.clear()
        self.MA_viewer_base.update_annotations()
        self.updateListWidgets()
        self.updateNeuroglancer()


    def deleteAllMp(self):
        logger.info('Deleting All Base + Reference Image Manual Correspondence Points from Buffer...')
        cfg.main_window.hud.post('Deleting All Base + Reference Image Manual Correspondence Points from Buffer...')
        cfg.data.clearMps()
        self.MA_viewer_ref.pts.clear()
        self.MA_ptsListWidget_ref.clear()
        self.MA_viewer_base.pts.clear()
        self.MA_ptsListWidget_base.clear()
        self.MA_viewer_ref.update_annotations()
        self.MA_viewer_base.update_annotations()
        self.updateListWidgets()
        self.applyMps()
        self.updateNeuroglancer()


    def applyMps(self):
        logger.info('')
        if self.checkMApoints():
            ref_pts, base_pts = [], []
            for key in self.MA_viewer_ref.pts.keys():
                p = self.MA_viewer_ref.pts[key]
                _, x, y = p.point.tolist()
                ref_pts.append((x, y))
            for key in self.MA_viewer_base.pts.keys():
                p = self.MA_viewer_base.pts[key]
                _, x, y = p.point.tolist()
                base_pts.append((x, y))
            logger.info('Setting+Saving Reference manual points: %s' % str(ref_pts))
            logger.info('Setting+Saving Working manual points: %s' % str(base_pts))
            cfg.data.set_manual_points('ref', ref_pts)
            cfg.data.set_manual_points('base', base_pts)

            if self.rbAuto.isChecked():
                cfg.data.set_selected_method('Auto-SWIM')
            if self.rbManHint.isChecked():
                cfg.data.set_selected_method('Manual-Hint')
            elif self.rbManStrict.isChecked():
                cfg.data.set_selected_method('Manual-Strict')
            else:
                cfg.data.set_selected_method('Auto-SWIM')

            cfg.data.print_all_match_points()
            cfg.main_window._saveProjectToFile(silently=True)
            cfg.main_window.hud.post('Match Points Saved!')


    def eventFilter(self, source, event):
        if event.type() == QEvent.ContextMenu and source is self.MA_ptsListWidget_ref:
            menu = QMenu()
            self.deleteMpRefAction = QAction('Delete')
            self.deleteMpRefAction.setStatusTip('Delete this manual correspondence point')
            self.deleteMpRefAction.triggered.connect(self.deleteMpRef)
            menu.addAction(self.deleteMpRefAction)
            self.deleteAllMpRefAction = QAction('Delete All Ref Pts')
            self.deleteAllMpRefAction.setStatusTip('Delete all reference manual correspondence points')
            self.deleteAllMpRefAction.triggered.connect(self.deleteAllMpRef)
            menu.addAction(self.deleteAllMpRefAction)
            self.deleteAllPtsAction0 = QAction('Delete All Pts')
            self.deleteAllPtsAction0.setStatusTip('Delete all manual correspondence points')
            self.deleteAllPtsAction0.triggered.connect(self.deleteAllMp)
            menu.addAction(self.deleteAllPtsAction0)
            if menu.exec_(event.globalPos()):
                item = source.itemAt(event.pos())
            return True
        elif event.type() == QEvent.ContextMenu and source is self.MA_ptsListWidget_base:
            menu = QMenu()
            self.deleteMpBaseAction = QAction('Delete')
            self.deleteMpBaseAction.setStatusTip('Delete this manual correspondence point')
            self.deleteMpBaseAction.triggered.connect(self.deleteMpBase)
            menu.addAction(self.deleteMpBaseAction)
            self.deleteAllMpBaseAction = QAction('Delete All Base Pts')
            self.deleteAllMpBaseAction.setStatusTip('Delete all base manual correspondence points')
            self.deleteAllMpBaseAction.triggered.connect(self.deleteAllMpBase)
            menu.addAction(self.deleteAllMpBaseAction)
            self.deleteAllPtsAction1 = QAction('Delete All Pts')
            self.deleteAllPtsAction1.setStatusTip('Delete all manual correspondence points')
            self.deleteAllPtsAction1.triggered.connect(self.deleteAllMp)
            menu.addAction(self.deleteAllPtsAction1)
            if menu.exec_(event.globalPos()):
                item = source.itemAt(event.pos())
            return True
        return super().eventFilter(source, event)

    def onEnterManualMode(self):
        # logger.critical('')
        self.bookmark_tab = self._tabs.currentIndex()
        self._tabs.setCurrentIndex(0)
        self.ng_browser_container.hide()
        self.MA_splitter.show()

        method = cfg.data.selected_method()
        if method == 'Auto-SWIM':
            self.rbAuto.setChecked(True)
        elif method == 'Manual-Hint':
            self.rbManHint.setChecked(True)
        elif method == 'Manual-Strict':
            self.rbManStrict.setChecked(True)
        else:
            self.rbAuto.setChecked(True)

        #Todo update listwidgets before entering manual alignment mode
        self.MA_viewer_ref = MAViewer(index=max(cfg.data.layer() - 1, 0), role='ref', webengine=self.MA_webengine_ref)
        self.MA_viewer_base = MAViewer(index=cfg.data.layer(), role='base', webengine=self.MA_webengine_base)
        self.MA_viewer_stage = EMViewer(force_xy=True, webengine=self.MA_webengine_stage)
        self.MA_viewer_ref.initViewer()
        self.MA_viewer_base.initViewer()
        self.MA_viewer_stage.initViewer()
        self.MA_viewer_ref.signals.zoomChanged.connect(self.slotUpdateZoomSlider)
        self.MA_viewer_ref.signals.ptsChanged.connect(self.updateListWidgets)
        self.MA_viewer_base.signals.ptsChanged.connect(self.updateListWidgets)
        self.MA_viewer_ref.shared_state.add_changed_callback(self.updateMA_base_state)
        self.MA_viewer_base.shared_state.add_changed_callback(self.updateMA_ref_state)

        self.ngVertLab.setText('Manual Alignment Mode')
        self.ngVertLab.setStyleSheet("""background-color: #1b1e23; color: #f3f6fb;""")

        self.updateListWidgets()


    def onExitManualMode(self):
        # logger.critical('')
        # self.deleteAllMp()
        self.MA_viewer_ref.pts.clear()
        self.MA_ptsListWidget_ref.clear()
        self.MA_viewer_base.pts.clear()
        self.MA_ptsListWidget_base.clear()
        self._tabs.setCurrentIndex(self.bookmark_tab)
        self.ng_browser_container.show()
        # self.MA_widget.hide()
        self.MA_splitter.hide()
        self.ngVertLab.setStyleSheet('')
        self.ngVertLab.setText('Neuroglancer 3DEM View')
        self.initNeuroglancer()


    def updateUISpacing(self):
        isUiControls = getOpt('neuroglancer,SHOW_UI_CONTROLS')
        self.spreadW.setVisible(isUiControls)
        if isUiControls:
            self.spreadW2.setFixedSize(96, 1)
            self.spreadW3.setFixedSize(40, 1)
        else:
            self.spreadW2.setFixedSize(10, 1)
            self.spreadW3.setFixedSize(10, 1)

    def slotUpdateZoomSlider(self):
        # Lets only care about REF <--> slider
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        try:
            if getData('state,MANUAL_MODE'):
                val = self.MA_viewer_ref.state.cross_section_scale
                if val:
                    if val != 0:
                        new_val = float(sqrt(val))
                        # logger.info(f'val = {val}, new_val = {new_val}')
                        self.zoomSlider.setValue(new_val)
            else:
                val = self.viewer.state.cross_section_scale
                if val:
                    if val != 0:
                        new_val = float(sqrt(val))
                        # logger.info(f'val = {val}, new_val = {new_val}')
                        self.zoomSlider.setValue(new_val)
        except:
            print_exception()


    def onZoomSlider(self):
        caller = inspect.stack()[1].function
        curframe = inspect.currentframe()
        calframe = inspect.getouterframes(curframe, 2)
        calname = str(calframe[1][3])

        logger.critical('caller: %s, calname: %s, sender: %s' % (caller, calname, self.sender()))

        if caller not in  ('slotUpdateZoomSlider', 'setValue'):
            if getData('state,MANUAL_MODE'):
                val = self.zoomSlider.value()
                state = copy.deepcopy(self.MA_viewer_ref.state)
                state.cross_section_scale = val * val
                self.MA_viewer_ref.set_state(state)
            else:
                try:
                    val = self.zoomSlider.value()
                    state = copy.deepcopy(self.viewer.state)
                    state.cross_section_scale = val * val
                    self.viewer.set_state(state)
                except:
                    print_exception()


    def setZmag(self, val):
        logger.critical(f'Setting Z-mag to {val}...')
        try:
            state = copy.deepcopy(self.viewer.state)
            state.relative_display_scales = {'z': val}
            self.viewer.set_state(state)
            cfg.main_window.update()
        except:
            print_exception()


    def onSliderZmag(self):
        caller = inspect.stack()[1].function
        logger.critical('caller: %s' % caller)
        try:
            if getData('state,MANUAL_MODE'):
                val = self.ZdisplaySlider.value()
                state = copy.deepcopy(self.MA_viewer_ref.state)
                state.relative_display_scales = {'z': val}
                self.MA_viewer_ref.set_state(state)
                state = copy.deepcopy(self.MA_viewer_base.state)
                state.relative_display_scales = {'z': val}
                self.MA_viewer_base.set_state(state)
            else:
                val = self.ZdisplaySlider.value()
                logger.critical('val = %d' % val)
                state = copy.deepcopy(self.viewer.state)
                state.relative_display_scales = {'z': val}
                self.viewer.set_state(state)
            cfg.main_window.update()
        except:
            print_exception()


    def resetSliderZmag(self):
        caller = inspect.stack()[1].function
        logger.info(f'caller: {caller}')
        try:
            if cfg.main_window.rb1.isChecked():
                self.ZdisplaySlider.setValue(10)
            else:
                self.ZdisplaySlider.setValue(1)

        except:
            print_exception()

    # def onSliderCrossSectionOrientation(self):
    #     caller = inspect.stack()[1].function
    #     # if caller not in ('slotUpdateZoomSlider', 'setValue'):
    #     #     # logger.info(f'caller: {caller}')
    #     if cfg.emViewer.state.cross_section_scale:
    #         state = copy.deepcopy(cfg.emViewer.state)
    #         val = self.crossSectionOrientationSlider.value()
    #         logger.info(f'val={val}')
    #         # cur_val = state.cross_section_orientation
    #         state.cross_section_orientation = [0,0,0,val]
    #         cfg.emViewer.set_state(state)
    #     else:
    #         logger.warning('cfg.emViewer.state.cross_section_scale does not exist!')


    def initUI_table(self):
        '''Layer View Widget'''
        logger.info('')
        self.project_table = ProjectTable(self)
        self.project_table.setObjectName('project_table')
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.project_table)
        self.label_overview = VerticalLabel('Project Data Table View')
        self.label_overview.setObjectName('label_overview')
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.label_overview)
        hbl.addLayout(vbl)
        self.table_container = QWidget()
        self.table_container.setObjectName('table_container')
        self.table_container.setLayout(hbl)


    def updateTreeWidget(self):
        logger.info('')
        self.treeview_model.load(cfg.data.to_dict())
        self.treeview.header().resizeSection(0, 300)
        self.treeview.expandAll()


    def initUI_JSON(self):
        '''JSON Project View'''
        logger.info('')
        self.treeview = QTreeView()
        self.treeview.setAnimated(True)
        self.treeview.setIndentation(20)
        self.treeview.header().resizeSection(0, 300)
        self.treeview_model = JsonModel()
        self.treeview.setModel(self.treeview_model)
        self.treeview.setAlternatingRowColors(True)
        self._wdg_treeview = QWidget()
        self._wdg_treeview.setObjectName('_wdg_treeview')
        self.btnCollapseAll = QPushButton('Collapse All')
        self.btnCollapseAll.setFixedSize(90,18)
        self.btnCollapseAll.clicked.connect(self.treeview.collapseAll)
        self.btnExpandAll = QPushButton('Expand All')
        self.btnExpandAll.setFixedSize(90,18)
        self.btnExpandAll.clicked.connect(self.treeview.expandAll)


        self.treeHbl = QHBoxLayout()
        self.treeHbl.setContentsMargins(2, 0, 2, 0)
        lab = VerticalLabel('Project Dictionary/JSON Tree View')
        lab.setObjectName('label_treeview')
        self.treeHbl.addWidget(lab)

        spcr = QWidget()
        spcr.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self.btnCollapseAll)
        hbl.addWidget(self.btnExpandAll)
        hbl.addWidget(spcr)
        btns = QWidget()
        btns.setMaximumHeight(22)
        btns.setLayout(hbl)

        w = QWidget()
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.treeview)
        vbl.addWidget(btns)

        w.setLayout(vbl)
        self.treeHbl.addWidget(w)
        self._wdg_treeview.setLayout(self.treeHbl)


    def updatePlotThumbnail(self):
        pixmap = QPixmap(cfg.data.thumbnail())
        pixmap = pixmap.scaledToHeight(160)
        self._thumbnail_src.setPixmap(pixmap)
        self.source_thumb_and_label.show()
        if cfg.data.is_aligned_and_generated():
            pixmap = QPixmap(cfg.data.thumbnail_aligned())
            pixmap = pixmap.scaledToHeight(160)
            self._thumbnail_aligned.setPixmap(pixmap)
            self.aligned_thumb_and_label.show()
        else:
            self.aligned_thumb_and_label.hide()


    def initUI_plot(self):
        '''SNR Plot Widget'''
        logger.info('')
        font = QFont()
        font.setBold(True)
        self.snr_plot = SnrPlot()
        lab_yaxis = VerticalLabel('Signal-to-Noise Ratio', font_color='#f3f6fb', font_size=14)
        lab_yaxis.setFixedWidth(18)
        hbl = QHBoxLayout()
        hbl.addWidget(lab_yaxis)
        self._plot_Yaxis = QWidget()
        self._plot_Yaxis.setLayout(hbl)
        self._plot_Yaxis.setContentsMargins(0, 0, 0, 0)
        self._plot_Yaxis.setFixedWidth(26)
        lab_yaxis.setFont(font)
        hbl = QHBoxLayout()
        hbl.setContentsMargins(0, 0, 0, 0)
        hbl.addWidget(self._plot_Yaxis)
        hbl.addWidget(self.snr_plot)
        # self.snr_plot_widget = QWidget()
        # self.snr_plot_widget.setObjectName('snr_plot_widget')
        self._plot_Xaxis = QLabel('Serial Section #')
        self._plot_Xaxis.setStyleSheet('color: #f3f6fb; font-size: 14px;')
        self._plot_Xaxis.setContentsMargins(0, 0, 0, 8)
        self._plot_Xaxis.setFont(font)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addLayout(hbl)
        vbl.addWidget(self._plot_Xaxis, alignment=Qt.AlignmentFlag.AlignHCenter)

        w1 = QWidget()
        w1.setLayout(vbl)

        self._thumbnail_src = QLabel()
        self._thumbnail_aligned = QLabel()

        style = '''font-size: 14px; color: #f3f6fb; font-weight: 500;'''

        self._lab_source_thumb = QLabel('Source:')
        self._lab_source_thumb.setFixedHeight(16)
        self._lab_source_thumb.setStyleSheet(style)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self._lab_source_thumb)
        vbl.addWidget(self._thumbnail_src, alignment=Qt.AlignmentFlag.AlignTop)
        self.source_thumb_and_label = QWidget()
        self.source_thumb_and_label.setLayout(vbl)

        self._lab_aligned_thumb = QLabel('Aligned:')
        self._lab_aligned_thumb.setFixedHeight(16)
        self._lab_aligned_thumb.setStyleSheet(style)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self._lab_aligned_thumb)
        vbl.addWidget(self._thumbnail_aligned, alignment=Qt.AlignmentFlag.AlignTop)
        self.aligned_thumb_and_label = QWidget()
        self.aligned_thumb_and_label.setLayout(vbl)

        self.source_thumb_and_label.hide()
        self.aligned_thumb_and_label.hide()

        gl = QGridLayout()
        gl.setContentsMargins(4, 4, 4, 4)
        gl.setRowStretch(0, 1)
        gl.setRowStretch(1, 1)
        gl.setColumnStretch(0, 1)
        gl.addWidget(self.source_thumb_and_label, 0, 0)
        gl.addWidget(self.aligned_thumb_and_label, 1, 0)
        w2 = QWidget()
        w2.setLayout(gl)
        self.snr_plot_widget = QSplitter(Qt.Orientation.Horizontal)
        # self.snr_plot_widget.setStyleSheet('background-color: #1b1e23;')
        # self.snr_plot_widget.setObjectName('snr_plot_widget')



        self.snr_plot_widget.addWidget(w1)
        self.snr_plot_widget.addWidget(w2)
        # self.snr_plot_widget.addWidget(w3)



    def initUI_tab_widget(self):
        '''Tab Widget'''
        logger.info('')
        self._tabs = QTabWidget()
        self._tabs.setStyleSheet('QTabBar::tab { height: 22px; width: 84px; }')
        self._tabs.setDocumentMode(True)
        self._tabs.setTabsClosable(True)
        self._tabs.setObjectName('project_tabs')
        self._tabs.addTab(self.ng_browser_container_outer, ' 3DEM ')
        self._tabs.addTab(self.table_container, ' Table ')
        self._tabs.setTabToolTip(1, os.path.basename(cfg.data.dest()))
        # self._tabs.addTab(self._wdg_treeview, ' Tree ')
        self._tabs.addTab(self._wdg_treeview, ' Data ')
        self._tabs.addTab(self.snr_plot_widget, ' SNR Plot ')
        self._tabs.tabBar().setTabButton(0, QTabBar.RightSide, None)
        self._tabs.tabBar().setTabButton(1, QTabBar.RightSide, None)
        self._tabs.tabBar().setTabButton(2, QTabBar.RightSide, None)
        self._tabs.tabBar().setTabButton(3, QTabBar.RightSide, None)
        self._tabs.tabBar().setTabButton(0, QTabBar.LeftSide, None)
        self._tabs.tabBar().setTabButton(1, QTabBar.LeftSide, None)
        self._tabs.tabBar().setTabButton(2, QTabBar.LeftSide, None)
        self._tabs.tabBar().setTabButton(3, QTabBar.LeftSide, None)
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self._tabs)
        self.setLayout(vbl)


    def paintEvent(self, pe):
        '''Enables widget to be style-ized'''
        opt = QStyleOption()
        opt.initFrom(self)
        p = QPainter(self)
        s = self.style()
        s.drawPrimitive(QStyle.PE_Widget, opt, p, self)

    def sizeHint(self):
        return QSize(1000,1000)


class Thumbnail(QWidget):

    def __init__(self, parent, path):
        super().__init__(parent)
        thumbnail = ScaledPixmapLabel(self)
        pixmap = QPixmap(path)
        thumbnail.setPixmap(pixmap)
        thumbnail.setScaledContents(True)
        layout = QGridLayout()
        layout.setContentsMargins(1, 1, 1, 1)
        layout.addWidget(thumbnail, 0, 0)
        self.setLayout(layout)


class ScaledPixmapLabel(QLabel):
    def __init__(self, parent):
        super().__init__(parent)
        self.setScaledContents(True)

    def paintEvent(self, event):
        if self.pixmap():
            pm = self.pixmap()
            try:
                originalRatio = pm.width() / pm.height()
                currentRatio = self.width() / self.height()
                if originalRatio != currentRatio:
                    qp = QPainter(self)
                    pm = self.pixmap().scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    rect = QRect(0, 0, pm.width(), pm.height())
                    rect.moveCenter(self.rect().center())
                    qp.drawPixmap(rect, pm)
                    return
            except ZeroDivisionError:
                pass
                # logger.warning('Cannot divide by zero')
                # print_exception()
        super().paintEvent(event)



class VerticalLabel(QLabel):

    def __init__(self, text, bg_color=None, font_color=None, font_size=None, *args):
        QLabel.__init__(self, text, *args)

        self.text = text
        self.setStyleSheet("font-size: 12px;")
        font = QFont()
        font.setBold(True)
        self.setFont(font)
        style = ''
        if bg_color:
            style += f'background-color: {bg_color};'
        if font_color:
            style += f'color: {font_color};'
        if font_size:
            style += f'font-size: {str(font_size)};'
        if style != '':
            self.setStyleSheet(style)

    def setText(self, p_str):
        self.text = p_str

    def paintEvent(self, event):
        p = QPainter(self)
        p.rotate(-90)
        rgn = QRect(-self.height(), 0, self.height(), self.width())
        align  = Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignHCenter
        # align  = Qt.AlignmentFlag.AlignCenter
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            self.hint = p.drawText(rgn, align, self.text)
        p.end()
        self.setMaximumWidth(self.hint.height())
        self.setMinimumHeight(self.hint.width())


    def sizeHint(self):
        if hasattr(self, 'hint'):
            return QSize(self.hint.height(), self.hint.width() + 10)
        else:
            return QSize(10, 48)


    def minimumSizeHint(self):
        size = QLabel.minimumSizeHint(self)
        return QSize(size.height(), size.width())


class ClickLabel(QLabel):
    clicked=Signal()

    def mousePressEvent(self, ev):
        self.clicked.emit()
__all__ = ['ZarrTab']

log = logging.getLogger(__name__)

class ZarrTab(QWidget):

    def __init__(self, parent, path):
        super().__init__(parent)
        log.info('')
        self.parent = parent
        self.path = path
        self.viewer = cfg.emViewer = ZarrViewer(path=path)
        self.webengine = QWebEngineView()
        self.load()


        with open(os.path.join(path, '.zarray')) as j:
            self.zarray = json.load(j)
        self.shape      = self.zarray['shape']
        self.chunkshape = self.zarray['chunks']
        self.zdim       = self.shape[0]

        cfg.main_window._sectionSlider.setRange(0, self.zdim - 1)
        cfg.main_window._jumpToLineedit.setText('0')
        # cfg.main_window.comboboxNgLayout.setCurrentText('4panel')

        self.initUI()

    def load(self):
        self.webengine.setUrl(QUrl(self.viewer.url()))

    def initUI(self):
        vbl = QVBoxLayout()
        vbl.setContentsMargins(0, 0, 0, 0)
        vbl.addWidget(self.webengine)
        self.setLayout(vbl)

logger = logging.getLogger(__name__)


class SnrThumbnail(QWidget):

    def __init__(self, parent=None, path='', snr=0.0):
        super().__init__(parent)
        # thumbnail = QLabel(self)
        self.path = path
        self.snr = snr
        self.thumbnail = CorrSignalThumbnail(self)
        self.thumbnail.setScaledContents(True)
        self.label = QLabel('%.3f' % self.snr)
        self.label.setStyleSheet('color: #ff0000')
        self.no_image_path = os.path.join(get_appdir(), 'resources', 'no-image.png')
        # layout = QGridLayout()
        # layout.setContentsMargins(1, 1, 1, 1)
        # layout.addWidget(self.thumbnail, 0, 0)
        # layout.addWidget(self.label, 0, 0, alignment=Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignBottom)
        # self.setLayout(layout)

        if path:
            self.set_data(path=self.path, snr=self.snr)

    def set_data(self, path, snr):
        self.path = path
        self.snr = snr
        self.thumbnail.snr = snr
        try:
            self.thumbnail.setPixmap(QPixmap(self.path))
            # self.label.setText('%.3f' % self.snr)
        except:
            print_exception()
            logger.warning(f'WARNING path={self.path}, label={self.snr}')

    def set_no_image(self):
        try:
            self.thumbnail.setPixmap(QPixmap(self.no_image_path))
            self.label.setText('')
        except:
            print_exception()
            logger.warning(f'WARNING path={self.no_image_path}, label={self.snr}')

    # def sizeHint(self):
    #     return QSize(200, 200)


class Thumbnail(QWidget):

    def __init__(self, parent, path):
        super().__init__(parent)
        self.thumbnail = CorrSignalThumbnail(self)
        self.pixmap = QPixmap(path)
        self.thumbnail.setPixmap(self.pixmap)
        self.thumbnail.setScaledContents(True)
        self.layout = QGridLayout()
        self.layout.setContentsMargins(1, 1, 1, 1)
        self.layout.addWidget(self.thumbnail, 0, 0)
        self.setLayout(self.layout)



class ThumbnailFast(QLabel):
    def __init__(self, parent, path, extra=''):
        super().__init__(parent)
        self.setScaledContents(True)
        self.path = path
        self.setPixmap(QPixmap(self.path))
        self.extra = extra
        # self.no_image_path = os.path.join(get_appdir(), 'resources', 'no-image.png')
        # self.repaint()

    def paintEvent(self, event):
        if self.pixmap():
            try:
                pm = self.pixmap()
                originalRatio = pm.width() / pm.height()
                currentRatio = self.width() / self.height()
                if originalRatio != currentRatio:
                    qp = QPainter(self)
                    pm = self.pixmap().scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    self.r = rect = QRect(0, 0, pm.width(), pm.height())
                    rect.moveBottomLeft(self.rect().bottomLeft())
                    qp.drawPixmap(rect, pm)

                    if self.extra:
                        qp.setPen(QColor('#ede9e8'))
                        loc = QPoint(0, self.rect().height() - 4)
                        if self.extra:
                            qp.drawText(loc, self.extra)
                    return
            except ZeroDivisionError:
                # logger.warning('Cannot divide by zero')
                # print_exception()
                pass
        super().paintEvent(event)




class CorrSignalThumbnail(QLabel):
    def __init__(self, parent, path='', snr='', extra=''):
        super().__init__(parent)
        self.setScaledContents(True)
        self.path = path
        if self.path:
            self.setPixmap(QPixmap(self.path))
        self.snr = snr
        self.extra = extra
        self.no_image_path = os.path.join(get_appdir(), 'resources', 'no-image.png')

    def paintEvent(self, event):
        if self.pixmap():
            try:
                # originalRatio = pm.width() / pm.height()
                # currentRatio = self.width() / self.height()
                # if originalRatio != currentRatio:
                qp = QPainter(self)
                pm = self.pixmap().scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                self.r = rect = QRect(0, 0, pm.width(), pm.height())
                rect.moveBottomLeft(self.rect().bottomLeft())
                qp.drawPixmap(rect, pm)
                qp.setPen(QColor('#ff0000'))
                if self.snr:
                    loc = QPoint(0, self.rect().height() - 4)
                    if self.extra:
                        qp.drawText(loc, '%.3f' %self.snr + '\n' + self.extra)
                    else:
                        qp.drawText(loc, '%.3f' %self.snr)
                return
            except ZeroDivisionError:
                # logger.warning('Cannot divide by zero')
                # print_exception()
                pass
        super().paintEvent(event)


    def set_data(self, path, snr):
        self.path = path
        self.snr = snr
        try:
            self.setPixmap(QPixmap(self.path))
            # self.label.setText('%.3f' % self.snr)
        except:
            print_exception()
            logger.warning(f'WARNING path={self.path}, label={self.snr}')

    def set_no_image(self):
        try:
            self.setPixmap(QPixmap(self.no_image_path))
        except:
            print_exception()
            logger.warning(f'WARNING path={self.no_image_path}, label={self.snr}')
__all__ = ['ToggleSwitch']

logger = logging.getLogger(__name__)

class ToggleSwitch(QCheckBox):
    _transparent_pen = QPen(QColor('transparent'))
    _light_grey_pen = QPen(QColor('lightgrey'))
    _black_pen = QPen(QColor('black'))
    _almost_black_color = QColor('#070D0D')
    _almost_black_pen = QPen(_almost_black_color)
    _grey_pen = QPen(QColor('grey'))
    _snow_color = QColor('#F3F6FB')
    _snow_pen = QPen(_snow_color)
    _green_pen = QPen(QColor('#00ff00'))
    _green_color = '#588A0E' #darker green
    _black_charcoal_color = QColor('#212121')
    _black_color = QColor('#000000')
    _border_color_pen = QPen(QColor('#171d22;'))
    _red_color = QColor('#D61529') # deeper red
    _red_pen = QPen(_red_color) # deeper red
    def __init__(self,
                 parent=None,
                 bar_color=QColor(_red_color),
                 checked_color=_green_color,
                 handle_color=_snow_color, # handle; off
                 h_scale=.7,
                 v_scale=1,
                 fontSize=13):

        super().__init__(parent)
        self.setFocusPolicy(Qt.FocusPolicy.NoFocus)  # focus don't steal focus from zoompanwidget
        self._bar_brush = QBrush(bar_color)
        self._bar_checked_brush = QBrush(QColor(checked_color).lighter())
        self._handle_brush = QBrush(handle_color)
        self._handle_checked_brush = QBrush(QColor("white")) # handle, off
        self.setContentsMargins(0, 0, 4, 0)
        self._handle_position = 0
        self._h_scale = h_scale
        self._v_scale = v_scale
        self._fontSize = fontSize
        self.stateChanged.connect(self.handle_state_change)
        self._fixed_height = 52 #horizontal
        self._fixed_width = 32 #vertical
        self.setFixedWidth(self._fixed_height)
        self.setFixedHeight(self._fixed_width)

    def __str__(self):
        return str(self.__class__) + '\n' + '\n'.join(
            ('{} = {}'.format(item, self.__dict__[item]) for item in self.__dict__))

    def sizeHint(self):
        return QSize(self._fixed_height, self._fixed_width)

    def hitButton(self, pos: QPoint):
        return self.contentsRect().contains(pos)

    def paintEvent(self, e: QPaintEvent):

        contRect = self.contentsRect() #0610 #TypeError: moveCenter(self, QPointF): argument 1 has unexpected type 'QPoint'
        # contRect = QPointF(self.contentsRect()) #0613
        self.width = contRect.width() * self._h_scale
        self.height = contRect.height() * self._v_scale
        self.handle_radius = round(0.16 * self.height)
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing) #0610 #0628 re-uncommenting
        p.setPen(self._snow_pen) # Border around background area
        barRect = QRectF(0, 0, self.width - self.handle_radius, 0.42 * self.height)
        barRect.moveCenter(QPointF(contRect.center())) #pyqt6 fix
        rounding = barRect.height() / 2
        # the handle will move along this line
        adjust_trail = -6
        self.trailLength = contRect.width() * self._h_scale - 2 * self.handle_radius + adjust_trail
        self.xLeft = int(contRect.center().x() - (self.trailLength + self.handle_radius) / 2)
        self.xPos = self.xLeft + self.handle_radius + self.trailLength * self._handle_position

        if self.isChecked():
            p.setBrush(self._bar_checked_brush)
            p.drawRoundedRect(barRect, rounding, rounding)
            '''TEXT, ON'''
            p.setPen(self._snow_pen)
            p.setBrush(self._handle_checked_brush)
            font = QFont("PT Sans", self._fontSize)
            p.setFont(font)
            p.setFont(QFont('Helvetica', self._fontSize, 95))
            adjust_x = -1
            adjust_y = 4 # higher adjust is lower text
            p.drawText(int(self.xLeft + self.handle_radius / 2 + adjust_x), int(contRect.center().y() + adjust_y), "✓")

        else:
            p.setBrush(self._bar_brush)
            p.drawRoundedRect(barRect, rounding, rounding)
            p.setPen(self._snow_pen)
            p.setBrush(self._handle_brush)
            font = QFont("PT Sans", self._fontSize)
            p.setFont(font)
            p.setFont(QFont('Helvetica', self._fontSize, 95))
            adjust_y = 4
            adjust_x = -2
            p.drawText(int(contRect.center().x() + adjust_x), int(contRect.center().y() + adjust_y), " ×")

        p.setPen(self._transparent_pen)
        p.drawEllipse(QPointF(self.xPos, barRect.center().y()), self.handle_radius, self.handle_radius)
        p.end()

    @Slot(int)
    def handle_state_change(self, value):
        '''Position of Handle; orig= 1 or 0'''
        self._handle_position = .8 if value else 0

    def setH_scale(self, value):
        self._h_scale = value
        self.update()

    def setV_scale(self, value):
        self._v_scale = value
        self.update()

    def setFontSize(self, value):
        self._fontSize = value
        self.update()
class WebEnginePage(QWebEnginePage):
    """ Custom WebEnginePage to customize how we handle link navigation """
    # Store external windows.
    external_window = None

    def acceptNavigationRequest(self, url, _type, isMainFrame):
        print(url, _type, isMainFrame)
        if _type == QWebEnginePage.NavigationTypeLinkClicked:
            if not self.external_window:
                self.external_window = QWebEngineView()

            self.external_window.setUrl(url)
            self.external_window.show()
            return False

        return super().acceptNavigationRequest(url, _type, isMainFrame)


class WebPage(QMainWindow):
    def __init__(self, url=None, *args, **kwargs):
        super(WebPage, self).__init__(*args, **kwargs)

        self.webengineview = QWebEngineView()
        self.webengineview.setPage(WebEnginePage())
        self.setCentralWidget(self.webengineview)

        if url:
            self.setUrl(url)
            self.show()

    def setUrl(self, url):
        self.webengineview.setUrl(QUrl(url))
        self.show()

    def sizeHint(self):
        return QSize(1024, 768)
logger = logging.getLogger(__name__)

class WidgetArea(QWidget):

    def __init__(self,
                 parent=None,
                 name=None,
                 title=None,
                 labels=(),
                 *args, **kwargs):
        QWidget.__init__(self, *args, **kwargs)
        self.parent=parent
        self.name = name
        self.setObjectName(('defaultWidgetArea', name)[isinstance(name, str)])
        if title:
            self._title = QLabel(('Widget Area', title)[isinstance(title, str)])
            self._title.setObjectName('cp_title')
            self._title.setStyleSheet('font-size: 10px; '
                                      'font-weight: 500;')
        else:
            self._title = None

        self.setContentsMargins(0, 0, 0, 0)

        self._labels = list(labels)
        self._style = ''
        # self.addStyle(f'QLabel#title{{font-size: 10px; font-weight: 750;}}')
        self.updateLayout()
        self.updateStyle()

        # self.setSizePolicy(
        #     QSizePolicy.MinimumExpanding,
        #     QSizePolicy.MinimumExpanding
        # )

    def hideTitle(self):
        self._title.hide()

    def setTitleStyle(self, style=None):
        self._title.setStyleSheet(style)

    def addLabels(self, items):
        for item in items:
            self._appendLabel(item)
        self.updateLayout()

    def setLabels(self, items, names=None):
        self._labels = []
        self.addLabels(items)

    def _appendLabel(self, item):
        self._labels.append(item)

    def updateLayout(self):
        # self._layout = QVBoxLayout()
        # self._layout.setContentsMargins(0, 0, 0, 0)
        # self._layout.setSpacing(0)
        #
        # self._form = QFormLayout()
        # self._form.setVerticalSpacing(1)
        # self._form.setRowWrapPolicy(QFormLayout.WrapAllRows)
        #
        # self._gb = QGroupBox()
        # self._gb.setContentsMargins(0, 0, 0, 0)
        # # self._gb.setLayout(self._form)
        # self._gb.setLayout(self._layout)
        # self._scroll = QScrollArea()
        # self._scroll.setContentsMargins(0, 0, 0, 0)
        # # self._scroll.setWidget(self._gb)
        # self._scroll.setLayout(self._layout)
        # self._scroll.setWidgetResizable(True)
        # if self._title:
        #     self._layout.addWidget(self._title)
        # self._layout.addWidget(self._scroll)
        # for lb in self._labels:
        #     self._form.addRow(lb)
        # self.setLayout(self._layout)

        self._layout = QVBoxLayout()
        self._layout.setContentsMargins(0, 0, 0, 0)
        self._layout.setSpacing(4)
        self._form = QFormLayout()
        self._form.setContentsMargins(0,0,0,0)
        self._form.setVerticalSpacing(3)
        # self._gb = QGroupBox('AlignEM-SWiFT')
        self._gb = QGroupBox()
        self._gb.setLayout(self._form)
        self._gb.setContentsMargins(0,0,0,0)
        self._scroll = QScrollArea()
        self._scroll.setWidget(self._gb)
        self._scroll.setWidgetResizable(True)
        self._layout.addWidget(self._title)
        self._layout.addWidget(self._scroll)
        for lb in self._labels:
            self._form.addRow(lb)
        self.setLayout(self._layout)

    def addStyle(self, style:str):
        self._style += style

    def updateStyle(self):
        self.setStyleSheet(self._style)

    def sizeHint(self):
        return QSize(80,50)
class CustomFormatter(logging.Formatter):

    grey = "\x1b[38;20m"
    yellow = "\x1b[33;20m"
    red = "\x1b[31;20m"
    bold_red = "\x1b[31;1m"
    # blue = "\x1b[1;34m"
    reset = "\x1b[0m"
    format = '%(asctime)s %(levelname)s [%(module)s.%(funcName)s:%(lineno)d] %(message)s'
    format2 = '%(asctime)s [%(module)s.%(funcName)s:%(lineno)d] %(message)s'
    FORMATS = {
        logging.DEBUG: grey + format + reset,
        logging.INFO: grey + format + reset,
        logging.WARNING: yellow + format + reset,
        logging.ERROR: red + format + reset,
        logging.CRITICAL: bold_red + format2 + reset,
    }
    def format(self, record):
        log_fmt = self.FORMATS.get(record.levelno)
        formatter = logging.Formatter(log_fmt, datefmt='%H:%M:%S')
        return formatter.format(record)


def main():
    logger = logging.getLogger()
    # logger = logging.getLogger(__name__)
    # logging.propagate = False  # stops message propogation to the root handler
    # fh = logging.FileHandler('messages.log')
    # logger.addHandler(fh)
    logger.info('Running ' + __file__ + '.__main__()')
    check_for_binaries()
    addLoggingLevel('VERSIONCHECK', logging.DEBUG + 5)
    logging.getLogger('init').setLevel("VERSIONCHECK")
    logging.getLogger('init').versioncheck('QtCore.__version__ = %s' % QtCore.__version__)
    logging.getLogger('init').versioncheck('qtpy.PYQT_VERSION = %s' % qtpy.PYQT_VERSION)
    logging.getLogger('init').versioncheck('qtpy.PYSIDE_VERSION = %s' % qtpy.PYSIDE_VERSION)


    parser = argparse.ArgumentParser()
    parser.add_argument('--api', default='pyqt5', help='Python-Qt API (pyqt6|pyqt5|pyside6|pyside2)')
    parser.add_argument('--debug', action='store_true', help='Debug Mode')
    parser.add_argument('--debug_mp', action='store_true', help='Set python multiprocessing debug level to DEBUG')
    parser.add_argument('--loglevel', type=int, default=cfg.LOG_LEVEL, help='Logging Level (1-5)')
    # parser.add_argument('--no_tensorstore', action='store_true', help='Does not use Tensorstore if True')
    parser.add_argument('--headless', action='store_true', help='Do not embed the neuroglancer browser if True')
    parser.add_argument('--no_splash', action='store_true', help='Do not start up with a splash screen')
    parser.add_argument('--dummy', action='store_true', help='Start the application using a dummy project')
    parser.add_argument('--profile', action='store_true', help='Profile performance of memory and multiprocessing')
    args = parser.parse_args()
    os.environ['QT_API'] = args.api  # This env setting is ingested by qtpy
    # os.environ['PYQTGRAPH_QT_LIB'] = args.api #do not set!

    if logger.hasHandlers():  logger.handlers.clear() #orig
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)
    ch.setFormatter(CustomFormatter())
    logger.addHandler(ch)

    LOGLEVELS = [logging.DEBUG, logging.INFO, logging.WARNING, logging.ERROR, logging.CRITICAL]
    if args.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(LOGLEVELS[args.loglevel])
    if args.debug_mp:
        cfg.DEBUG_MP = True
    # if args.no_tensorstore: cfg.USE_TENSORSTORE = False
    if args.headless:  cfg.HEADLESS = True
    if args.no_splash: cfg.NO_SPLASH = True
    if args.dummy: cfg.DUMMY = True
    if args.profile:
        cfg.PROFILING_MODE = True


    # https://doc.qt.io/qtforpython-5/PySide2/QtCore/Qt.html
    QCoreApplication.setAttribute(Qt.AA_UseOpenGLES)
    # Forces the usage of OpenGL ES 2.0 or higher on platforms that
    # use dynamic loading of the OpenGL implementation.

    if cfg.FAULT_HANDLER:
        faulthandler.enable(file=sys.stderr, all_threads=True)

    if cfg.PROFILING_MODE:
        sys.setprofile(tracefunc)

    # os.environ['MESA_GL_VERSION_OVERRIDE'] = '4.5'
    # logger.info('Setting OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES')
    # logger.info('Setting QTWEBENGINE_CHROMIUM_FLAGS')
    # os.environ['OBJC_DISABLE_INITIALIZE_FORK_SAFETY'] = 'YES'
    # os.environ['QTWEBENGINE_CHROMIUM_FLAGS'] = '--disable-web-security'

    # ***************
    # os.environ['QTWEBENGINE_CHROMIUM_FLAGS'] = '--no-sandbox -disable-web-security --enable-logging'
    # ***************

    # os.environ['QTWEBENGINE_CHROMIUM_FLAGS'] = '--enable-logging --log-level=3' # suppress JS warnings
    # os.environ['QTWEBENGINE_CHROMIUM_FLAGS'] = '--disable-web-security --enable-logging --log-level=0'
    # os.environ['OPENBLAS_NUM_THREADS'] = '1'
    # os.environ['QTWEBENGINE_REMOTE_DEBUGGING'] = '9000'

    if qtpy.QT5:
        logger.info('Setting Qt.AA_EnableHighDpiScaling')
        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
        logger.info('Setting Qt.AA_UseHighDpiPixmaps')
        QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)

    # 2230-
    # logger.info('Setting Qt.AA_ShareOpenGLContexts')
    # QCoreApplication.setAttribute(Qt.AA_ShareOpenGLContexts) # must be set before QCoreApplication is created. #2230-
    # QApplication.setAttribute(Qt.ApplicationAttribute.AA_UseDesktopOpenGL)

    initialize_user_preferences()
    configure_project_paths()

    app = QApplication([])
    app.setStyle('Fusion')
    cfg.main_window = MainWindow()

    logger.info('Showing AlignEM-SWiFT...')
    cfg.main_window.show()

    sys.exit(app.exec())
class WorkerSignals(QObject):
    '''
    Defines the signals available from a running worker thread.
    Supported signals are:

    finished - No datamodel
    error - tuple (exctype, value, traceback.format_exc() )
    result - object datamodel returned from processing, anything
    progress - int indicating % progress
    '''

    # https://stackoverflow.com/questions/29007619/python-typeerror-pickling-an-authenticationstring-object-is-disallowed-for-sec
    def __getstate__(self):
        """called when pickling - this hack allows subprocesses to
           be spawned without the AuthenticationString raising an error"""
        state = self.__dict__.copy()
        conf = state['_config']
        if 'authkey' in conf:
            del conf['authkey']
            conf['authkey'] = bytes(conf['authkey'])
        return state

    finished = Signal()
    error = Signal(tuple)
    result = Signal(object)
    progress = Signal(int, name='progressSignal')


class BackgroundWorker(QRunnable):
    '''
    BackgroundWorker thread
    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.
    :param callback: The function callback to run on this worker thread. Supplied args and kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    Doc:
    QThreadPool manages and recyles individual QThread objects to help reduce thread creation costs in
    programs that use threads. Each src application has one global QThreadPool object, which can be
    accessed by calling globalInstance() .

    To use one of the QThreadPool threads, subclass QRunnable and implement the run() virtual function.
    Then create an object of that class and pass it to start() .

    QThreadPool deletes the QRunnable automatically by default.

    QThreadPool supports executing the same QRunnable more than once by calling tryStart (this) from within run()

    Note that QThreadPool is a low-level class for managing threads, see the src Concurrent module
    for higher level alternatives.

    '''

    def __init__(self, fn, *args, **kwargs):
        super(BackgroundWorker, self).__init__()
        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()
        self.signals.progress.__hash__()
        self.signals.progress.__str__()
        '''If 'progress_callback' is provided as a parameter of the function passed into BackgroundWorker, it will be assigned
        the value -> self.signals.progress'''
        self.kwargs['progress_callback'] = self.signals.progress

    @Slot()
    def run(self):
        logger.info("Running A Background Worker...")
        # if self.status != None:
        #     self.parent.set_status(self.status)
        #     # QApplication.processEvents()
        # else:
        #     logger.critical('self.status equals None')
        cfg.main_window._working = True
        # cfg.main_window.pbar.show()

        try:
            result = self.fn(*self.args, **self.kwargs)
        except:
            #Todo look into why this exception gets triggered

            # logger.info('BackgroundWorker.run traceback:')
            # traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            cfg.main_window._working = False
            self.signals.finished.emit()
__all__ = ['compute_affines']

logger = logging.getLogger(__name__)

def compute_affines(scale, start=0, end=None):
    '''Compute the python_swiftir transformation matrices for the current s stack of images according to Recipe1.'''
    scale_val = get_scale_val(scale)
    cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
    pbar_text = 'Computing Scale %d Transforms w/ SWIM (%d Cores)...' % (scale_val, cpus)
    if cfg.CancelProcesses:
        cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
    else:
        logger.critical('Computing Affines...')

        dm = cfg.data

        # if ng.is_server_running():
        #     logger.info('Stopping Neuroglancer...')
        #     ng.server.stop()

        rename_switch = False
        alignment_dict = dm['data']['scales'][scale]['alignment_stack']

        alignment_option = dm['data']['scales'][scale]['method_data']['alignment_option']
        logger.info('Start Layer: %s / # Layers: %s' % (str(start), str(end)))

        # path = os.path.join(dm.dest(), scale, 'img_aligned')
        # if checkForTiffs(path):
        #     # al_substack = dm['data']['scales'][scale]['alignment_stack'][start:]
        #     # remove_aligned(al_substack) #0903 Moved into conditional
        #     dm.remove_aligned(scale, start, end)

        corr_spots_dir = os.path.join(dm.dest(), scale, 'corr_spots')
        if not os.path.exists(corr_spots_dir):
            os.mkdir(corr_spots_dir)

        dm.clear_method_results(scale=scale, start=start, end=end) #1109 Should this be on the copy?
        if rename_switch:
            rename_layers(use_scale=scale, al_dict=alignment_dict)

        dm_ = copy.deepcopy(dm) # Copy the datamodel previewmodel for this datamodel to add local fields for SWiFT
        alstack = dm_['data']['scales'][scale]['alignment_stack']
        substack = alstack[start:end]
        n_tasks = n_skips = 0
        for layer in substack: # Operating on the Copy!
            # # layer['align_to_ref_method']['method_data']['bias_x_per_image'] = 0.0
            # # layer['align_to_ref_method']['method_data']['bias_y_per_image'] = 0.0
            # layer['align_to_ref_method']['selected_method'] = 'Auto Swim Align'
            if not layer['skipped']: n_tasks +=1
            else:                    n_skips +=1
        logger.info('# Sections (total)         : %d' % len(dm))
        logger.info('# Tasks (excluding skips)  : %d' % n_tasks)
        logger.info('# Skipped Layers           : %d' % n_skips)
        temp_file = os.path.join(dm.dest(), "temp_project_file.json")
        with open(temp_file, 'w') as f:
            f.write(dm.to_json())

        task_queue = TaskQueue(n_tasks=n_tasks, parent=cfg.main_window, pbar_text=pbar_text)

        # START TASK QUEUE
        task_queue.start(cpus)
        align_job = os.path.join(os.path.split(os.path.realpath(__file__))[0], 'job_single_alignment.py')

        # ADD ALIGNMENT TASKS TO QUEUE
        for layer in substack:
            index = alstack.index(layer)
            if not layer['skipped']:
                task_args = [sys.executable,
                             align_job,            # Python program to run (single_alignment_job)
                             temp_file,            # Temp project file name
                             alignment_option,     # Init, Refine, or Apply
                             str(scale_val),       # Scale to use or 0
                             str(cfg.CODE_MODE),   # Python or C mode
                             str(index),           # First l number to run from Project file #ATTN!
                             str(1),               # Number of layers to run                 #ATTN!
                             str(cfg.USE_FILE_IO)  # Use File IO instead of Pipe
                             ]
                # if index == 5:
                #     task_args[3] = 'bogus_align'
                # if index == 8:
                #     task_args[1] = 'bogus_script.py'
                task_queue.add_task(task_args)
                if cfg.PRINT_EXAMPLE_ARGS:
                    if index in range(start, start + 3):
                        e = [str(p) for p in task_args] # example
                        logger.info("Layer #%d (example):\n%s\n%s\n%s\n%s" % (index, e[0],e[1],e[2]," ".join(e[3::])))

        # task_queue.work_q.join()
        # cfg.main_window.hud.post('Computing Alignment Using SWIM...')
        dt = task_queue.collect_results()
        dm.set_t_align(dt, s=scale)

        if cfg.CancelProcesses:
            return

        # Sort the tasks by layers rather than by process IDs
        task_dict = {}
        for k in task_queue.task_dict.keys():
            t = task_queue.task_dict[k]
            task_dict[int(t['args'][5])] = t

        task_list = [task_dict[k] for k in sorted(task_dict.keys())]
        updated_model = copy.deepcopy(dm) # Integrate output of each task into a new combined datamodel previewmodel

        for tnum in range(len(task_list)):

            if cfg.USE_FILE_IO:
                # Get the updated datamodel previewmodel from the file written by single_alignment_job
                output_dir = os.path.join(os.path.split(temp_file)[0], scale)
                output_file = "single_alignment_out_" + str(tnum) + ".json"
                with open(os.path.join(output_dir, output_file), 'r') as f:
                    dm_text = f.read()

            else:
                # Get the updated datamodel previewmodel from stdout for the task
                parts = task_list[tnum]['stdout'].split('---JSON-DELIMITER---')
                dm_text = None
                for p in parts:
                    ps = p.strip()
                    if ps.startswith('{') and ps.endswith('}'):
                        dm_text = p

            if dm_text != None:
                # This gets run normally...

                results_dict = json.loads(dm_text)
                fdm_new = results_dict['data_model']

                # Get the same s from both the old and new datamodel models
                al_stack_old = updated_model['data']['scales'][scale]['alignment_stack']
                al_stack_new = fdm_new['data']['scales'][scale]['alignment_stack']
                layer_index = int(task_list[tnum]['args'][5]) # may differ from tnum!
                al_stack_old[layer_index] = al_stack_new[layer_index]
                if task_list[tnum]['statusBar'] == 'task_error':
                    ref_fn = al_stack_old[layer_index]['reference']
                    base_fn = al_stack_old[layer_index]['filename']
                    cfg.main_window.hud.post('Alignment Task Error at: ' +
                                             str(task_list[tnum]['cmd']) + " " +
                                             str(task_list[tnum]['args']))
                    cfg.main_window.hud.post('Automatically Skipping Layer %d' % (layer_index), logging.WARNING)
                    cfg.main_window.hud.post(f'  ref img: %s\nbase img: %s' % (ref_fn,base_fn))
                    al_stack_old[layer_index]['skipped'] = True
                need_to_write_json = results_dict['need_to_write_json']  # It's not clear how this should be used (many to one)

        cfg.data = updated_model #0809-
        write_run_to_file(dm)

        # logger.info('Collating Correlation Spot Images...')
        # job_script = os.path.join(os.path.split(os.path.realpath(__file__))[0], 'job_collate_spots.py')
        # task_queue = TaskQueue(n_tasks=len(substack),
        #                        parent=cfg.main_window,
        #                        pbar_text='Collating Scale %s Correlation Spot Images...' % (scale_val))
        # task_queue.start(cpus)
        #
        # for i, layer in enumerate(substack):
        #     if layer['skipped']:
        #         continue
        #     fn = os.path.basename(layer['images']['base']['filename'])
        #     out = os.path.join(corr_spots_dir, 'collated_' + fn)
        #     # out = os.path.join(dm.dest(), 'collated_' + fn)
        #     task_args = [sys.executable,
        #                  job_script,            # Python program to run (single_alignment_job)
        #                  fn,
        #                  out
        #                  ]
        #     task_queue.add_task(task_args)
        #     if cfg.PRINT_EXAMPLE_ARGS:
        #         if i in range(0,3):
        #             logger.info("Layer #%d (example):\n%s" % (i, "\n".join(task_args)))
        #
        # try:
        #     dt = task_queue.collect_results()
        # except:
        #     print_exception()
        #     logger.warning('Task Queue encountered a problem')

        logger.info('<<<< Compute Affines End <<<<')


def checkForTiffs(path) -> bool:
    '''Returns True or False dependent on whether aligned images have been generated for the current s.'''
    files = glob.glob(path + '/*.tif')
    if len(files) < 1:
        logger.debug('Zero aligned TIFs were found at this s - Returning False')
        return False
    else:
        logger.debug('One or more aligned TIFs were found at this s - Returning True')
        return True

def write_run_to_file(dm, scale=None):
    if scale == None: scale = dm.scale()
    # snr_avg = 'SNR=%.3f' % dm.snr_average(scale=scale)
    timestamp = datetime.now().strftime("%Y%m%d_%H:%M:%S")
    results = 'results'
    # swim_input = 'swim=%.3f' % dm.swim_window()
    # whitening_input = 'whitening=%.3f' % dm.whitening()
    # details = [date, time, s, _swimWindowControl, _whiteningControl, snr_avg]
    scale_str = 's' + str(get_scale_val(scale))
    details = [scale_str, results, timestamp]
    fn = '_'.join(details) + '.json'
    of = Path(os.path.join(dm.dest(), scale, 'history', fn))
    of.parent.mkdir(exist_ok=True, parents=True)
    with open(of, 'w') as f:
        json.dump(dm['data']['scales'][scale], f, indent=4)
__all__ = ['data']

LOG_LEVEL = 1

'''Main Objects'''
# datamodel = None
data = None
dataById = {}
main_window = None
project_tab = None
zarr_tab = None
thumb = None
emViewer = None
selected = None
dms = {}
refLV = None
baseLV = None
alLV = None
menLV = None
LV = None
tensor = None
unal_tensor = None
al_tensor = None
men_tensor = None
webdriver = None
py_console = None
is_mendenhall = False

'''Default Window Size'''
# WIDTH, HEIGHT = 1180, 680
# WIDTH, HEIGHT = 1380, 900
WIDTH, HEIGHT = 1180, 720

'''Default Alignment Params'''
DEFAULT_SWIM_WINDOW       = float(0.8125)
DEFAULT_WHITENING         = float(-0.6800)
DEFAULT_POLY_ORDER        = int(0)
DEFAULT_NULL_BIAS         = bool(False)
DEFAULT_BOUNDING_BOX      = bool(False)
DEFAULT_INITIAL_ROTATION  = float(0.0000)
DEFAULT_INITIAL_SCALE     = float(1.0000)

'''Default Image Resolution (Voxel Dimensions)'''
DEFAULT_RESX, DEFAULT_RESY, DEFAULT_RESZ = 2, 2, 50

'''Default Zarr Chunk Shape'''
CHUNK_X, CHUNK_Y, CHUNK_Z = 512, 512, 1
# CHUNK_X, CHUNK_Y, CHUNK_Z = 64, 64, 64

'''Default Compression Parameters'''
# CNAME = 'zstd'
CNAME = 'None'
CLEVEL = 5

'''Other Defaults'''
KEEP_ORIGINAL_SPOTS = False
PROFILING_TIMER_SPEED = 5000
PROFILING_TIMER_AUTOSTART = False
DEFAULT_PLAYBACK_SPEED = 4.0 # playback speed (fps)
TARGET_THUMBNAIL_SIZE = 256
if 'Joels-' in platform.node():
    DEV_MODE = True
else:
    DEV_MODE = False
PROFILING_MODE = False
# if 'Joels-' in platform.node():
#     PROFILING_MODE = True
PRINT_EXAMPLE_ARGS = True
AUTOSAVE = True
DAEMON_THREADS = True
USE_EXTRA_THREADING = True
DEBUG_MP = False
DEBUG_NEUROGLANCER = False
# DEBUG_MP = (False,True)[DEV_MODE]
# DEBUG_NEUROGLANCER = (False,True)[DEV_MODE]
PROFILER = False
DUMMY = False
USE_TENSORSTORE = True
FAULT_HANDLER = False
HEADLESS = False
TACC_MAX_CPUS = 122 # 128 hardware cores/node on Lonestar6
SUPPORT_NONSQUARE = True
USE_PYTHON = False
NO_SPLASH = True
MP_MODE = False
THEME = 0
MP_LINEWEIGHT = 3
MP_SIZE = 6
USE_FILE_IO = 0
CODE_MODE = 'c'
# HTTP_PORT = 9000
ICON_COLOR = '#2774AE'
MV = True

settings = None
selected_file = None
tasks_remaining = None
tasks_total = None

DELAY_BEFORE = 0
DELAY_AFTER = 0
USE_DELAY = False

nTasks = 0
nCompleted = 0
CancelProcesses = False
event = None

SHADER = shader_default_ = '''#uicontrol vec3 color color(default="white")
#uicontrol float brightness slider(min=-1, max=1, step=0.01)
#uicontrol float contrast slider(min=-1, max=1, step=0.01)
void main() {
  emitRGB(color *
          (toNormalized(getDataValue()) + brightness) *
          exp(contrast));
}
'''
__all__ = ['DataModel']

logger = logging.getLogger(__name__)

class ScaleIterator:
    def __init__(self, data):
        self._data = data
        self._index = 0

    def __next__(self):
        if self._index < len(self._data):
            result =  self._data[self._index]
        else:
            raise StopIteration
        self._index += 1
        return result

    def __iter__(self):
        return self


class DataModel:
    """ Encapsulate datamodel dictionary and wrap with methods for convenience """
    def __init__(self, data=None, name=None, quitely=False, mendenhall=False):
        logger.info('>>>> Constructing DataModel >>>>')
        self._current_version = 0.50
        self.quietly = quitely
        self.scalesAlignedAndGenerated = []
        self.nScalesAlignedAndGenerated = None
        self.nscales = None
        self.nSections = None
        self.curScale = None
        if not self.quietly:
            logger.info(f'Constructing Data Model (caller:{inspect.stack()[1].function})...')

        if data:
            self._data = data
        else:
            self._data = copy.deepcopy(data_template)
            current_time = datetime.now()
            self._data['created'] = current_time.strftime('%Y-%m-%d %H:%M:%S')
            self.set_system_info()
        # if not self.layer():
        #     self.set_layer(0)

        if not self.quietly:
            self._data['modified'] = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            # self.set_defaults()

        if name:
            self._data['data']['destination_path'] = name
        self._data['data']['mendenhall'] = mendenhall

        if not self.quietly:
            self.set_defaults()
        if not self.layer():
            self.set_layer(0)

        logger.info('<<<< Exiting DataModel Constructor <<<<')

    def __setitem__(self, key, item):
        self._data[key] = item

    def __getitem__(self, key):
        return self._data[key]

    def __repr__(self):
        return self.to_json()

    def __copy__(self):
        cls = self.__class__
        result = cls.__new__(cls)
        result.__dict__.update(self.__dict__)
        return result

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            setattr(result, k, deepcopy(v, memo))
        return result

    def __len__(self):
        try:
            return self.n_sections()
        except:
            logger.warning('No Images Found')

    def created(self):
        return self._data['created']

    def last_opened(self):
        return self._data['modified']

    def modified(self):
        return self._data['modified']

    def is_aligned(self, s=None):
        # logger.info('')
        if s == None: s = self.curScale
        if sum(self.snr_list(s=s)) < 1:
            # logger.info('is_aligned is returning False')
            return False
        else:
            # logger.info('is_aligned is returning True')
            return True

    def is_aligned_and_generated(self, s=None) -> bool:
        if s == None: s = cfg.data.scale()
        if s in self.scalesAlignedAndGenerated:
            return True
        else:
            return False

    def update_cache(self):
        logger.info('Caching data model variables...')
        self.curScale = self.scale()
        try:
            self.scalesAlignedAndGenerated = get_scales_with_generated_alignments(self.scales())
            self.nScalesAlignedAndGenerated = len(self.scalesAlignedAndGenerated)
        except:
            print_exception()
        self.scalesList = self.scales()
        self.nscales = len(self.scalesList)
        self.nSections = self.n_sections()

    def numCorrSpots(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return len(self.snr_components())

    def set_t_scaling(self, dt):
        self._data['data']['t_scaling'] = dt

    def set_t_scaling_convert_zarr(self, dt):
        self._data['data']['t_scaling_convert_zarr'] = dt

    def set_t_thumbs(self, dt):
        self._data['data']['t_thumbs'] = dt

    def set_t_align(self, dt, s=None):
        if s == None: s = cfg.data.scale()
        self._data['data']['scales'][s]['t_align'] = dt

    def set_t_generate(self, dt, s=None):
        if s == None: s = cfg.data.scale()
        self._data['data']['scales'][s]['t_generate'] = dt

    def set_t_convert_zarr(self, dt, s=None):
        if s == None: s = cfg.data.scale()
        self._data['data']['scales'][s]['t_convert_zarr'] = dt

    def set_t_thumbs_aligned(self, dt, s=None):
        if s == None: s = cfg.data.scale()
        self._data['data']['scales'][s]['t_thumbs_aligned'] = dt

    def set_t_thumbs_spot(self, dt, s=None):
        if s == None: s = cfg.data.scale()
        self._data['data']['scales'][s]['t_thumbs_spot'] = dt

    def set_thumb_scaling_factor_source(self, factor:int):
        self._data['data']['thumb_scaling_factor_source'] = factor

    def set_thumb_scaling_factor_aligned(self, factor:int, s:str):
        self._data['data']['scales'][s]['thumb_scaling_factor_aligned'] = factor

    def set_thumb_scaling_factor_corr_spot(self, factor:int, s:str):
        self._data['data']['scales'][s]['thumb_scaling_factor_corr_spot'] = factor

    def normalize(self):
        return self._data['rendering']['normalize']

    def set_normalize(self, range):
        self._data['rendering']['normalize'] = range

    def brightness(self):
        return self._data['rendering']['brightness']

    def contrast(self):
        return self._data['rendering']['contrast']

    def set_brightness(self, val):
        self._data['rendering']['brightness'] = val

    def set_contrast(self, val):
        self._data['rendering']['contrast'] = val

    def set_defaults(self):
        # logger.info(f'caller: {inspect.stack()[1].function}')
        self._data['data'].setdefault('shader', cfg.SHADER)
        self._data['data'].setdefault('cname', cfg.CNAME)
        self._data['data'].setdefault('clevel', cfg.CLEVEL)
        self._data['data'].setdefault('chunkshape', (cfg.CHUNK_Z, cfg.CHUNK_Y, cfg.CHUNK_X))
        self._data['data'].setdefault('t_scaling', 0.0)
        self._data['data'].setdefault('t_scaling_convert_zarr', 0.0)
        self._data['data'].setdefault('t_thumbs', 0.0)

        self._data['rendering'].setdefault('normalize', [1,255])
        self._data['rendering'].setdefault('brightness', 0)
        self._data['rendering'].setdefault('contrast', 0)
        self._data['rendering'].setdefault('shader', '''
        #uicontrol vec3 color color(default="white")
        #uicontrol float brightness slider(min=-1, max=1, step=0.01)
        #uicontrol float contrast slider(min=-1, max=1, step=0.01)
        void main() { emitRGB(color * (toNormalized(getDataValue()) + brightness) * exp(contrast));}
        ''')
        self._data.setdefault('ui', {})
        self._data['ui'].setdefault('ng_layout', '4panel')
        self._data['ui'].setdefault('arrangement', 'stack')


        # for s in self.scales():
        for s in self._data['data']['scales'].keys():
            logger.info('Setting defaults for %s' % self.scale_pretty(s=s))
            scale = self._data['data']['scales'][s]
            scale.setdefault('use_bounding_rect', cfg.DEFAULT_BOUNDING_BOX)
            scale.setdefault('null_cafm_trends', cfg.DEFAULT_NULL_BIAS)
            scale.setdefault('poly_order', cfg.DEFAULT_POLY_ORDER)
            scale.setdefault('resolution', (cfg.DEFAULT_RESZ, cfg.DEFAULT_RESY, cfg.DEFAULT_RESX))
            scale.setdefault('t_align', 0.0)
            scale.setdefault('t_generate', 0.0)
            scale.setdefault('t_convert_zarr', 0.0)
            scale.setdefault('t_thumbs_aligned', 0.0)
            scale.setdefault('t_thumbs_spot', 0.0)

            for layer_index in range(len(scale['alignment_stack'])):
                layer = scale['alignment_stack'][layer_index]
                layer.setdefault('alignment', {})
                layer['alignment'].setdefault('method_data', {})
                layer['alignment']['method_data'].setdefault('win_scale_factor', cfg.DEFAULT_SWIM_WINDOW)
                layer['alignment']['method_data'].setdefault('whitening_factor', cfg.DEFAULT_WHITENING)
                layer['alignment'].setdefault('manual_points', {})
                layer['alignment']['manual_points'].setdefault('ref', [])
                layer['alignment']['manual_points'].setdefault('base', [])
                if s == self.coarsest_scale_key():
                    layer['alignment']['method_data']['alignment_option'] = 'init_affine'
                else:
                    layer['alignment']['method_data']['alignment_option'] = 'refine_affine'


    def notes(self, s=None, l=None):
        return self._data['data']['scales'][s]['alignment_stack'][l]['notes']


    def save_notes(self, text, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        self._data['data']['scales'][s]['alignment_stack'][l]['notes'] = text


    def sl(self):
        return (self.curScale, self.layer())

    def to_json(self):
        return json.dumps(self._data)

    def to_dict(self):
        return self._data

    def dest(self) -> str:
        return self._data['data']['destination_path']

    def name(self) -> str:
        return os.path.split(self.dest())[-1]


    def set_system_info(self):
        logger.info('')
        try:    self._data['system']['node'] = platform.node()
        except: self._data['system']['node'] = 'Unknown'


    def base_image_name(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        # logger.info(f'Caller: {inspect.stack()[1].function}, s={s}, l={l}')
        return os.path.basename(self._data['data']['scales'][s]['alignment_stack'][l]['filename'])



    '''NEW METHODS USING NEW DATA SCHEMA 2023'''

    def filename(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return self._data['data']['scales'][s]['alignment_stack'][l]['filename']

    def reference(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return self._data['data']['scales'][s]['alignment_stack'][l]['reference']

    def filename_basename(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return os.path.basename(self._data['data']['scales'][s]['alignment_stack'][l]['filename'])

    def reference_basename(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return os.path.basename(self._data['data']['scales'][s]['alignment_stack'][l]['reference'])


    '''END OF NEW METHODS'''

    def filenames(self):
        '''Returns filenames as absolute paths'''
        return natural_sort([os.path.abspath(l['filename'])
                for l in self._data['data']['scales'][self.scales()[0]]['alignment_stack']])

    def basefilenames(self):
        '''Returns filenames as absolute paths'''
        return natural_sort([os.path.basename(l['filename'])
                for l in self._data['data']['scales'][self.scales()[0]]['alignment_stack']])

    def thumbnail(self, l = None):
        '''Returns absolute path of thumbnail for current layer '''
        if l == None: l = cfg.data.layer()
        return self.thumbnails()[l]

    def thumbnails(self) -> list:
        lst = []
        for name in self.basefilenames():
            lst.append(os.path.join(self.dest(), 'thumbnails', name))
        return lst


    def thumbnails_ref(self) -> list:
        paths = []
        for l in cfg.data.alstack():
            paths.append(os.path.join(self.dest(), 'thumbnails', os.path.basename(l['reference'])))
        return paths

    def thumbnails_aligned(self) -> list:
        paths = []
        for layer in range(0, self.n_sections()):
            paths.append(os.path.join(self.dest(), self.curScale, 'thumbnails_aligned', self.base_image_name(l=layer)))
        return paths

    def thumbnail_aligned(self):
        '''Returns absolute path of thumbnail for current layer '''
        path = os.path.join(self.dest(), self.curScale, 'thumbnails_aligned', self.base_image_name())
        # return self._data['data']['thumbnails'][self.layer()]
        return path

    def corr_signal_path(self, i, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        img = self.base_image_name(s=s, l=l)
        return os.path.join(self.dest(), s, 'thumbnails_corr_spots' , 'corr_spot_%d_' %i + img)


    def corr_spot_q0_path(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        img = self.base_image_name(s=s, l=l)
        return os.path.join(self.dest(), s, 'thumbnails_corr_spots' , 'corr_spot_0_' + img)

    def corr_spot_q1_path(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        img = self.base_image_name(s=s, l=l)
        return os.path.join(self.dest(), s, 'thumbnails_corr_spots' , 'corr_spot_1_' + img)

    def corr_spot_q2_path(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        img = self.base_image_name(s=s, l=l)
        return os.path.join(self.dest(), s, 'thumbnails_corr_spots' , 'corr_spot_2_' + img)

    def corr_spot_q3_path(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        img = self.base_image_name(s=s, l=l)
        return os.path.join(self.dest(), s, 'thumbnails_corr_spots' , 'corr_spot_3_' + img)

    def corr_spots_q0(self) -> list:
        names = []
        for img in self.basefilenames():
            # names.append(os.path.join(self.dest(), self.curScale, 'corr_spots' , 'corr_spot_0_' + img))
            names.append(os.path.join(self.dest(), self.curScale, 'thumbnails_corr_spots' , 'corr_spot_0_' + img))
        return names

    def corr_spots_q1(self) -> list:
        names = []
        for img in self.basefilenames():
            # names.append(os.path.join(self.dest(), self.curScale, 'corr_spots' , 'corr_spot_1_' + img))
            names.append(os.path.join(self.dest(), self.curScale, 'thumbnails_corr_spots' , 'corr_spot_1_' + img))
        return names

    def corr_spots_q2(self) -> list:
        names = []
        for img in self.basefilenames():
            # names.append(os.path.join(self.dest(), self.curScale, 'corr_spots' , 'corr_spot_2_' + img))
            names.append(os.path.join(self.dest(), self.curScale, 'thumbnails_corr_spots' , 'corr_spot_2_' + img))
        return names

    def corr_spots_q3(self) -> list:
        names = []
        for img in self.basefilenames():
            # names.append(os.path.join(self.dest(), self.curScale, 'corr_spots', 'corr_spot_3_' + img))
            names.append(os.path.join(self.dest(), self.curScale, 'thumbnails_corr_spots', 'corr_spot_3_' + img))
        return names

    def smallest_scale(self):
        return natural_sort(self._data['data']['scales'].keys())[-1]

    # def thumbnail_names(self):
    #
    #
    #     [os.path.join(cfg.dest())            name in self.basefilenames()])
    #     return glob.glob(os.path.join(self.dest(), 'thumbnails', '*.tif'))

    # def thumbnail_paths(self):
    #     names = self.thumbnail_names()
    #     for i, name in enumerate(names):
    #         names[i] = os.path.join(self.dest(), 'thumbnails', name)

    def set_source_path(self, dir):
        # self._data['data']['src_img_root'] = dir
        self._data['data'].update({'source_path': dir})

    def source_path(self):
        return self._data['data']['source_path']

    def get_source_img_paths(self):
        imgs = []
        for f in self.filenames():
            imgs.append(os.path.join(self.source_path(), os.path.basename(f)))
        return imgs

    def is_mendenhall(self):
        return self._data['data']['mendenhall']

    def get_iter(self, s=None, start=0, end=None):
        if s == None: s = self.curScale
        return ScaleIterator(self._data['data']['scales'][s]['alignment_stack'][start:end])

    def layer(self) -> int:
        '''Returns the Current Layer as an Integer.'''
        try:
            layer = self._data['data']['current_layer']
            if layer is None:
                logger.warning('Layer is None!')
            return layer
        except:
            logger.warning('Falling Back To Layer 0')
            self.set_layer(0)
            return self._data['data']['current_layer']

    def method_results(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']
        except:
            return {}

    def datetime(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['datetime']
        except:
            return ''


    def previous_method_results(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['previous_method_results']
        except:
            return {}



    def snr(self, s=None, l=None) -> float:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        if l == 0:
            return 0.0
        try:
            value = self.method_results(s=s, l=l)['snr']
            return statistics.fmean(map(float, value))
        except:
            return 0.0

    def snr_prev(self, s=None, l=None) -> float:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        if l == 0:
            return 0.0
        try:
            value = self.previous_method_results(s=s, l=l)['snr']
            return statistics.fmean(map(float, value))
        except:
            return 0.0


    def snr_list(self, s=None) -> list[float]:
        # logger.info('caller: %s...' % inspect.stack()[1].function)
        ''' n is 4 for a 2x2 SWIM'''
        if self.method_results():
            try:
                return [self.snr(s=s, l=i) for i in range(len(self))]
            except:
                return [0.0, 0.0, 0.0, 0.0]
        else:
            logger.warning('No Method Results, No SNR List - Returning Empty List')



    def snr_prev_list(self, s=None, l=None):
        # logger.info('caller: %s...' % inspect.stack()[1].function)
        if s == None: s = self.curScale
        try:
            return [self.snr_prev(s=s, l=i) for i in range(self.n_sections())]
        except:
            return [0.0, 0.0, 0.0, 0.0]


    def delta_snr_list(self):
        return [a_i - b_i for a_i, b_i in zip(self.snr_prev_list(), self.snr_list())]


    def snr_components(self, s=None, l=None) -> list[float]:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                            'alignment']['method_results']['snr']
        except:
            logger.warning('No SNR data for %s, layer %d' %(s,l))
            return [0.0, 0.0, 0.0, 0.0]


    def snr_prev_components(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = cfg.data.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['previous_method_results']['snr_prev']
        except:
            logger.warning('No Previous SNR data for %s, layer %d' %(s,l))
            return [0.0, 0.0, 0.0, 0.0]


    def snr_report(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['method_results']['snr_report']
        except:
            logger.warning('No SNR Report for Layer %d' % l)
            return ''


    def snr_errorbar_size(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            if l == 0:
                return 0.0
            report = self.snr_report(s=s, l=l)
            if not isinstance(report, str):
                logger.debug(f'No SNR Report Available For Layer {l}, Returning 0.0...')
                return 0.0
            substr = '+-'
            return float(report[report.index(substr) + 2: report.index(substr) + 5])
        except:
            return 0.0


    def snr_errorbars(self, s=None):
        '''Note Length Of Return Array has size self.n_sections() - 1 (!)'''
        if s == None: s = self.curScale
        return np.array([self.snr_errorbar_size(s=s, l=l) for l in range(0, self.n_sections())])


    def check_snr_status(self, s=None) -> list:
        if s == None: s = self.curScale
        unavailable = []
        for i,l in enumerate(self.alstack(s=s)):
            if not 'snr' in l['alignment']['method_results']:
                unavailable.append((i, self.name_base(s=s, l=i)))
        return unavailable


    def snr_max_all_scales(self) -> float:
        #Todo refactor, store local copy, this is a bottleneck
        max_snr = []
        # logger.critical(f'self.scalesAlignedAndGenerated: {self.scalesAlignedAndGenerated}')
        try:
            for s in cfg.data.scales():
                if cfg.data.is_aligned(s=s):
                    m = max(self.snr_list(s=s))
                    # logger.critical(f'm: {m}')
                    max_snr.append(m)
            return max(max_snr)
        except:
            caller = inspect.stack()[1].function
            logger.warning('Unable to append maximum SNR, none found (%s) - Returning Empty List' % caller)
            return []



    def snr_average(self, scale=None) -> float:
        logger.info('caller: %s...' % inspect.stack()[1].function)
        if scale == None: scale = self.curScale
        # NOTE: skip the first layer which does not have an SNR value s may be equal to zero
        return statistics.fmean(self.snr_list(s=scale)[1:])


    def snr_prev_average(self, scale=None) -> float:
        logger.info('caller: %s...' % inspect.stack()[1].function)
        if scale == None: scale = self.curScale
        # NOTE: skip the first layer which does not have an SNR value s may be equal to zero
        return statistics.fmean(self.snr_prev_list(s=scale)[1:])


    def print_all_matchpoints(self):
        logger.info('Match Points:')
        for i, l in enumerate(self.alstack()):
            r = self._data['data']['scales'][cfg.data.scale()]['alignment_stack'][
                l]['alignment']['manual_points']['ref']
            b = self._data['data']['scales'][cfg.data.scale()]['alignment_stack'][
                l]['alignment']['manual_points']['base']
            if r != []:
                logger.info(f'Index: {i}, Ref, Match Points: {str(r)}')
            if b != []:
                logger.info(f'Index: {i}, Base, Match Points: {str(b)}')


    def scale(self) -> str:
        '''Returns the Current Scale as a String.'''
        assert isinstance(self._data['data']['current_scale'], str)
        if self._data['data']['current_scale'] == '':
            logger.warning('WARNING: Scale Was An Empty String')
            self._data['data']['current_scale'] = self.scales()[-1]
        return self._data['data']['current_scale']

    def add_manpoint(self, coordinates, role, s=None, l=None) -> None:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        if role == 'base':
            self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['manual_points']['base'].append(coordinates)
        elif role == 'ref':
            self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['manual_points']['ref'].append(coordinates)


    def manual_points(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return self._data['data']['scales'][s]['alignment_stack'][l][
            'alignment']['manual_points']

    def manpoints_pretty(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        ref = cfg.data.manual_points()['ref']
        base = cfg.data.manual_points()['base']
        return (['(%d, %d)' % (round(x1), round(y1)) for x1, y1 in ref],
                ['(%d, %d)' % (round(x1), round(y1)) for x1, y1 in base])

    def manpoints_rounded(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        ref = cfg.data.manual_points()['ref']
        base = cfg.data.manual_points()['base']
        return zip([(round(x1), round(y1)) for x1, y1 in ref],
                [(round(x1), round(y1)) for x1, y1 in base])


    def find_layers_with_matchpoints(self, s=None) -> list:
        '''Returns the list of layers that have match points'''
        if s == None: s = self.curScale
        indexes, names = [], []
        try:
            for i,layer in enumerate(self.alstack()):
                r = layer['alignment']['manual_points']['ref']
                b = layer['alignment']['manual_points']['base']
                if (r != []) or (b != []):
                    indexes.append(i)
                    names.append(os.path.basename(layer['filename']))
            return list(zip(indexes, names))
        except:
            print_exception()
            logger.warning('Unable to To Return List of Match Point Layers')
            return []


    def print_all_match_points(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        for i,layer in enumerate(self.alstack()):
            r = layer['alignment']['manual_points']['ref']
            b = layer['alignment']['manual_points']['base']
            if r != [] or b != []:
                # combined = {'ref': r, 'base': b}
                logger.info('____Layer %d Matchpoints____\n  Ref: %s\n  Base: %s' % (i, str(r), str(b)))


    def getmp(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        # return self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']['ref']
        return self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']

    def getmpFlat(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            mps = self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']
            # ref = [(0, x[0], x[1]) for x in mps['ref']]
            # base = [(0, x[0], x[1]) for x in mps['base']]
            ref = [(0.5, x[0], x[1]) for x in mps['ref']]
            base = [(0.5, x[0], x[1]) for x in mps['base']]
            return {'ref': ref, 'base': base}
        except:
            return {'ref': [], 'base': []}

    # def match_points_ref(self, s=None, l=None):
    #     if s == None: s = self.curScale
    #     if l == None: l = self.layer()
    #     # return self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']['ref']
    #     return self._data['data']['scales'][s]['alignment_stack'][l]['images']['ref']['metadata']['manual_points']
    #
    # def match_points_base(self, s=None, l=None):
    #     if s == None: s = self.curScale
    #     if l == None: l = self.layer()
    #     # return self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']['base']
    #     return self._data['data']['scales'][s]['alignment_stack'][l]['images']['base']['metadata']['manual_points']

    # def all_match_points_ref(self, s=None):
    #     if s == None: s = self.curScale
    #     lst = []
    #     for i, layer in enumerate(self.alstack(s=s)):
    #         mp = layer['alignment']['manual_points']['ref']
    #         if mp != []:
    #             for p in mp:
    #                 lst.append([i, p[0], p[1]])
    #     return lst
    #
    # def all_match_points_base(self, s=None):
    #     if s == None: s = self.curScale
    #     lst = []
    #     for i, layer in enumerate(self.alstack(s=s)):
    #         mp = layer['alignment']['manual_points']['base']
    #         if mp != []:
    #             for p in mp:
    #                 lst.append([i, p[0], p[1]])
    #     return lst

    def clearMps(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']['ref'] = []
        self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['manual_points']['base'] = []

    def clearAllMps(self):
        for layer in self.alstack():
            layer['alignment']['manual_points']['ref'] = []
            layer['alignment']['manual_points']['base'] = []

    def annotations(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        layer = self._data['data']['scales'][s]['alignment_stack'][l]
        r = layer['images']['ref']['metadata']['annotations']
        b = layer['images']['base']['metadata']['annotations']
        a = layer['images']['aligned']['metadata']['annotations']
        combined = {'ref': r, 'base': b, 'aligned': a}
        logger.info(f'Ref, Annotations: {str(r)}')
        logger.info(f'Base, Annotations: {str(b)}')
        logger.info(f'Base, Annotations: {str(a)}')
        return combined


    def set_manual_points(self, role, matchpoints, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        logger.info(f"Writing manual points to project dictionary, s={s}, l={l}")
        self.alstack()[l]['alignment']['manual_points'][role] = matchpoints


    def afm(self, s=None, l=None) -> list:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['affine_matrix']
        except:
            return [[0, 0, 0], [0, 0, 0]]

    def afm_(self, s=None, l=None) -> zip:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return zip(self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['affine_matrix'][0],
                       self._data['data']['scales'][s]['alignment_stack'][l][
                           'alignment']['method_results']['affine_matrix'][1]
                       )
        except:
            return zip([0, 0, 0], [0, 0, 0])

    def cafm(self, s=None, l=None) -> list:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['cumulative_afm']
        except:
            return [[0, 0, 0], [0, 0, 0]]

    def cafm_(self, s=None, l=None) -> zip:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return zip(self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['cumulative_afm'][0],
                       self._data['data']['scales'][s]['alignment_stack'][l][
                           'alignment']['method_results']['cumulative_afm'][1]
                       )
        except:
            return zip([0, 0, 0], [0, 0, 0])

    def afm_list(self, s=None, l=None) -> list:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        lst = [l['alignment']['method_results']['affine_matrix'] for l in self.alstack()]
        return lst

    def cafm_list(self, s=None, l=None) -> list:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        lst = [l['alignment']['method_results']['cumulative_afm'] for l in self.alstack()]
        return lst

    def bias_data_path(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return os.path.join(self.dest(), s, 'bias_data')

    def show_afm(self):
        logger.info('\nafm = %s\n' % ' '.join(map(str, self.afm())))

    def show_cafm(self):
        logger.info('\ncafm = %s\n' % ' '.join(map(str, self.cafm())))

    def resolution(self, s=None):
        if s == None: s = self.scale()
        # logger.info('returning: %s' % str(self._data['data']['scales'][s]['resolution']))
        return self._data['data']['scales'][s]['resolution']
    #
    # def res_x(self, s=None) -> int:
    #     if s == None: s = self.curScale
    #     if 'resolution_x' in self._data['data']['scales'][s]:
    #         return int(self._data['data']['scales'][s]['resolution_x'])
    #     else:
    #         logger.warning('resolution_x not in dictionary')
    #         # return int(2)
    #
    # def res_y(self, s=None) -> int:
    #     if s == None: s = self.curScale
    #     if 'resolution_y' in self._data['data']['scales'][s]:
    #         return int(self._data['data']['scales'][s]['resolution_y'])
    #     else:
    #         logger.warning('resolution_y not in dictionary')
    #         # return int(2)
    #
    # def res_z(self, s=None) -> int:
    #     if s == None: s = self.curScale
    #     if 'resolution_z' in self._data['data']['scales'][s]:
    #         return int(self._data['data']['scales'][s]['resolution_z'])
    #     else:
    #         logger.warning('resolution_z not in dictionary')
    #         # return int(50)

    # def set_resolutions(self, scale, res_x:int, res_y:int, res_z:int):
    #     self._data['data']['scales'][scale]['resolution_x'] = res_x
    #     self._data['data']['scales'][scale]['resolution_y'] = res_y
    #     self._data['data']['scales'][scale]['resolution_z'] = res_z

    def set_resolution(self, s, res_x:int, res_y:int, res_z:int):
        self._data['data']['scales'][s]['resolution'] = (res_z, res_y, res_x)

    def cname(self):
        try:     return self._data['data']['cname']
        except:  logger.warning('cname not in dictionary')

    def clevel(self):
        try:     return int(self._data['data']['clevel'])
        except:  logger.warning('clevel not in dictionary')

    def chunkshape(self):
        try:
            return self._data['data']['chunkshape']
        except:
            logger.warning('chunkshape not in dictionary')

    def get_user_zarr_settings(self):
        '''Returns user settings for cname, clevel, chunkshape as tuple (in that order).'''
        return (self.cname(), self.clevel(), self.chunkshape())

    def scale_pretty(self, s=None) -> str:
        if s == None: s = self.curScale
        return 'Scale %d' % self.scale_val(s=s)

    def scale_val(self, s=None) -> int:
        if s == None: s = self.curScale
        while s.startswith('scale_'):
            s = s[len('scale_'):]
        return int(s)

    def scale_vals(self) -> list[int]:
        return [int(v) for v in sorted([get_scale_val(s) for s in self.scales()])]

    def n_scales(self) -> int:
        '''Returns the number of scales in s pyramid'''
        try:
            n_scales = len(self._data['data']['scales'].keys())
            return n_scales
        except:
            logger.warning('No Scales Found - Returning 0')

    def n_sections(self) -> int:
        '''Returns # of imported images.
        #TODO Check this for off-by-one bug'''
        try:
            if self.is_mendenhall():
                return cfg.main_window.mendenhall.n_files()
            else:
                return len(self._data['data']['scales']['scale_1']['alignment_stack'])
        except:
            print_exception()

    def scales(self) -> list[str]:
        '''Get scales list.
        Faster than O(n*m) performance.
        Preserves order of scales.'''
        return natural_sort([key for key in self._data['data']['scales'].keys()])

    def downscales(self) -> list[str]:
        '''Get downscales list (similar to scales() but with scale_1 removed).
        Faster than O(n*m) performance.
        Preserves order of scales.'''
        lst = natural_sort([key for key in self._data['data']['scales'].keys()])
        try:
            lst.remove('scale_1')
        except:
            print_exception()
        return lst

    def skipped(self, s=None, l=None) -> bool:
        '''Called by get_axis_data'''
        # logger.info('skipped (called By %s)' % inspect.stack()[1].function)

        # print('Before Defaults: s = %s, l = %s' % (str(s), str(l))) # Before Defaults: s = None, l = None
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        # print('After Defaults: s = %s, l = %s' % (str(s), str(l))) # After Defaults: s = scale_4, l = 0
        assert isinstance(s, str)
        assert isinstance(l, int)
        try:
            return bool(self._data['data']['scales'][s]['alignment_stack'][l]['skipped'])
        except IndexError:
            logger.warning(f'Index {l} is out of range.')
        except:
            print_exception()
            logger.warning('Returning False, but there was a problem')
            return False

    def skips_list(self, s=None) -> list:
        '''Returns the list of skipped images for a s'''
        if s == None: s = self.curScale
        indexes, names = [], []
        try:
            for i,layer in enumerate(self.alstack(s=s)):
                if layer['skipped'] == True:
                    indexes.append(i)
                    names.append(os.path.basename(layer['filename']))
            return list(zip(indexes, names))
        except:
            print_exception()
            logger.warning('Unable to To Return Skips List')
            return []

    def skips_indices(self) -> list:
        try:
            return list(list(zip(*cfg.data.skips_list()))[0])
        except:
            return []

    def skips_by_name(self, s=None) -> list[str]:
        '''Returns the list of skipped images for a s'''
        if s == None: s = self.curScale
        lst = []
        try:
            for i in range(self.n_sections()):
                if self._data['data']['scales'][s]['alignment_stack'][i]['skipped'] == True:
                    f = os.path.basename(self._data['data']['scales'][s]['alignment_stack'][i]['filename'])
                    lst.append(f)
            return lst
        except:
            logger.warning('Unable to To Return Skips By Name List')
            return []

    def whitening(self) -> float:
        '''Returns the Whitening Factor for the Current Layer.'''
        return float(self._data['data']['scales'][self.curScale]['alignment_stack'][
                         self.layer()]['alignment']['method_data']['whitening_factor'])

    def swim_window(self) -> float:
        '''Returns the SWIM Window for the Current Layer.'''
        return float(self._data['data']['scales'][self.curScale]['alignment_stack'][
                         self.layer()]['alignment']['method_data']['win_scale_factor'])

    def has_bb(self, s=None) -> bool:
        '''Returns the Bounding Rectangle On/Off State for the Current Scale.'''
        if s == None: s = self.curScale
        return bool(self._data['data']['scales'][s]['use_bounding_rect'])

    def bounding_rect(self, s=None):
        if s == None: s = self.curScale
        try:
            return self._data['data']['scales'][s]['bounding_rect']
        except:
            try:
                self.set_bounding_rect(ComputeBoundingRect(self.alstack(s=s), scale=s))
                return self._data['data']['scales'][s]['bounding_rect']
            except:
                logger.warning('Unable to return a bounding rect (s=%s)' % s)
                return None

    def image_size(self, s=None) -> tuple:
        if s == None: s = self.curScale
        logger.debug('Called by %s, s=%s' % (inspect.stack()[1].function, s))
        try:
            return tuple(self._data['data']['scales'][s]['image_src_size'])
        except:
            logger.info(f"No key 'image_src_size' found (scale:{s}). Adding it now...")
            try:
                self.set_image_size(s=s)
                answer = tuple(self._data['data']['scales'][s]['image_src_size'])
                logger.info(f'Returning {answer}')
                return answer
            except:
                print_exception()
                logger.warning('Unable to return the image size (s=%s)' % s)
                return None

    def full_scale_size(self):
        return ImageSize(self.path_base(s='scale_1'))

    def poly_order(self, s=None) -> int:
        '''Returns the Polynomial Order for the Current Scale.'''
        if s == None: s = self.curScale
        return int(self._data['data']['scales'][s]['poly_order'])

    def null_cafm(self, s=None) -> bool:
        '''Gets the Null Cafm Trends On/Off State for the Current Scale.'''
        if s == None: s = self.curScale
        return bool(self._data['data']['scales'][s]['null_cafm_trends'])

    def al_option(self, s=None) -> str:
        '''Gets the Alignment Option for the Current Scale.'''
        if s == None: s = self.curScale
        return self._data['data']['scales'][s]['method_data']['alignment_option']

    def path_ref(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return self._data['data']['scales'][s]['alignment_stack'][l]['reference']

    def path_base(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        # Todo -- Refactor!
        try:
            name = self._data['data']['scales'][s]['alignment_stack'][l]['filename']
            return name
        except:
            print_exception()

    def name_base(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return os.path.basename(self._data['data']['scales'][s]['alignment_stack'][l]['filename'])
        except:
            return ''

    def name_ref(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            return os.path.basename(self._data['data']['scales'][s]['alignment_stack'][l]['reference'])
        except:
            return ''

    def path_aligned(self, s=None, l=None) -> str:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return os.path.join(self.dest(), s, 'img_aligned', self.name_base(l=l))

    def zarr_scale_paths(self):
        l = []
        for s in self.scales():
            # l.append(os.path.join(self._data['data']['destination_path'], s + '.zarr'))
            l.append(os.path.join(self._data['data']['destination_path'], 'img_src.zarr', s + str(get_scale_val(s))))
        return l

    def roles(self):
        l, s = self.layer(), self.curScale
        return self._data['data']['scales'][s]['alignment_stack'][l]['images'].keys()

    def set_destination(self, s):
        self._data['data']['destination_path'] = s

    def set_scale(self, s:str) -> None:
        '''Sets the Current Scale.'''
        self._data['data']['current_scale'] = s
        self.curScale = s

    def set_layer(self, index:int) -> None:
        '''Sets Current Layer To Index.'''
        # logger.info('caller: %s...' % inspect.stack()[1].function)
        assert isinstance(index, int)
        # logger.info(f'Setting Current Layer #{index}, {self.curScale}')
        self._data['data']['current_layer'] = index

    def set_previous_results(self, s=None):
        logger.info('Setting PREVIOUS SNR, caller: %s...' % inspect.stack()[1].function)
        if s == None: s = self.curScale
        logger.info('')
        try:
            for l in range(len(self)):
                self._data['data']['scales'][s]['alignment_stack'][l][
                    'alignment']['previous_method_results'] = \
                    self._data['data']['scales'][s]['alignment_stack'][l][
                        'alignment']['method_results']
        except:
            print_exception()
            logger.warning('Unable to set previous SNR...')

    def set_skip(self, b: bool, s=None, l=None) -> None:
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        '''Sets the Bounding Rectangle On/Off State for the Current Scale.'''
        self._data['data']['scales'][s]['alignment_stack'][l]['skipped'] = b

    def set_whitening(self, f: float) -> None:
        '''Sets the Whitening Factor for the Current Layer.'''
        self._data['data']['scales'][self.curScale]['alignment_stack'][self.layer()][
            'alignment']['method_data']['whitening_factor'] = f

    def set_swim_window(self, f: float) -> None:
        '''Sets the SWIM Window for the Current Layer.'''
        self._data['data']['scales'][self.curScale]['alignment_stack'][self.layer()][
            'alignment']['method_data']['win_scale_factor'] = f

    def set_use_bounding_rect(self, b: bool, s=None) -> None:
        '''Sets the Bounding Rectangle On/Off State for the Current Scale.'''
        if s == None:
            for s in self.scales():
                self._data['data']['scales'][s]['use_bounding_rect'] = bool(b)
        else:
            self._data['data']['scales'][s]['use_bounding_rect'] = bool(b)

    def set_bounding_rect(self, bounding_rect: list, s=None) -> None:
        if s == None: s = self.curScale
        self._data['data']['scales'][s]['bounding_rect'] = bounding_rect

    def set_calculate_bounding_rect(self, s=None):
        if s == None: s = self.curScale
        self.set_bounding_rect(ComputeBoundingRect(self.alstack(s=s)))
        return self.bounding_rect()

    def set_image_size(self, s) -> None:
        self._data['data']['scales'][s]['image_src_size'] = ImageSize(self.path_base(s=s))
        val = self._data['data']['scales'][s]['image_src_size']
        # logger.info(f'Just Set {s} image size to {val}')
        logger.info(f'Scale Image Sizes Resolved, {self.scale_pretty(s=s)}: {self.image_size(s=s)}')

    def set_image_size_directly(self, size, s=None):
        if s == None: s = self.curScale
        logger.info(f"Setting Image Sizes Directly, {s}, ImageSize: {size}")
        self._data['data']['scales'][s]['image_src_size'] = size

    def set_poly_order(self, x: int) -> None:
        '''Sets the Polynomial Order for the Current Scale.'''
        self._data['data']['scales'][self.curScale]['poly_order'] = int(x)

    def set_use_poly_order(self, b: bool) -> None:
        '''Sets the Null Cafm Trends On/Off State for the Current Scale.'''
        self._data['data']['scales'][self.curScale]['null_cafm_trends'] = bool(b)

    # def make_absolute(file_path, proj_path):
    #     abs_path = os.path.join(os.path.split(proj_path)[0], file_path)
    #     return abs_path

    def set_al_dict(self, aldict, s=None):
        if s == None: s = self.curScale
        try:
            self._data['data']['scales'][s]['alignment_stack'] = aldict
        except:
            logger.warning('Unable to set alignment dict')

    def remove_aligned(self, scale, start, end):
        '''
        Removes previously generated aligned images for the current s, starting at l 'start_layer'.
        :param use_scale: The s to remove aligned images from.
        :type use_scale: str

        :param start_layer: The starting l index from which to remove all aligned images, defaults to 0.
        :type start_layer: int
        '''
        cfg.main_window.hud.post(f'Removing Aligned for Current Scale...')
        try:
            for layer in self._data['data']['scales'][scale]['alignment_stack'][start:end]:
                ifn = layer['images'].get('filename', None)
                layer['images'].pop('aligned', None)
                if ifn != None:
                    try:     os.remove(ifn)
                    except:  logger.warning(f'os.remove({ifn}) Raised An Exception')
        except:
            print_exception()
            cfg.main_window.warn('An Exception Was Raisied While Removing Previous Alignment...')
        else:
            cfg.main_window.hud.done()

    def set_afm(self, afm: list, s=None, l=None) -> None:
        '''set afm as list of lists of floats'''
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['cumulative_afm'] = afm
        except:
            print_exception()

    def set_cafm(self, cafm: list, s=None, l=None) -> None:
        '''set cafm as list of lists of floats'''
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        try:
            self._data['data']['scales'][s]['alignment_stack'][l][
                'alignment']['method_results']['cumulative_afm'] = cafm
        except:
            print_exception()

    def selected_method(self, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        return self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['selected_method']

    def set_selected_method(self, method, s=None, l=None):
        if s == None: s = self.curScale
        if l == None: l = self.layer()
        logger.info(f'Setting method for section #{l}, {s} to {method}...')
        cfg.main_window.hud.post(f'Setting method for section #{l}, {s} to {method}...')
        self._data['data']['scales'][s]['alignment_stack'][l]['alignment']['selected_method'] = method


    def set_destination_absolute(self, head):
        head = os.path.split(head)[0]
        self.set_destination(os.path.join(head, self.dest()))

    def set_paths_absolute(self, filename):
        logger.info(f'Setting Absolute File Paths...')
        # returns path to project file minus extension (should be the project directory)
        self.set_destination(os.path.splitext(filename)[0])
        logger.debug(f'Setting absolute project dest/head: {self.dest()}...')
        try:
            head = self.dest()
            for s in self.scales():
                if s == 'scale_1':
                    pass
                else:
                    for l in self._data['data']['scales'][s]['alignment_stack']:
                        # for r in l['images'].keys():
                        # if (not l==0) and (not r=='ref'):
                        # tail = l['images'][r]['filename']
                        tail = l['filename']
                        # l['images'][r]['filename'] = os.path.join(head, tail)
                        l['filename'] = os.path.join(head, tail)
                    # self._data['data']['scales'][s]['alignment_stack'][0]['images']['ref']['filename'] = None
        except:
            logger.warning('Setting Absolute Paths Triggered This Exception')
            print_exception()


    def alstack(self, s=None) -> dict:
        if s == None: s = self.scale()
        return self._data['data']['scales'][s]['alignment_stack']


    def aligned_list(self) -> list[str]:
        '''Deprecate this

        Get aligned scales list. Check project datamodel and aligned Zarr group presence.'''
        lst = []
        for s in self.scales():
            r = self._data['data']['scales'][s]['alignment_stack'][-1]['alignment']['method_results']
            if r != {}:
                lst.append(s)
        for s in lst:
            if not exist_aligned_zarr(s):
                lst.remove(s)
        return lst

    # def not_aligned_list(self) -> list[str]:
    #     '''Get not aligned scales list.'''
    #     lst = []
    #     for s in self.scales():
    #         if not exist_aligned_zarr(s):
    #             lst.append(s)
    #     logger.debug('Not Aligned Scales List: %s ' % str(lst))
    #     return lst

    def not_aligned_list(self):
        return set(self.scales()) - set(self.scalesAlignedAndGenerated)

    def coarsest_scale_key(self) -> str:
        '''Return the coarsest s key. '''
        return natural_sort([key for key in self._data['data']['scales'].keys()])[-1]

    def next_coarsest_scale_key(self) -> str:
        if self.n_scales() == 1:
            return self.curScale
        scales_dict = self._data['data']['scales']
        cur_scale_key = self.curScale
        coarsest_scale = list(scales_dict.keys())[-1]
        if cur_scale_key == coarsest_scale:
            return cur_scale_key
        scales_list = []
        for scale_key in scales_dict.keys():
            scales_list.append(scale_key)
        cur_scale_index = scales_list.index(cur_scale_key)
        next_coarsest_scale_key = scales_list[cur_scale_index + 1]
        return next_coarsest_scale_key

    def is_alignable(self) -> bool:
        '''Checks if the current scale is able to be aligned'''
        try:
            if self.nSections < 1:
                logger.debug("Returning False because self.nSections < 1")
                return False
            scales_list = self.scales()
            cur_scale_key = self.curScale
            coarsest_scale = scales_list[-1]
            if cur_scale_key == coarsest_scale:
                logger.debug("is_alignable returning True because: "
                             "cur_scale_key == coarsest_scale) is True")
                return True
            cur_scale_index = scales_list.index(cur_scale_key)
            next_coarsest_scale_key = scales_list[cur_scale_index + 1]
            if not cfg.data.is_aligned(s=next_coarsest_scale_key):
                logger.debug("is_alignable returning False because: "
                             "not exist_aligned_zarr(next_coarsest_scale_key) is True")
                return False
            else:
                logger.debug('Returning True')
                return True
        except:
            print_exception()

    def clear_all_skips(self):
        cfg.main_window.tell('Resetting Skips...')
        try:
            for scale in self.scales():
                scale_key = str(scale)
                for layer in self._data['data']['scales'][scale_key]['alignment_stack']:
                    layer['skipped'] = False
        except:
            print_exception()

    def append_image(self, file):
        scale = self.scale()
        # logger.info("Adding Image: %s, role: base, scale: %s" % (file, scale))
        self._data['data']['scales'][scale]['alignment_stack'].append(copy.deepcopy(layer_template))
        self._data['data']['scales'][scale]['alignment_stack'][self.n_sections() - 1]['filename'] = file
        self._data['data']['scales'][scale]['alignment_stack'][self.n_sections() - 1]['reference'] = ''

    def append_empty(self):
        logger.critical('MainWindow.append_empty:')
        scale = self.curScale
        used_for_this_role = ['base' in l['images'].keys() for l in self.alstack(s=scale)]
        layer_index = -1
        if False in used_for_this_role:
            layer_index = used_for_this_role.index(False)
        else:
            self._data['data']['scales'][scale]['alignment_stack'].append(copy.deepcopy(layer_template))
            layer_index_for_new_role = len(self['data']['scales'][scale]['alignment_stack']) - 1
        self._data['data']['scales'][scale]['alignment_stack'][layer_index]['filename'] = ''


    # def add_img(self, scale, layer, role, filename=''):
    #     logger.info(f'Adding Image ({scale}, {layer}, {role}): {filename}...')
    #     self._data['data']['scales'][scale]['alignment_stack'][layer]['images'][role] = copy.deepcopy(image_template)
    #     self._data['data']['scales'][scale]['alignment_stack'][layer]['images'][role]['filename'] = filename
    #     self._data['data']['scales'][scale]['alignment_stack'][layer]['img'] = copy.deepcopy(image_template) # 0119+
    #     self._data['data']['scales'][scale]['alignment_stack'][layer]['img'] = filename                      # 0119+


    def update_datamodel(self, updated_model):
        '''This function is called by align_layers and regenerate_aligned. It is called when
        'run_json_project' returns with need_to_write_json=false'''
        logger.info('Updating Data Model...')
        # Load the alignment stack after the alignment has completed
        aln_image_stack = []
        scale = self.curScale
        for layer in self.alstack():
            image_name = None
            if 'base' in layer['images'].keys():
                # image_name = layer['images']['base']['filename']
                image_name = layer['filename']
            # Convert from the base name to the standard aligned name:
            name = None
            if image_name is not None:
                if scale == "scale_1":
                    name = os.path.join(os.path.abspath(self._data['data']['destination_path']),
                                        scale, 'img_aligned', os.path.split(image_name)[-1])
                else:
                    name_parts = os.path.split(image_name)
                    if len(name_parts) >= 2:
                        name = os.path.join(os.path.split(name_parts[0])[0], os.path.join('img_aligned', name_parts[1]))
            aln_image_stack.append(name)
            logger.info("Adding aligned image %s" % name)
            # layer['images']['aligned'] = {}
            # layer['images']['aligned']['filename'] = name
            layer['filename'] = name
        try:
            cfg.main_window.load_images_in_role('aligned', aln_image_stack)
        except:
            print_exception()

    def are_there_any_skips(self) -> bool:
        if len(self.skips_list()) > 0:
            return True
        else:
            return False

    def set_method_options(self):
        coarsest = self.coarsest_scale_key()
        for s in self.scales():
            if s == coarsest:  self._data['data']['scales'][s]['method_data']['alignment_option'] = 'init_affine'
            else:  self._data['data']['scales'][s]['method_data']['alignment_option'] = 'refine_affine'
            for i in range(self.n_scales()):
                layer = self._data['data']['scales'][s]['alignment_stack'][i]
                if s == coarsest:
                    layer['alignment']['method_data']['alignment_option'] = 'init_affine'
                else:
                    layer['alignment']['method_data']['alignment_option'] = 'refine_affine'



    def set_scales_from_string(self, scale_string: str):
        '''This is not pretty. Needs to be refactored ASAP.
        Two callers: 'new_project', 'prepare_generate_scales_worker'
        '''
        logger.info('')
        cur_scales = list(map(str, cfg.data.scale_vals()))
        try:
            input_scales = [str(v) for v in sorted([get_scale_val(s) for s in scale_string.strip().split(' ')])]
        except:
            logger.error(f'Bad input: {scale_string}. Scales Unchanged.')
            input_scales = []

        if (input_scales != cur_scales):
            input_scale_keys = [get_scale_key(v) for v in input_scales]
            scales_to_remove = list(set(self.scales()) - set(input_scale_keys) - {'scale_1'})
            logger.info(f'Removing Scale Keys: {scales_to_remove}...')
            for key in scales_to_remove:
                self._data['data']['scales'].pop(key)
            scales_to_add = list(set(input_scale_keys) - set(self.scales()))
            logger.info(f'Adding Scale Keys (copying from scale_1): {scales_to_add}...')
            for key in scales_to_add:
                new_stack = [deepcopy(l) for l in self.alstack(s='scale_1')]
                self._data['data']['scales'][key] = \
                    {'alignment_stack': new_stack, 'method_data': { 'alignment_option': 'init_affine' } }

    # def set_default_data(self):
    #     '''Ensure Proper Data Structure (that the previewmodel is usable)...'''
    #     logger.debug('Ensuring called by %s' % inspect.stack()[1].function)
    #     '''  '''
    #     scales_dict = self._data['data']['scales']
    #     coarsest = list(scales_dict.keys())[-1]
    #     for scale_key in scales_dict.keys():
    #         scale = scales_dict[scale_key]
    #         scale.setdefault('use_bounding_rect', cfg.DEFAULT_BOUNDING_BOX)
    #         scale.setdefault('null_cafm_trends', cfg.DEFAULT_NULL_BIAS)
    #         scale.setdefault('poly_order', cfg.DEFAULT_POLY_ORDER)
    #         for layer_index in range(len(scale['alignment_stack'])):
    #             layer = scale['alignment_stack'][layer_index]
    #             layer.setdefault('alignment', {})
    #             layer['alignment'].setdefault('method_data', {})
    #             layer['alignment']['method_data'].setdefault('win_scale_factor', cfg.DEFAULT_SWIM_WINDOW)
    #             layer['alignment']['method_data'].setdefault('whitening_factor', cfg.DEFAULT_WHITENING)
    #             if scale_key == coarsest:
    #                 layer['alignment']['method_data']['alignment_option'] = 'init_affine'
    #             else:
    #                 layer['alignment']['method_data']['alignment_option'] = 'refine_affine'


    def link_reference_sections(self):
        '''Called by the functions '_callbk_skipChanged' and 'import_multiple_images'
        Link layers, taking into accounts skipped layers'''
        # self.set_default_data()  # 0712 #0802 #original
        for s in self.scales():
            skip_list = self.skips_indices()
            for layer_index in range(len(self)):
                base_layer = self._data['data']['scales'][s]['alignment_stack'][layer_index]
                if (layer_index == 0) or (layer_index in skip_list):
                    self._data['data']['scales'][s]['alignment_stack'][layer_index]['reference'] = ''
                else:
                    j = layer_index - 1  # Find nearest previous non-skipped l
                    while (j in skip_list) and (j >= 0):
                        j -= 1
                    if (j not in skip_list) and (j >= 0):
                        ref = self._data['data']['scales'][s]['alignment_stack'][j]['filename']
                        ref = os.path.join(self.dest(), s, 'img_src', ref)
                        # base_layer['images']['ref']['filename'] = ref
                        base_layer['reference'] = ref


    def upgrade_data_model(self):
        # Upgrade the "Data Model"
        if self._data['version'] != self._current_version:
            logger.critical('Upgrading Data Model...')

            # Begin the upgrade process:

            if self._data['version'] <= 0.26:
                logger.info("Upgrading datamodel previewmodel from " + str(self._data['version']) + " to " + str(0.27))
                # Need to modify the datamodel previewmodel from 0.26 or lower up to 0.27
                # The "alignment_option" had been in the method_data at each l
                # This new version defines it only at the s level
                # So loop through each s and move the alignment_option from the l to the s
                for scale_key in self.scales():
                    scale = self._data['data']['scales'][scale_key]
                    stack = scale['alignment_stack']
                    current_alignment_options = []
                    for layer in stack:
                        if "alignment" in layer:
                            align_method = layer['alignment']
                            if 'method_data' in align_method:
                                if 'alignment_option' in align_method['method_data']:
                                    current_alignment_options.append(align_method['method_data']['alignment_option'])
                    # The current_alignment_options list now holds all of the options for this s (if any)
                    # Start by setting the default for the s option to "init_affine" if none are found
                    scale_option = "init_affine"
                    # If any options were found in this s, search through them for most common
                    if len(current_alignment_options) > 0:
                        # They should all be the same at this s, so set to the first
                        scale_option = current_alignment_options[0]
                        # But check if any are different and then find the most common
                        if current_alignment_options.count(current_alignment_options[0]) != len(
                                current_alignment_options):
                            # There are some that are different, so find the most common option
                            scale_option = max(set(current_alignment_options), key=current_alignment_options.count)
                    # At this point "scale_option" should be the one to use
                    if not ('method_data' in scale):
                        # Ensure that there's some method datamodel
                        scale['method_data'] = {}
                    # Finally set the value
                    scale['method_data']["alignment_option"] = scale_option
                # Now the datamodel previewmodel is at 0.27, so give it the appropriate version
                self._data['version'] = 0.27

            if self._data['version'] == 0.27:
                print("\n\nUpgrading datamodel previewmodel from " + str(self._data['version']) + " to " + str(0.28))
                # Need to modify the datamodel previewmodel from 0.27 up to 0.28
                # The "alignment_option" had been left in the method_data at each l
                # This new version removes that option from the l method datamodel
                # So loop through each s and remove the alignment_option from the l
                for scale_key in self.scales():
                    scale = self._data['data']['scales'][scale_key]
                    stack = scale['alignment_stack']
                    current_alignment_options = []
                    for layer in stack:
                        if "alignment" in layer:
                            align_method = layer['alignment']
                            if 'method_data' in align_method:
                                if 'alignment_option' in align_method['method_data']:
                                    align_method['method_data'].pop('alignment_option')
                # Now the datamodel previewmodel is at 0.28, so give it the appropriate version
                self._data['version'] = 0.28

            if self._data['version'] == 0.28:
                print("\n\nUpgrading datamodel previewmodel from " + str(self._data['version']) + " to " + str(0.29))
                # Need to modify the datamodel previewmodel from 0.28 up to 0.29
                # The "use_c_version" was added to the "user_settings" dictionary
                # self._data['user_settings']['use_c_version'] = True #0206-
                # Now the datamodel previewmodel is at 0.29, so give it the appropriate version
                self._data['version'] = 0.29

            if self._data['version'] == 0.29:
                print("\n\nUpgrading datamodel previewmodel from " + str(self._data['version']) + " to " + str(0.30))
                # Need to modify the datamodel previewmodel from 0.29 up to 0.30
                # The "poly_order" was added to the "scales" dictionary
                for scale_key in self.scales():
                    scale = self._data['data']['scales'][scale_key]
                    scale['poly_order'] = 4
                # Now the datamodel previewmodel is at 0.30, so give it the appropriate version
                self._data['version'] = 0.30

            if self._data['version'] == 0.30:
                print("\n\nUpgrading datamodel previewmodel from " + str(self._data['version']) + " to " + str(0.31))
                # Need to modify the datamodel previewmodel from 0.30 up to 0.31
                # The "skipped(1)" annotation is currently unused (now hard-coded in alignem.py)
                # Remove alll "skipped(1)" annotations since they can not otherwise be removed
                for scale_key in self.scales():
                    scale = self._data['data']['scales'][scale_key]
                    stack = scale['alignment_stack']
                    for layer in stack:
                        for role in layer['images'].keys():
                            image = layer['images'][role]
                            print("Checking for annotations in image...")
                            if 'metadata' in image.keys():
                                print("Checking for annotations in metadata...")
                                m = image['metadata']
                                if 'annotations' in m.keys():
                                    print("Removing any \"skipped()\" annotations ... ")
                                    m['annotations'] = [a for a in m['annotations'] if not a.startswith('skipped')]
                # Now the datamodel previewmodel is at 0.31, so give it the appropriate version
                self._data['version'] = 0.31
            if self._data['version'] == 0.31:
                print("\n\nUpgrading datamodel previewmodel from " + str(self._data['version']) + " to " + str(0.32))
                # Need to modify the datamodel previewmodel from 0.31 up to 0.32
                #   1) change name of method_results key "affine_matrix" to "afm"
                #   2) change name of method_results key "cumulative_afm" to "cafm"
                #   3) add new method_results key, "aim" and compute/store this value
                #   4) add new method_results key, "c_aim" and compute/store this value
                #   5) add new method_results key, "reconstruct_x_coeff" and compute/store this value
                #   6) add new method_results key, "reconstruct_y_coeff" and compute/store this value
                #   7) add new s key, "bounding_rect_x" and compute/store this value
                #   8) add new s key, "bounding_rect_y" and compute/store this value
                # Note, aim and c_aim are the inverse of afm and cafm
                # Note, cafm and c_aim are the now the cumulative matrices not including
                #       the bounding rect.
                # Note, reconstruct_x_coeff and _y_coeff are the coefficients of the
                #       dim 3 polynomial basis transforms used by RECONSTRUCT.
                #       These coefficients do not include the bounding rect terms.
                #

                # FIXME: leave this commented out until we have finished 1-8 above
                # Now the datamodel previewmodel is at 0.32, so give it the appropriate version
                # data_model ['version'] = 0.32

            # Make the final test
            if self._data['version'] != self._current_version:
                # The datamodel previewmodel could not be upgraded, so return a string with the error
                data_model = 'Version mismatch. Expected "' + str(
                    self._current_version) + '" but found ' + str(
                    self._data['version'])

    # def update_init_rot(self):
    #     image_scales_to_run = [self.scale_val(s) for s in sorted(self._data['data']['scales'].keys())]
    #     for s in sorted(image_scales_to_run):  # i.e. string '1 2 4'
    #         scale_key = self.get_scale_key(s)
    #         for i, l in enumerate(self._data['data']['scales'][scale_key]['alignment_stack']):
    #             l['alignment']['method_options'] = {'initial_rotation': cfg.DEFAULT_INITIAL_ROTATION}
    #     logger.critical('cfg.DEFAULT_INITIAL_ROTATION = %f' % cfg.DEFAULT_INITIAL_ROTATION)
    #
    # def update_init_scale(self):
    #     image_scales_to_run = [self.scale_val(s) for s in sorted(self._data['data']['scales'].keys())]
    #     for s in sorted(image_scales_to_run):  # i.e. string '1 2 4'
    #         scale_key = self.get_scale_key(s)
    #         for i, l in enumerate(self._data['data']['scales'][scale_key]['alignment_stack']):
    #             l['alignment']['method_options'] = {'initial_scale': cfg.DEFAULT_INITIAL_SCALE}
    #     logger.critical('cfg.DEFAULT_INITIAL_SCALE = %f' % cfg.DEFAULT_INITIAL_SCALE)


    def clear_method_results(self, scale=None, start=0, end=None):
        if scale == None: scale = cfg.data.scale()
        logger.info("Clearing 'method_results'...")
        for layer in self._data['data']['scales'][scale]['alignment_stack'][start:end]:
            layer['alignment']['method_results'] = {}


    def make_paths_relative(self, start):
        self.set_destination(os.path.relpath(self.dest(), start=start))
        for s in self.downscales():
            for layer in self.alstack(s=s):
                for role in layer['images'].keys():
                    layer['filename'] = os.path.relpath(layer['filename'], start=start)
                    layer['reference'] = os.path.relpath(layer['reference'], start=start)


@dataclass
class StripNullFields:
    def asdict(self):
        result = {}
        for k, v in self.__dict__.items():
            if v is not None:
                if hasattr(v, "asdict"):
                    result[k] = v.asdict()
                elif isinstance(v, list):
                    result[k] = []
                    for element in v:
                        if hasattr(element, "asdict"):
                            result[k].append(element.asdict())
                        else:
                            result[k].append(element)
                else:
                    result[k] = v
        return result
data_template = \
    {
        "version": 0.50,
        "created": '',
        # "method": "None",
        "system": {
            "node": None,
        },
        "state": {
            "MANUAL_MODE": False
        },
        "rendering": {
            "normalize": [1,255],
            "brightness": 0,
            "contrast": 0,
        },
        "ui": {
            "ng_layout": '4panel',
            "arrangement": 'stack',
        },
        "data": {
            "shader": None,
            "source_path": "",
            "destination_path": "",
            "current_layer": 0,
            "current_scale": "scale_1",
            "t_scaling": 0.0,
            "t_scaling_convert_zarr": 0.0,
            "t_thumbs": 0.0,
            "thumb_scaling_factor_source": None,
            "scales": {
                "scale_1": {
                    "method_data": {
                        "alignment_option": "init_affine"
                    },
                    "null_cafm_trends": cfg.DEFAULT_NULL_BIAS,
                    "use_bounding_rect": cfg.DEFAULT_BOUNDING_BOX,
                    "alignment_stack": [],
                    "t_align": 0.0,
                    "t_generate": 0.0,
                    "t_convert_zarr": 0.0,
                    "t_thumbs_aligned": 0.0,
                    "t_thumbs_spot": 0.0,
                    "thumb_scaling_factor_aligned": None,
                    "thumb_scaling_factor_corr_spot": None,
                }
            },
        },

    }

layer_template = \
    {
        "alignment": {
            "method_data": {},
            "method_options": {},
            "selected_method": "Auto-SWIM",
            "manual_points": {
                "ref": [],
                'base': []
            },
            "method_results": {
                "snr": [],
                "snr_prev": [],
            }
        },
        "images": {},
        "skipped": False,
        "notes": ""
    }

image_template = \
    {
        "filename": None,
        "metadata": {
            "annotations": [],
            "manual_points": []
        }
    }
__all__ = ['preallocate_zarr', 'tiffs2MultiTiff', 'write_metadata_zarr_multiscale']

logger = logging.getLogger(__name__)


def get_zarr_tensor(zarr_path):
    '''
    Returns an asynchronous TensorStore future object which is a webengineview
    into the Zarr image on disk. All TensorStore indexing operations
    produce lazy views.

    Ref: https://stackoverflow.com/questions/64924224/getting-a-view-of-a-zarr-array-slice

    :param zarr_path:
    :type zarr_path:
    :return: A webengineview into the dataset.
    :rtype: tensorstore.Future
    '''

    node = platform.node()
    if '.tacc.utexas.edu' in node:
        # Lonestar6: 256 GB (3200 MT/s) DDR4
        # total_bytes_limit = 200_000_000_000
        total_bytes_limit = 250_000_000_000 # just under 256 GB
    else:
        total_bytes_limit = 6_000_000_000
    # total_bytes_limit = (6_000_000_000, 200_000_000_000_000)['.tacc.utexas.edu' in platform.node()]
    arr = ts.open({
        'dtype': 'uint8',
        'driver': 'zarr',
        'kvstore': {
            'driver': 'file',
            # 'driver': 'memory',
            'path': zarr_path
        },
        'context': {
            'cache_pool': {'total_bytes_limit': total_bytes_limit},
            # 'data_copy_concurrency': {'limit': 128},
            # 'file_io_concurrency': {'limit': 128},
        },
        'recheck_cached_data': 'open',
    })
    return arr


def get_zarr_array_layer_view(zarr_path:str, l=None):
    if l == None: l = cfg.data.layer()
    arr = ts.open({
        'driver': 'zarr',
        'kvstore': {
            'driver': 'file',
            'path': zarr_path,
        },
        'path': 'temp.zarr',
        'metadata': {
            'dtype': '<f4',
            'shape': list(cfg.data.resolution()),
            'chunks': list(cfg.data.chunkshape()),
            'order': 'C',
        },
    }, create=True).result()
    # arr[1] = 42  # Overwrites, just like numpy/zarr library
    view = arr[l, :, :]  # Returns a lazy view, no I/O performed
    np.array(view)  # Reads from the view
    # Returns JSON spec that can be passed to `ts.open` to reopen the view.
    view.spec().to_json()
    return view


def get_tensor_from_tiff(dir=None, s=None, l=None):
    if s == None: s = cfg.data.scale()
    if l == None: l = cfg.data.layer()
    fn = os.path.basename(cfg.data.base_image_name(s=s, l=l))
    path = os.path.join(cfg.data.dest(), s, 'img_src', fn)
    logger.info('Path: %s' % path)
    arr = ts.open({
        'driver': 'tiff',
        'kvstore': {
            'driver': 'file',
            'path': path,
        },
    }, create=True).result()
    return arr


def get_zarr_tensor_layer(zarr_path:str, layer:int):
    '''
    Returns an asynchronous TensorStore future object which is a webengineview
    into the Zarr image on disk. All TensorStore indexing operations
    produce lazy views.

    Ref: https://stackoverflow.com/questions/64924224/getting-a-view-of-a-zarr-array-slice

    :param zarr_path:
    :type zarr_path:
    :return: A webengineview into the dataset.
    :rtype: tensorstore.Future
    '''
    node = platform.node()
    if '.tacc.utexas.edu' in node:
        # Lonestar6: 256 GB (3200 MT/s) DDR4
        # total_bytes_limit = 200_000_000_000
        total_bytes_limit = 200_000_000_000_000
    else:
        total_bytes_limit = 8_000_000_000
    # total_bytes_limit = (6_000_000_000, 200_000_000_000_000)['.tacc.utexas.edu' in platform.node()]
    arr = ts.open({
        'driver': 'zarr',
        'kvstore': { 'driver': 'file', 'path': zarr_path },
        'context': { 'cache_pool': { 'total_bytes_limit': total_bytes_limit} },
        'recheck_cached_data': 'open',
    }, dtype=ts.uint32,)
    slice = np.array(arr[layer,:, :])
    # return arr[layer, :, :]
    return slice


def loadTiffsMp(directory:str):
    '''
    :param directory: Directory containing TIF images.
    :type directory: str
    :return: image_arrays
    :rtype: list[numpy.ndarray]
    '''
    tifs = glob(os.path.join(directory, '*.tif'))
    cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
    pool = mp.Pool(processes=cpus)
    start = time.time()
    image_arrays = pool.map(imageio_read_image, tifs)
    dt = time.time() - start
    logger.critical('Writing the Multipage Tiff Took %g Seconds' % dt)

    return image_arrays


# def tiffs2MultiTiff(directory:str, out:str, n_frames:int, width:int, height:int):
def tiffs2MultiTiff(directory:str, out:str):
    # tifs = list(pathlib.Path(directory).glob('*.tif'))
    image_arrays = loadTiffsMp(directory=directory) # image_arrays is a list of numpy arrays
    with tifffile.TiffWriter(out, bigtiff=True) as file:
        file.write(image_arrays)
    # write_multipage(tifs, out)
    # imageio.mimwrite(out, tifs)
    # a = np.ones((n_frames, width, height), dtype=np.uint8)
    # imlist = []
    # for m in a:
    #     imlist.append(Image.fromarray(m))
    # imlist[0].save("test.tif", compression="tiff_deflate", save_all=True, append_images=imlist[1:])


def remove_zarr(path) -> None:
    if os.path.isdir(path):
        logger.info('Removing Extant Zarr Located at %s' % path)
        try:
            with time_limit(20):
                shutil.rmtree(path, ignore_errors=True)
        except TimeoutError as e:
            logger.warning("Timed out!")
        logger.info('Done Removing Zarr')


def preallocate_zarr(name, group, dimx, dimy, dimz, dtype, overwrite):
    '''zarr.blosc.list_compressors() -> ['blosclz', 'lz4', 'lz4hc', 'zlib', 'zstd']'''
    cname, clevel, chunkshape = cfg.data.get_user_zarr_settings()
    src = os.path.abspath(cfg.data.dest())
    path_zarr = os.path.join(src, name)
    path_out = os.path.join(path_zarr, group)
    path_base = os.path.basename(src)
    path_relative = os.path.join(path_base, name)
    logger.info(f'Preallocating Zarr Array (caller: {inspect.stack()[1].function})...'
                    f' dimx: {dimx}, dimy: {dimy}, dimz: {dimz}')

    cfg.main_window.hud(f'Preallocating {path_base}/{group} Zarr...')
    if os.path.exists(path_out) and (overwrite == False):
        logger.warning('Overwrite is False - Returning')
        return
    shape = (dimz, dimy, dimx)  # Todo check this, inverting x & y

    output_text = f'\n  Zarr root : {path_relative}' \
                  f'\n      group :   └ {group}({name}) {dtype} {cname}/{clevel}' \
                  f'\n      shape : {str(shape)} ' \
                  f'\n      chunk : {chunkshape}'

    try:
        if overwrite and os.path.exists(path_out):
            remove_zarr(path_out)
        # synchronizer = zarr.ThreadSynchronizer()
        # arr = zarr.group(store=path_zarr, synchronizer=synchronizer) # overwrite cannot be set to True here, will overwrite entire Zarr
        arr = zarr.group(store=path_zarr)
        # compressor = Blosc(cname=cname, clevel=clevel) if cname in ('zstd', 'zlib', 'gzip') else None
        if cname in ('zstd', 'zlib', 'gzip'):
            compressor = Blosc(cname=cname, clevel=clevel)
        # elif cname == 'zstd':
        #     zarr.storage.default_compressor = Zstd(level=1)
            # compressor = Zstd(level=clevel)
        else:
            compressor = None

        # if cname == 'zstd':
        #     arr.zeros(name=group, shape=shape, chunks=chunkshape, dtype=dtype, overwrite=overwrite)
        # else:
        # arr.zeros(name=group, shape=shape, chunks=chunkshape, dtype=dtype, compressor=compressor, overwrite=overwrite, synchronizer=synchronizer)
        arr.zeros(name=group, shape=shape, chunks=chunkshape, dtype=dtype, compressor=compressor, overwrite=overwrite)
        '''dtype definitely sets the dtype, otherwise goes to float64 on Lonestar6, at least for use with tensorstore'''
        # write_metadata_zarr_multiscale() # thon3 al   write single multiscale zarr for all aligned s
    except:
        print_exception()
        cfg.main_window.warn('Zarr Preallocation Encountered A Problem')
    else:
        cfg.main_window.hud.done()
        # cfg.main_window.hud(output_text)
        logger.info(output_text)


def write_metadata_zarr_multiscale(path):
    root = zarr.group(store=path)
    datasets = []
    for scale in cfg.data.scalesAlignedAndGenerated:
        scale_factor = get_scale_val(scale)
        name = 's' + str(scale_factor)
        metadata = {
            "path": name,
            "coordinateTransformations": [{
                "type": "s",
                "s": [float(50.0), 2 * float(scale_factor), 2 * float(scale_factor)]}]
        }
        datasets.append(metadata)
    axes = [
        {"name": "z", "type": "space", "unit": "nanometer"},
        {"name": "y", "type": "space", "unit": "nanometer"},
        {"name": "x", "type": "space", "unit": "nanometer"}
    ]
    root.attrs['_ARRAY_DIMENSIONS'] = ["z", "y", "x"]
    root.attrs['multiscales'] = [
        {
            "version": "0.4",
            "name": "my_data",
            "axes": axes,
            "datasets": datasets,
            "type": "gaussian",
        }
    ]


def write_metadata_zarr_aligned(name='img_aligned.zarr'):
    zarr_path = os.path.join(cfg.data.dest(), name)
    root = zarr.group(store=zarr_path)
    datasets = []
    # scale_factor = scale_val(cfg.datamodel.s())
    scale_factor = cfg.data.scale_val()
    name = 's' + str(scale_factor)
    metadata = {
        "path": name,
        "coordinateTransformations": [{
            "type": "s",
            "s": [float(50.0), 2 * float(scale_factor), 2 * float(scale_factor)]}]
    }
    datasets.append(metadata)

    axes = [
        {"name": "z", "type": "space", "unit": "nanometer"},
        {"name": "y", "type": "space", "unit": "nanometer"},
        {"name": "x", "type": "space", "unit": "nanometer"}
    ]

    root.attrs['_ARRAY_DIMENSIONS'] = ["z", "y", "x"]
    root.attrs['multiscales'] = [
        {
            "version": "0.4",
            "name": "my_data",
            "axes": axes,
            "datasets": datasets,
            "type": "gaussian",
        }
    ]
__all__ = ['generate_aligned']

logger = logging.getLogger(__name__)


def generate_aligned(scale, start=0, end=None, renew_od=False, reallocate_zarr=True):
    cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
    scale_val = get_scale_val(scale)
    pbar_text = 'Generating Scale %d Alignment w/ MIR (%d Cores)...' % (scale_val, cpus)
    if cfg.CancelProcesses:
        cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
    else:
        logger.critical('Generating Aligned Images...')
        dm = cfg.data

        if ng.is_server_running():
            logger.info('Stopping Neuroglancer...')
            ng.server.stop()

        tryRemoveDatFiles(dm, scale,dm.dest())
        Z_STRIDE = 0

        if cfg.USE_PYTHON:
            job_script = 'job_python_apply_affine.py'
        else:
            '''Default'''
            job_script = 'job_apply_affine.py'
        path = os.path.split(os.path.realpath(__file__))[0]
        job_script = os.path.join(path, job_script)

        alstack = dm.alstack(s=scale)
        print_example_cafms(dm)
        logger.info('Setting Stack CAFM...')
        SetStackCafm(scale=scale, null_biases=dm.null_cafm(s=scale), poly_order=dm.poly_order(s=scale))
        od = os.path.join(dm.dest(), scale, 'img_aligned')
        if renew_od:
            logger.info('Renewing Directory %s...' % od)
            renew_directory(directory=od)
        # print_example_cafms(scale_dict)
        bias_path = os.path.join(dm.dest(), scale, 'bias_data')
        save_bias_analysis(layers=dm.get_iter(s=scale), bias_path=bias_path)
        if end == None:
            end = len(dm)
        n_tasks = len(list(range(start,end)))
        if dm.has_bb():
            # Note: now have got new cafm's -> recalculate bounding box
            rect = dm.set_calculate_bounding_rect(s=scale) # Only after SetStackCafm
            logger.info(f'Bounding Box              : ON\nNew Bounding Box          : {str(rect)}')
            logger.info(f'Null Bias                 : {dm.null_cafm()} (Polynomial Order: {dm.poly_order()})')
        else:
            logger.info(f'Bounding Box              : OFF')
            w, h = dm.image_size(s=scale)
            rect = [0, 0, w, h] # might need to swap w/h for Zarr
        logger.info(f'Aligned Size              : {rect[2:]}')
        logger.info(f'Offsets                   : {rect[0]}, {rect[1]}')
        # args_list = makeTasksList(dm, iter(alstack[start:end]), job_script, scale, rect) #0129-
        cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
        task_queue = TaskQueue(n_tasks=n_tasks, parent=cfg.main_window, pbar_text=pbar_text)
        task_queue.start(cpus)
        for ID, layer in enumerate(iter(alstack[start:end])):
            base_name = layer['filename']
            _ , fn = os.path.split(base_name)
            al_name = os.path.join(dm.dest(), scale, 'img_aligned', fn)
            # layer['images']['aligned'] = {}
            # layer['images']['aligned']['filename'] = al_name
            cafm = layer['alignment']['method_results']['cumulative_afm']
            args = [sys.executable, job_script, '-gray', '-rect',
                    str(rect[0]), str(rect[1]), str(rect[2]), str(rect[3]), '-afm', str(cafm[0][0]), str(cafm[0][1]),
                    str(cafm[0][2]), str(cafm[1][0]), str(cafm[1][1]), str(cafm[1][2]), base_name, al_name]
            task_queue.add_task(args)
            if cfg.PRINT_EXAMPLE_ARGS:
                if ID in [0,1,2]:
                    logger.info('Example Arguments (ID: %d):\n%s' % (ID, '    '.join(map(str,args))))
                # if ID is 7:

        # args_list = reorder_tasks(task_list=args_list, z_stride=Z_STRIDE)
        # for task in args_list:
        #     task_queue.add_task(task)
        try:
            dt = task_queue.collect_results()
            cfg.data.set_t_generate(dt, s=scale)
        except:
            print_exception()
            logger.warning('Task Queue encountered a problem')


    pbar_text = 'Copy-converting Scale %d Alignment To Zarr (%d Cores)...' % (scale_val, cpus)
    if cfg.CancelProcesses:
        cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
    else:
        logger.info('Generating Zarr...')
        if reallocate_zarr:
            logger.info('preallocating')
            preallocate_zarr(name='img_aligned.zarr',
                             group='s%d' % scale_val,
                             dimx=rect[2],
                             dimy=rect[3],
                             dimz=len(cfg.data),
                             dtype='uint8',
                             overwrite=True
                             )

        if cfg.CancelProcesses:
            cfg.main_window.tell('Canceling Copy-convert Alignment to Zarr Tasks...')
        else:
            logger.info('Making Copy-convert Alignment To Zarr Tasks List...')
            # cfg.main_window.set_status('Copy-converting TIFFs...')
            task_queue = TaskQueue(n_tasks=n_tasks, parent=cfg.main_window, pbar_text=pbar_text)
            task_queue.start(cpus)
            job_script = os.path.join(os.path.split(os.path.realpath(__file__))[0], 'job_convert_zarr.py')
            task_list = []
            for ID, layer in enumerate(iter(alstack[start:end])):
                _ , fn = os.path.split(layer['filename'])
                al_name = os.path.join(dm.dest(), scale, 'img_aligned', fn)
                zarr_group = os.path.join(dm.dest(), 'img_aligned.zarr', 's%d' % scale_val)
                args = [sys.executable, job_script, str(ID), al_name, zarr_group]
                task_queue.add_task(args)
                if cfg.PRINT_EXAMPLE_ARGS:
                    if ID in [0,1,2]:
                        logger.info('Example Arguments (ID: %d):\n%s' % (ID, '    '.join(map(str,args))))
                # task_queue.add_task(args)
            logger.info('Adding Tasks To Multiprocessing Queue...')
            try:
                dt = task_queue.collect_results()
                cfg.data.set_t_convert_zarr(dt, s=scale)
            except:
                print_exception()
                logger.warning('Task Queue encountered a problem')

            logger.info('<<<< Generate Aligned End <<<<')


def makeTasksList(dm, iter, job_script, scale, rect, zarr_group):
    logger.info('Making Generate Alignment Tasks List...')
    args_list = []
    dest = dm.dest()
    for ID, layer in enumerate(iter):
        # if ID in [0,1,2]:
        #     logger.info('afm = %s\n' % ' '.join(map(str, datamodel.afm(l=ID))))
        #     logger.info('cafm = %s\n' % ' '.join(map(str, datamodel.cafm(l=ID))))
        base_name = layer['filename']
        _ , fn = os.path.split(base_name)
        al_name = os.path.join(dest, scale, 'img_aligned', fn)
        # layer['images']['aligned'] = {}
        # layer['images']['aligned']['filename'] = al_name
        cafm = layer['alignment']['method_results']['cumulative_afm']
        args = [sys.executable, job_script, '-gray', '-rect',
                str(rect[0]), str(rect[1]), str(rect[2]), str(rect[3]), '-afm', str(cafm[0][0]), str(cafm[0][1]),
                str(cafm[0][2]), str(cafm[1][0]), str(cafm[1][1]), str(cafm[1][2]), base_name, al_name,
                zarr_group, str(ID)]
        if cfg.PRINT_EXAMPLE_ARGS:
            if ID in [0,1,2]:
                logger.info('Example Arguments (ID: %d):\n%s' % (ID, '    '.join(map(str,args))))
            # if ID is 7:
            #     args[2] = '-bogus_option'
            # if ID is 11:
            #     args[15] = 'bogus_file'

        # NOTE - previously had conditional here for 'if use_bounding_rect' then don't pass -rect args
        args_list.append(args)
    return args_list


def tryRemoveFile(directory):
    try:
        os.remove(directory)
    except:
        pass

def tryRemoveDatFiles(dm, scale, path):
    bb_str = str(dm.has_bb())
    poly_order_str = str(dm.poly_order())
    null_cafm_str = str(dm.null_cafm())
    bias_data_path = os.path.join(path, scale, 'bias_data')
    tryRemoveFile(os.path.join(path, scale,
                               'swim_log_' + bb_str + '_' + null_cafm_str + '_' + poly_order_str + '.dat'))
    tryRemoveFile(os.path.join(path, scale,
                               'mir_commands_' + bb_str + '_' + null_cafm_str + '_' + poly_order_str + '.dat'))
    tryRemoveFile(os.path.join(path, scale, 'swim_log.dat'))
    tryRemoveFile(os.path.join(path, scale, 'mir_commands.dat'))
    tryRemoveFile(os.path.join(path, 'fdm_new.txt'))
    tryRemoveFile(os.path.join(bias_data_path, 'snr_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_x_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_y_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_rot_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_scale_x_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_scale_y_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_skew_x_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'bias_det_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'afm_1.dat'))
    tryRemoveFile(os.path.join(bias_data_path, 'c_afm_1.dat'))


def print_example_cafms(dm):
    try:
        # print('-----------------------------------')
        print('First Three CAFMs:')
        print(str(dm.cafm(l=0)))
        print(str(dm.cafm(l=1)))
        print(str(dm.cafm(l=2)))
        # print('-----------------------------------')
    except:
        pass
__all__ = ['generate_multiscale_zarr']

logger = logging.getLogger(__name__)

Z_STRIDE = 1

def generate_multiscale_zarr(src, out):
    logger.critical('Generating Multiscale Zarr...')
    logger.info('src : %s\nout: %s' % (src, out))
    # Todo conditional handling of skips
    tasks_ = []
    imgs = sorted(get_img_filenames(os.path.join(src, cfg.data.scale(), 'img_aligned')))
    logger.info('# images: %d' % len(imgs))
    for ID, img in enumerate(imgs):
        for scale in cfg.data.scalesAlignedAndGenerated:
            scale_val = get_scale_val(scale)
            path_out = os.path.join(out, 's' + str(scale_val))
            tasks_.append([ID, img, src, path_out, scale])
    tasks = [[t for t in tasks_[x::Z_STRIDE]] for x in range(0, Z_STRIDE)]
    logger.info('\n(example task)\n%s' % str(tasks[0]))
    cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
    task_queue = TaskQueue(n_tasks=len(tasks), parent=cfg.main_window, pbar_text='Generating Multiscale Zarr (%d Cores)...' % cpus)
    task_queue.start(cpus)
    for task in tasks:
        script = 'src/job_convert_zarr_scales.py'
        script = 'src/job_convert_zarr.py' #1124
        task_args = [sys.executable,
                     script,
                     str(task[0]),          # ID
                     str(task[1]),          # img
                     str(task[2]),          # src
                     str(task[3]),          # out
                     str(task[4]),          # s str
                     ]
        task_queue.add_task(task_args)
    cfg.main_window.tell('Copy-converting TIFFs to NGFF-Compliant Multiscale Zarr...')
    t0 = time.time()
    task_queue.collect_results()
    dt = time.time() - t0
    logger.info('<<<< Generate Zarr End <<<<')
__all__ = ['generate_scales']

logger = logging.getLogger(__name__)


def generate_scales(dm):
    cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
    pbar_text = 'Generating Scale Image Hierarchy (%d Cores)...' % cpus
    if cfg.CancelProcesses:
        cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
    else:

        n_tasks = len(cfg.data) * (dm.n_scales() - 1)  #0901 #Refactor
        task_queue = TaskQueue(n_tasks=n_tasks, parent=cfg.main_window, pbar_text=pbar_text)
        my_path = os.path.split(os.path.realpath(__file__))[0] + '/'
        create_project_structure_directories(dm.dest(), dm.scales())
        iscale2_c = os.path.join(my_path, 'lib', get_bindir(), 'iscale2')

        # Create Scale 1 Symlinks
        logger.info('Creating Scale 1 symlinks')
        cfg.main_window.tell('Sym-linking full scale images...')
        src_path = dm.source_path()
        for img in dm.basefilenames():
            fn = os.path.join(src_path, img)
            ofn = os.path.join(dm.dest(), 'scale_1', 'img_src', os.path.split(fn)[1])
            # normalize path for different OSs
            if os.path.abspath(os.path.normpath(fn)) != os.path.abspath(os.path.normpath(ofn)):
                try:    os.unlink(ofn)
                except: pass
                try:    os.symlink(fn, ofn)
                except:
                    logger.warning("Unable to link from %s to %s. Copying instead." % (fn, ofn))
                    try:    shutil.copy(fn, ofn)
                    except: logger.warning("Unable to link or copy from " + fn + " to " + ofn)

        task_queue.start(cpus)
        assert dm.downscales() != 'scale_None'
        for s in dm.downscales():  # value string '1 2 4'
            scale_val = get_scale_val(s)
            logger.info("Queuing Downsample Tasks For Scale %d..." % scale_val)
            # for i, layer in enumerate(datamodel.get_iter(s)):
            for i, layer in enumerate(dm['data']['scales'][s]['alignment_stack']):
                base       = dm.base_image_name(s=s, l=i)
                if_arg     = os.path.join(src_path, base)
                ofn        = os.path.join(dm.dest(), s, 'img_src', os.path.split(if_arg)[1]) # <-- wrong path on second project
                of_arg     = 'of=%s' % ofn
                scale_arg  = '+%d' % scale_val
                task_queue.add_task([iscale2_c, scale_arg, of_arg, if_arg])
                if cfg.PRINT_EXAMPLE_ARGS:
                    if i in [0, 1, 2]:
                        logger.info('generate_scales/iscale2 TQ Params (Example ID %d):\n%s' %
                                    (i, '\n'.join(map(str,[iscale2_c, scale_arg, of_arg, if_arg]))))
                # if cfg.CODE_MODE == 'python':
                #     task_queue.add_task(cmd=sys.executable,
                #                         args=['src/job_single_scale.py', str(s), str(fn), str(ofn)], wd='.')
                # layer['images']['base']['filename'] = ofn
                layer['filename'] = ofn #0220+
        dt = task_queue.collect_results()
        results = task_queue.get_status_of_tasks()
        # show_mp_queue_results(task_queue=task_queue, dt=dt)
        cfg.data.set_t_scaling(dt)
        print(f'results : {results}')
        print(f'dt      : {dt}')
        # cfg.results = results
        # cfg.dt = dt
        logger.info('<<<< generate_scales <<<<')
__all__ = ['generate_zarr_scales']

logger = logging.getLogger(__name__)

Z_STRIDE = 1

def generate_zarr_scales(data):
    cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
    pbar_text = 'Generating Zarr Scale Arrays (%d Cores)...' % cpus
    if cfg.CancelProcesses:
        cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
    else:

        logger.info('Generating Scaled Zarr Arrays...')
        # Todo conditional handling of skips

        dest = data.dest()
        imgs = sorted(get_img_filenames(os.path.join(dest, 'scale_1', 'img_src')))
        od = os.path.abspath(os.path.join(dest, 'img_src.zarr'))
        renew_directory(directory=od)
        for scale in data.scales():
            x, y = data.image_size(s=scale)
            group = 's%d' % get_scale_val(scale)
            preallocate_zarr(name='img_src.zarr',
                             group=group,
                             dimx=x,
                             dimy=y,
                             dimz=len(cfg.data),
                             dtype='uint8',
                             overwrite=True)
        n_tasks = len(data) * data.n_scales()

        task_queue = TaskQueue(n_tasks=n_tasks, parent=cfg.main_window, pbar_text=pbar_text)
        task_queue.start(cpus)
        script = 'src/job_convert_zarr.py'

        # store = zarr.open(out, synchronizer=synchronizer)
        # task_list = []
        for scale in data.scales():
            for ID, img in enumerate(imgs):
                out = os.path.join(od, 's%d' % get_scale_val(scale))
                fn = os.path.join(dest, scale, 'img_src', img)
                # task_list.append([sys.executable, script, str(ID), fn, out ])
                task = [sys.executable, script, str(ID), fn, out ]
                if cfg.PRINT_EXAMPLE_ARGS:
                    if ID in [0, 1, 2]:
                        print('Example Arguments (ID %d):' % (ID))
                        print(task, sep='\n')

                # print('\n'.join(task))
                task_queue.add_task(task)
                # task_queue.add_task([sys.executable, script, str(ID), fn, out ])
                # task_queue.add_task([sys.executable, script, str(ID), fn, store ])
        # n_scales = len(datamodel.scales())
        # chunkshape = datamodel.chunkshape()
        # z_stride = n_scales * chunkshape[0]
        # task_list = reorder_tasks(task_list, z_stride=z_stride)
        # for task in task_list:
        #     logger.info('Adding Layer %s Task' % task[2])
        #     task_queue.add_task(task)


        dt = task_queue.collect_results()
        cfg.data.set_t_scaling_convert_zarr(dt)
        logger.info('<<<< Generate Zarr Scales End <<<<')
logger = logging.getLogger(__name__)

snapshot = None

def getOpt(lookup):
    if isinstance(lookup, str):
        lookup = lookup.split(',')
    return reduce(operator.getitem, lookup, cfg.settings)


def setOpt(lookup, val):
    if isinstance(lookup, str):
        lookup = lookup.split(',')
    getOpt(lookup[:-1])[lookup[-1]] = val

def getData(lookup):
    if isinstance(lookup, str):
        lookup = lookup.split(',')
    return reduce(operator.getitem, lookup, cfg.data)

def setpOpt(lookup, val):
    if isinstance(lookup, str):
        lookup = lookup.split(',')
    getData(lookup[:-1])[lookup[-1]] = val


def natural_sort(l):
    '''Natural sort a list of strings regardless of zero padding'''
    convert = lambda text: int(text) if text.isdigit() else text.lower()
    alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
    return sorted(l, key=alphanum_key)


def find_allocated_widgets(filter) -> list:
    return [k for k in map(str,QApplication.allWidgets()) if str(filter) in k]


def count_widgets(name_or_type) -> int:
    return sum(name_or_type in s for s in map(str, QApplication.allWidgets()))


def delete_recursive(dir):
    # chunks = glob(dir + '/img_aligned.zarr/**/*', recursive=True) + glob(dir + '/img_src.zarr/**/*', recursive=True)
    cfg.main_window.showZeroedPbar()

    to_delete = []
    to_delete.extend(glob(dir +'/img_aligned.zarr/s*'))
    to_delete.extend(glob(dir +'/img_src.zarr/s*'))
    to_delete.append(dir +'/thumbnails')
    scales = glob(dir + '/scale_*')
    for s in scales:
        if os.path.exists(os.path.join(dir, s, 'thumbnails_corr_spots')):
            to_delete.append(os.path.join(dir, s, 'thumbnails_corr_spots'))
        if os.path.exists(os.path.join(dir, s, 'bias_data')):
            to_delete.append(os.path.join(dir, s, 'bias_data'))
        if os.path.exists(os.path.join(dir, s, 'img_aligned')):
            to_delete.append(os.path.join(dir, s, 'img_aligned'))
        if os.path.exists(os.path.join(dir, s, 'thumbnails_aligned')):
            to_delete.append(os.path.join(dir, s, 'thumbnails_aligned'))
        if os.path.exists(os.path.join(dir, s, 'img_src')):
            to_delete.append(os.path.join(dir, s, 'img_src'))
        if os.path.exists(os.path.join(dir, s, 'history')):
            to_delete.append(os.path.join(dir, s, 'history'))
    to_delete.append(dir)
    to_delete.append(dir) #delete twice
    cfg.nCompleted = 0
    cfg.nTasks = len(to_delete)
    logger.critical('# directories to delete: %d' % len(to_delete))

    cfg.main_window.showZeroedPbar()
    cfg.main_window.setPbarText('Deleting Files...')
    cfg.main_window.setPbarMax(cfg.nTasks)
    # logger.critical(f'To Delete: {to_delete}')
    for d in to_delete:
        cfg.nCompleted += 1
        shutil.rmtree(d, ignore_errors=True, onerror=handleError)
        cfg.main_window.setPbarText('Deleting %s...' % os.path.basename(d))
        cfg.main_window.updatePbar(cfg.nCompleted)
        cfg.main_window.update()
        QApplication.processEvents()

    cfg.main_window.pbar_widget.hide()




def update_preferences_model():
    logger.info('Updating user preferences model...')
    cfg.settings.setdefault('neuroglancer', {})
    cfg.settings['neuroglancer'].setdefault('SHOW_UI_CONTROLS', False)
    cfg.settings['neuroglancer'].setdefault('SHOW_PANEL_BORDERS', False)
    cfg.settings['neuroglancer'].setdefault('SHOW_YELLOW_FRAME', True)
    cfg.settings['neuroglancer'].setdefault('SHOW_SCALE_BAR', True)
    cfg.settings['neuroglancer'].setdefault('SHOW_AXIS_LINES', True)
    cfg.settings['neuroglancer'].setdefault('SHOW_ALIGNMENT_DETAILS', True)
    cfg.settings['neuroglancer'].setdefault('MATCHPOINT_MARKER_SIZE', 8)
    cfg.settings['neuroglancer'].setdefault('MATCHPOINT_MARKER_LINEWEIGHT', 3)
    cfg.settings.setdefault('state', {})
    cfg.settings['state'].setdefault('MANUAL_MODE', False)
    cfg.settings.setdefault('ui', {})
    cfg.settings['ui'].setdefault('SHOW_CORR_SPOTS', False)
    cfg.settings['ui'].setdefault('FETCH_PROJECT_SIZES', False)
    cfg.settings.setdefault('notes', {})
    cfg.settings['notes'].setdefault('global_notes', '')


def initialize_user_preferences():
    logger.info('Initializing user preferences model...')
    userpreferencespath = os.path.join(os.path.expanduser('~'), '.swiftrc')
    if os.path.exists(userpreferencespath):
        logger.info(f'Loading user settings "{userpreferencespath}"...')
        with open(userpreferencespath, 'r') as f:
            cfg.settings = json.load(f)
    else:
        logger.info(f'Loading user settings from defaults...')
        cfg.settings = {}
    update_preferences_model()
    '''save user preferences to file'''
    try:
        f = open(userpreferencespath, 'w')
        json.dump(cfg.settings, f, indent=2)
        f.close()
    except:
        logger.warning(f'Unable to save current user preferences')

def reset_user_preferences():
    userpreferencespath = os.path.join(os.path.expanduser('~'), '.swiftrc')
    if os.path.exists(userpreferencespath):
        os.remove(userpreferencespath)
    cfg.settings = {}
    update_preferences_model()


def isNeuroglancerRunning():
   return ng.server.is_server_running()


# def validate_project_selection() -> bool:
#     # logger.info('Validating selection %s...' % cfg.selected_file)
#     # called by setSelectionPathText
#     path, extension = os.path.splitext(cfg.selected_file)
#     if extension != '.swiftir':
#         return False
#     else:
#         return True
#
# def validate_zarr_selection() -> bool:
#     logger.info('Validating selection %s...' % cfg.selected_file)
#     # called by setSelectionPathText
#     if os.path.isdir(cfg.selected_file):
#         logger.info('Path IS a directory')
#         if '.zarray' in os.listdir(cfg.selected_file):
#             logger.info('Directory DOES contain .zarray -> Returning True...')
#             return True
#     logger.info('Returning False...')
#     return False


def validate_file(file) -> bool:
    # logger.info('Validating file...\n%s' % file)
    # logger.info('called by %s' % inspect.stack()[1].function)
    is_valid = False
    path, extension = os.path.splitext(file)
    if extension != '.swiftir':
        return False
    else:
        return True


def cleanup_project_list(paths: list) -> list:
    logger.info('')
    # logger.info(f'paths: {paths}')
    paths = list( dict.fromkeys(paths) ) # remove duplicates
    paths = [x for x in paths if x != '']
    clean_paths = []
    for path in paths:
        project_dir = os.path.splitext(path)[0]
        if os.path.exists(path):
            if os.path.isdir(project_dir):
                if validate_file(path):
                    clean_paths.append(path)
    diff = list(set(paths) - set(clean_paths))
    if diff:
        txt = f'Some projects were not found and will be removed from the project cache:\n{diff}'
        logger.warning(txt)
    # logger.info(f'clean_paths: {clean_paths}')
    return clean_paths


def get_project_list():
    logger.info('')
    try:
        userprojectspath = os.path.join(os.path.expanduser('~'), '.swift_cache')
        with open(userprojectspath, 'r') as f:
            projectpaths = [line.rstrip() for line in f]
        return projectpaths
    except:
        print_exception()


# file = os.path.join(os.path.expanduser('~'), '.swift_cache')
def append_project_path(path):
    logger.info('')
    userprojectspath = os.path.join(os.path.expanduser('~'), '.swift_cache')
    with open(userprojectspath, 'r') as f:
        lines = f.readlines()
    paths = [line.rstrip() for line in lines]
    paths.append(path)
    new_paths = cleanup_project_list(paths)
    with open(userprojectspath, 'a') as f:
        for p in new_paths:
            f.write(f"{p}\n")


def configure_project_paths():
    logger.info('')
    userprojectspath = os.path.join(os.path.expanduser('~'), '.swift_cache')
    if not os.path.exists(userprojectspath):
        open(userprojectspath, 'a').close()
    try:
        with open(userprojectspath, 'r') as f:
            lines = f.readlines()
        paths = [line.rstrip() for line in lines]
        # logger.info(f'paths: {paths}')
        projectpaths = cleanup_project_list(paths)
        # logger.info(f'projectpaths: {projectpaths}')
        with open(userprojectspath, 'w') as f:
            for p in projectpaths:
                f.write(f"{p}\n")
        if projectpaths:
            logger.info('AlignEM-SWiFT Knows About The Following Projects:\n'
                        '%s' % '  \n'.join(projectpaths))
    except:
        print_exception()


def check_for_binaries():
    # print("Checking platform-specific path to SWiFT-IR executables...")
    path = os.path.split(os.path.realpath(__file__))[0]
    if platform.system() == 'Darwin':
        bindir = os.path.join(path, 'lib', 'bin_darwin')
    elif platform.system() == 'Linux':
        bindir = os.path.join(path, 'lib', 'bin_tacc') if '.tacc.utexas.edu' in platform.node() else 'bin_linux'
    else:
        logger.warning("System Could Not Be Resolved. C Binaries Not Found.")
        return
    bin_lst = [os.path.join(bindir, 'iavg'),
               os.path.join(bindir, 'iscale2'),
               os.path.join(bindir, 'mir'),
               os.path.join(bindir, 'remod'),
               os.path.join(bindir, 'swim')
               ]
    for f in bin_lst:
        if os.path.isfile(f):  print(u'\u2713 FOUND: ' + f)
        else:  logger.warning('BINARY FILE NOT FOUND, PLEASE COMPILE: ' + f)


def obj_to_string(obj, extra='    '):
    return str(obj.__class__) + '\n' + '\n'.join(
        (extra + (str(item) + ' = ' +
                  (obj_to_string(obj.__dict__[item], extra + '    ') if hasattr(obj.__dict__[item], '__dict__') else str(
                      obj.__dict__[item])))
         for item in sorted(obj.__dict__)))


def is_tacc() -> bool:
    '''Checks if the program is running on a computer at TACC. Returns a boolean.'''
    node = platform.node()
    if '.tacc.utexas.edu' in node:  return True
    else:                           return False


def is_linux() -> bool:
    '''Checks if the program is running on a Linux OS. Returns a boolean.'''
    system = platform.system()
    if system == 'Linux':  return True
    else:                  return False


def is_mac() -> bool:
    '''Checks if the program is running on macOS. Returns a boolean.'''
    system = platform.system()
    if system == 'Darwin':  return True
    else:                   return False


def is_joel() -> bool:
    '''Checks if the program is running on macOS. Returns a boolean.'''
    system = platform.system()
    if 'Joels-' in platform.node():
        return True
    else:
        return False


def get_bindir() -> str:
    '''Checks operating system. Returns the operating system-dependent
    path to where SWiFT-IR binaries should exist'''
    bindir = ''
    error = 'Operating System Could Not Be Resolved'
    if is_tacc():     bindir = 'bin_tacc'
    elif is_mac():    bindir = 'bin_darwin'
    elif is_linux():  bindir = 'bin_linux'
    else:
        logger.warning(error)
        cfg.main_window.hud.post(error, logging.ERROR)
    assert len(bindir) > 0
    return bindir


def get_appdir() -> str:
    return os.path.split(os.path.realpath(__file__))[0]


def absFilePaths(d):
    for dirpath,_,filenames in os.walk(d):
        for f in filenames:
            yield os.path.abspath(os.path.join(dirpath, f))


def absFilePathsList(d):
    return list(absFilePaths(d))


def handleError(func, path, exc_info):
    logger.warning('Handling Error for file %s' % path)
    logger.warning(exc_info)
    if not os.access(path, os.W_OK):
        os.chmod(path, stat.S_IWUSR)
        func(path)


def get_paths_absolute(directory):
    for dirpath,_,filenames in os.walk(directory):
        for f in filenames:
            yield os.path.abspath(os.path.join(dirpath, f))


def list_paths_absolute(directory):
    return natural_sort(list(get_paths_absolute(directory)))


def tracemalloc_start():
    logger.info('Starting tracemalloc memory allocation analysis...')
    tracemalloc.start()


def tracemalloc_compare():
    if tracemalloc.is_tracing():
        global snapshot
        snapshot2 = tracemalloc.take_snapshot()
        snapshot2 = snapshot2.filter_traces((
            tracemalloc.Filter(False, "<frozen importlib._bootstrap>"),
            tracemalloc.Filter(False, "<unknown>"),
            tracemalloc.Filter(False, tracemalloc.__file__)
        ))

        if snapshot is not None:
            print("================================== Begin Trace:")
            top_stats = snapshot2.compare_to(snapshot, 'lineno', cumulative=True)
            for stat in top_stats[:10]:
                print(stat)
        snapshot = snapshot2
    else:
        logger.warning('tracemalloc is not currently tracing')


def tracemalloc_stop():
    if tracemalloc.is_tracing():
        logger.info('Stopping tracemalloc memory allocation analysis...')
        tracemalloc.stop()
    else:
        logger.warning('tracemalloc is not currently tracing')


def tracemalloc_clear():
    if tracemalloc.is_tracing():
        logger.info('Clearing tracemalloc traces...')
        tracemalloc.clear_traces()
    else:
        logger.warning('tracemalloc is not currently tracing')


def timer(func):
    def wrap_func(*args, **kwargs):
        t1 = time()
        result = func(*args, **kwargs)
        t2 = time()
        # print(f'Function {func.__name__!r} executed in {(t2-t1):.4f}s')
        function = f'Function {func.__name__!r}'.ljust(35, ' ')
        result = f'executed in {(t2-t1):.4f}s'
        print(function + result)
        return result

    return wrap_func


def get_bytes(start_path = '.'):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            if not os.path.islink(fp):
                # skip symbolic links
                total_size += os.path.getsize(fp)

    return total_size


def make_affine_widget_HTML(afm, cafm, fs1=7, fs2=8):
    # 'cellspacing' affects project_table width and 'cellpadding' affects project_table height
    # text = f"<project_table project_table-layout='fixed' style='border-collapse: collapse;' cellspacing='3' cellpadding='2' border='0'>"\
    # text = f"<project_table project_table-layout='fixed' style='border-collapse: collapse;' cellspacing='10' cellpadding='4' border='0'>"\
    text = f"<table table-layout='fixed' style='border-bottom: 1pt solid black;' cellspacing='2' cellpadding='2'>"\
           f"  <tr>"\
           f"    <td rowspan=2 style='font-size: {fs1}px;'>AFM</td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(afm[0][0], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(afm[0][1], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(afm[0][2], 3)).center(8)}</pre></center></td>"\
           f"  </tr>"\
           f"  <tr>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(afm[1][0], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(afm[1][1], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(afm[1][2], 3)).center(8)}</pre></center></td>"\
           f"  </tr>"\
           f"  <tr>"\
           f"    <td rowspan=2 style='font-size: {fs1}px;'>CAFM</td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(cafm[0][0], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(cafm[0][1], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(cafm[0][2], 3)).center(8)}</pre></center></td>"\
           f"  </tr>"\
           f"  <tr>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(cafm[1][0], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(cafm[1][1], 3)).center(8)}</pre></center></td>"\
           f"    <td style='width:30px; font-size: {fs2}px;'><center><pre>{str(round(cafm[1][2], 3)).center(8)}</pre></center></td>"\
           f"  </tr>"\
           f"</table>"
    return text


def elapsed_since(start):
    return time.strftime("%H:%M:%S", time.gmtime(time.time() - start))


def get_process_memory():
    process = psutil.Process(os.getpid())
    return process.memory_info().rss


def track(func):
    def wrapper(*args, **kwargs):
        mem_before = get_process_memory()
        start = time.time()
        result = func(*args, **kwargs)
        elapsed_time = elapsed_since(start)
        mem_after = get_process_memory()
        logger.critical("{}: memory before: {:,}, after: {:,}, consumed: {:,}; exec time: {}".format(
            func.__name__,
            mem_before, mem_after, mem_after - mem_before,
            elapsed_time))
        return result
    return wrapper


def renew_directory(directory:str) -> None:
    '''Remove and re-create a directory, if it exists.'''
    if os.path.exists(directory):
        d = os.path.basename(directory)
        cfg.main_window.hud.post("Overwriting Directory '%s'..." % directory)
        try:     shutil.rmtree(directory, ignore_errors=True)
        except:  print_exception()
        try:     os.makedirs(directory, exist_ok=True)
        except:  print_exception()
        cfg.main_window.hud.done()

# def kill_task_queue(task_queue):
#     '''End task queue multiprocessing tasks and delete a task queue object'''
#     try: task_queue.end_tasks()
#     except: print_exception()
#     task_queue.stop()
#     del task_queue

def show_status_report(results, dt):
    if results[2] > 0:
        cfg.main_window.hud(f'  Succeeded    = {results[0]}')
        if results[1] > 0:
            cfg.main_window.warning(f'  Queued       = {results[1]}')
        else:
            cfg.main_window.hud(f'  Queued       = {results[1]}')
        cfg.main_window.err(f'  Failed       = {results[2]}')
        cfg.main_window.hud(f'  Time Elapsed = {dt:.2f}s')
    else:
        cfg.main_window.hud(f'  Succeeded    = {results[0]}')
        cfg.main_window.hud(f'  Queued       = {results[1]}')
        cfg.main_window.hud(f'  Failed       = {results[2]}')
        cfg.main_window.hud(f'  Time Elapsed = {dt:.2f}s')


def get_scale_key(scale_val) -> str:
    '''Create a key like "scale_#" from either an integer or a string'''
    s = str(scale_val)
    while s.startswith('scale_'):
        s = s[len('scale_'):]
    return 'scale_' + s


def get_scale_val(scale_of_any_type) -> int:
    '''Converts s key to integer (i.e. 'scale_1' as string -> 1 as int)
    TODO: move this to glanceem_utils'''
    scale = scale_of_any_type
    try:
        if type(scale) == type(1):
            return scale
        else:
            while scale.startswith('scale_'):
                scale = scale[len('scale_'):]
            return int(scale)
    except:
        logger.warning('Unable to return s value')


def do_scales_exist() -> bool:
    '''Checks whether any stacks of scaled images exist'''
    try:
        if any(d.startswith('scale_') for d in os.listdir(cfg.data['data']['destination_path'])):
            return True
        else:
            return False
    except:
        pass


def get_scales_with_generated_alignments(scales) -> list:
    # logger.info('called by %s' % inspect.stack()[1].function)
    l = []
    for s in scales:
        if exist_aligned_zarr(s):
            l.append(s)
    return l


def exist_aligned_zarr(scale: str) -> bool:
    '''Returns boolean based on whether arg s is aligned '''
    caller = inspect.stack()[1].function
    # logger.info('called by %s' % inspect.stack()[1].function)
    if cfg.data:
        zarr_path = os.path.join(cfg.data.dest(), 'img_aligned.zarr', 's' + str(get_scale_val(scale)))
        if not os.path.isdir(zarr_path):
            logger.debug(f"Path Not Found: {zarr_path}")
            result = False
        elif not os.path.exists(os.path.join(zarr_path, '.zattrs')):
            logger.debug(f"Path Not Found: {os.path.join(zarr_path, '.zattrs')}")
            result = False
        elif not os.path.exists(os.path.join(zarr_path, '.zarray')):
            logger.debug(f"Path Not Found: {os.path.join(zarr_path, '.zarray')}")
            result = False
        elif not os.path.exists(os.path.join(zarr_path, '0.0.0')):
            logger.debug(f"Path Not Found: {os.path.join(zarr_path, '0.0.0')}")
            result = False
        else:
            result = True
        logger.debug('Returning Result: %r' % result)
        return result
    else:
        logger.warning(f'called by {caller} but there is no cfg.data!')


def exist_aligned_zarr_cur_scale(dest=None) -> bool:
    '''Checks if there exists an alignment stack for the current s

    #0615 Bug fixed - look for populated bias_data folder, not presence of aligned images

    #fix Note: This will return False if no scales have been generated, but code should be dynamic enough to run alignment
    functions even for a datamodel that does not need scales.'''
    # logger.info('Called by %s' % inspect.stack()[1].function)

    if dest == None: dest = cfg.data.dest()
    zarr_path = os.path.join(dest, 'img_aligned.zarr', 's' + str(cfg.data.scale_val()))
    # logger.info('zarr_path = %s' % zarr_path)
    if not os.path.isdir(zarr_path):
        logger.debug('Returning False due to os.path.isdir(zarr_path)')
        return False
    if not os.path.exists(os.path.join(zarr_path, '.zattrs')):
        logger.debug("Returning False due to os.path.exists(os.path.join(zarr_path, '.zattrs')")
        return False
    if not os.path.exists(os.path.join(zarr_path, '.zarray')):
        logger.debug("Returning False due to os.path.exists(os.path.join(zarr_path, '.zarray')")
        return False
    if not os.path.exists(os.path.join(zarr_path, '0.0.0')):
        logger.debug("Returning False due to os.path.exists(os.path.join(zarr_path, '0.0.0')")
        return False
    return True


def are_aligned_images_generated(dir, scale) -> bool:
    '''Returns True or False dependent on whether aligned images have been generated for the current s.'''
    path = os.path.join(dir, scale, 'img_aligned')
    files = glob(path + '/*.tif')
    if len(files) < 1:
        logger.debug('Zero aligned TIFs were found at this s - Returning False')
        return False
    else:
        logger.debug('One or more aligned TIFs were found at this s - Returning True')
        return True



def reorder_tasks(task_list, z_stride) -> list:
    tasks=[]
    for x in range(0, z_stride): #chunk z_dim
        tasks.extend(task_list[x::z_stride])
        # append_list = task_list[x::z_stride]
        # for t in append_list:
        #     tasks.append(t)
    return tasks


def imgToNumpy(img):
    '''Proper way to convert between images and numpy arrays as of PIL 1.1.6'''
    return np.array(img)


@contextmanager
def time_limit(seconds):
    def signal_handler(signum, frame):
        raise TimeoutException("Timed out!")
    signal.signal(signal.SIGALRM, signal_handler)
    signal.alarm(seconds)
    try:
        yield
    finally:
        signal.alarm(0)

class TimeoutException(Exception): pass


def print_exception():
    tstamp = datetime.now().strftime("%Y%m%d_%H:%M:%S")
    exi = sys.exc_info()
    txt = f"  [{tstamp}]\nError Type : {exi[0]}\nError Value : {exi[1]}\n{traceback.format_exc()}"
    logger.warning(txt)

    if cfg.data:
        lf = os.path.join(cfg.data.dest(), 'logs', 'exceptions.log')
        with open(lf, 'a+') as f:
            f.write('\n' + txt)




def get_img_filenames(path) -> list[str]:
    logger.debug('get_img_filenames:')
    logger.debug('Searching in Path: %s ' % path)
    imgs = [x for x in os.listdir(path) if os.path.splitext(x)[1] in (
        '.tif',
        '.tiff',
        '.bmp',
        '.jpg',
        '.jpeg',
        '.png',
        '.eps'
    )]
    logger.debug('Returning: %s' % str(imgs))
    return natural_sort(imgs)


def rename_layers(use_scale, al_dict):
    logger.info('rename_layers:')
    source_dir = os.path.join(cfg.data.dest(), use_scale, "img_src")
    for layer in al_dict:
        image_name = None
        if 'base' in layer['images'].keys():
            image = layer['images']['base']
            try:
                image_name = os.path.basename(image['filename'])
                destination_image_name = os.path.join(source_dir, image_name)
                shutil.copyfile(image.image_file_name, destination_image_name)
            except:
                logger.warning('Something went wrong with renaming the alignment layers')
                pass


def verify_image_file(path: str) -> str:
    '''Tries to determine the filetype of an image using the Python standard library.
    Returns a string.'''''
    imhgr_type = imghdr.what(path)
    logger.info('verify_image_file | imhgr_type = ' % imhgr_type)
    return imhgr_type


def percentage(part, whole) -> str:
    percentage = 100 * float(part) / float(whole)
    return str(round(percentage, 2)) + "%"


def make_relative(file_path, proj_path):
    rel_path = os.path.relpath(file_path, start=os.path.split(proj_path)[0])
    return rel_path


def make_absolute(file_path, proj_path):
    abs_path = os.path.join(os.path.split(proj_path)[0], file_path)
    return abs_path


def create_project_structure_directories(destination, scales) -> None:
    for scale in scales:
        subdir_path = os.path.join(destination, scale)
        cfg.main_window.hud('Creating directories for %s...' % scale)
        src_path = os.path.join(subdir_path, 'img_src')
        aligned_path = os.path.join(subdir_path, 'img_aligned')
        staged_path = os.path.join(subdir_path, 'img_staged')
        bias_data_path = os.path.join(subdir_path, 'bias_data')
        history_path = os.path.join(subdir_path, 'history')
        try:
            os.makedirs(subdir_path)
            os.makedirs(src_path)
            os.makedirs(aligned_path)
            os.makedirs(staged_path)
            os.makedirs(bias_data_path)
            os.makedirs(history_path)
        except:
            print_exception()
            logger.warning('There Was A Problem Creating Directory Structure')
        cfg.main_window.hud.done()



def is_not_hidden(path):
    return not path.name.startswith(".")


def print_project_tree() -> None:
    '''Recursive function that lists datamodel directory contents as a tree.'''
    paths = Treeview.make_tree(Path(cfg.data['data']['destination_path']))
    for path in paths:
        print(path.displayable())


def module_debug() -> None:
    '''Simple helper function to debug available modules.'''
    import sys, os
    modulenames = set(sys.modules) & set(globals())
    allmodules = [sys.modules[name] for name in modulenames]
    logger.info('========================================================' +
          '_____________________MODULE DEBUG_______________________' +
          'script       : ' + str(logger.info(sys.argv[0])) + 'running in   :' +
          str(os.path.dirname(os.path.realpath(__file__))) + 'sys.pathc    : ' + str(sys.path) +
          'module names : ' + str(modulenames) + 'allmodules   : ' + str(allmodules) +
          'In module products sys.path[0] = ' + str(sys.path[0]) + '__package__ = ' +
          str(__package__) + '========================================================')

    # Courtesy of https://github.com/wimglenn
    import sys
    try:
        old_import = builtins.__import__

        def my_import(name, *args, **kwargs):
            if name not in sys.modules:  logger.info('importing --> {}'.format(name))
            return old_import(name, *args, **kwargs)

        builtins.__import__ = my_import
    except:
        pass


def print_scratch(msg):
    with open('~/Logs/scratchlog', "w") as f:
        f.write(str(msg))


def makedirs_exist_ok(path_to_build, exist_ok=False):
    # Needed for old python which doesn't have the exist_ok option!!!
    logger.info("Making directories for path %s" % path_to_build)
    parts = path_to_build.split(os.sep)  # Variable "parts" should be a list of subpath sections. The first will be empty ('') if it was absolute.
    full = ""
    if len(parts[0]) == 0:
        # This happens with an absolute PosixPath
        full = os.sep
    else:
        # This may be a Windows drive or the start of a non-absolute path
        if ":" in parts[0]:
            # Assume a Windows drive
            full = parts[0] + os.sep
        else:
            # This is a non-absolute path which will be handled naturally with full=""
            pass
    for p in parts:
        full = os.path.join(full, p)
        if not os.path.exists(full):
            os.makedirs(full)
        elif not exist_ok:
            pass
            # logger.info("Warning: Attempt to create existing directory: " + full)


def update_skip_annotations():
    logger.info('update_skip_annotations:')
    # __import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
    remove_list = []
    add_list = []
    for sk, scale in cfg.data['data']['scales'].items():
        for layer in scale['alignment_stack']:
            layer_num = scale['alignment_stack'].index(layer)
            for ik, im in layer['images'].items():
                if not 'metadata' in im:
                    im['metadata'] = {}
                if not 'annotations' in im['metadata']:
                    im['metadata']['annotations'] = []
                ann = im['metadata']['annotations']
                if layer['skipped']:
                    # Check and set as needed
                    already_skipped = False
                    for a in ann:
                        if a.startswith('skipped'):
                            already_skipped = True
                            break
                    if not already_skipped:
                        add_list.append((sk, layer_num, ik))
                        ann.append('skipped(1)')
                else:
                    # Remove all "skipped"
                    for a in ann:
                        if a.startswith('skipped'):
                            remove_list.append((sk, layer_num, ik))
                            ann.remove(a)
    # for item in remove_list:
    #     interface.print_debug(80, "Removed skipped from " + str(item))
    # for item in add_list:
    #     interface.print_debug(80, "Added skipped to " + str(item))

class SwiftirException:
    def __init__(self, project_file, message):
        self.project_file = project_file
        self.message = message

    def __str__(self):
        return self.message



ZARR_AXES_3D = ["z", "y", "x"]
DEFAULT_ZARR_STORE = zarr.NestedDirectoryStore



def create_paged_tiff():
    dest = cfg.data.dest()
    for scale in cfg.data.scales():
        path = os.path.join(dest, scale, 'img_src')
        of = os.path.join(dest, scale + '_img_src.tif')
        files = glob(path + '/*.tif')
        image_sequence = tifffile.imread(files)
    '''
    image_sequence.shape
    Out[29]: (34, 4096, 4096)
    '''
    bb_x, bb_y = rect[2], rect[3]
    p1 = applyAffine(afm, (0,0))  # Transform Origin To Output Space
    p2 = applyAffine(afm, (rect[0], rect[1]))  # Transform BB Lower Left To Output Space
    offset_x, offset_y = p2 - p1  # Offset Is Difference of 'p2' and 'p1'
    a = afm_list[0];  c = afm_list[1];  e = afm_list[2] + offset_x
    b = afm_list[3];  d = afm_list[4];  f = afm_list[5] + offset_y
    mir_c = os.path.join(os.path.split(os.path.realpath(__file__))[0], 'lib', get_bindir(), 'mir')
    # Todo get exact median greyscale value for each image in list, for now just use 128
    mir_script = \
        'B %d %d 1\n' \
        'Z %g\n' \
        'F %s\n' \
        'A %g %g %g %g %g %g\n' \
        'RW %s\n' \
        'E' % (bb_x, bb_y, 128, in_fn, a, c, e, b, d, f, out_fn)
    o = run_command(mir_c, arg_list=[], cmd_input=mir_script)
    # path = os.path.join(os.path.dirname(os.path.dirname(out_fn)), 'mir_commands.dat')
    # with open(path, 'a+') as f:
    #     f.write('\n---------------------------\n' + mir_script + '\n')

    # Python Implementation
    # image_apply_affine(in_fn=in_fn, out_fn=out_fn, afm=afm, rect=rect, grayBorder=grayBorder)
    sys.stdout.write(o['out'])
    sys.stderr.write(o['err'])
    sys.stdout.close()
    sys.stderr.close()
    if o['rc']:
        exit(1)
    job_script   = sys.argv[0] #*
    ID           = int(sys.argv[1]) #*
    fn           = sys.argv[2]
    out          = sys.argv[3] #*

    # synchronizer = zarr.ThreadSynchronizer()
    # store = zarr.open(out, synchronizer=synchronizer)\
    store = zarr.open(out, write_empty_chunks=False)

    tif = TIFF.open(fn)
    img = tif.read_image()[:,::-1] # numpy array

    # LIBTIFF (pure Python module)
    # img = TIFFfile(fn)  # pylibtiff
    # img = tifffile.imread(fn)

    store[ID,:,:] = img # store: <zarr.core.Array (19, 1244, 1130) uint8>
    store.attrs['_ARRAY_DIMENSIONS'] = ["z", "y", "x"]

    del img #flush datamodel in memory

    sys.stdout.close()
    sys.stderr.close()
logger = logging.getLogger(__name__)

class Mendenhall(QObject):
    """ Mendenhall Protocol For Aligning Images Before Breakfast"""

    def __init__(self, parent=None, data=None, reopen=False):
        QObject.__init__(self)
        self.parent = parent
        self.data = data
        self._index = 0
        self.dest = cfg.data.dest()
        self.zarr_name = 'mendenhall.zarr'
        self.zarr_group = 'grp'
        self.zarr_path = os.path.join(self.dest, self.zarr_name, self.zarr_group)
        self.sink = None
        self.watchmen = None
        self._files = []
        self._empty = True
        self._first = None
        self.image_size = None
        if reopen:
            self._empty = False
            self.sink = cfg.data.set_source_path()
            self._files = os.listdir(self.sink)
            self._index = len(self._files)


    def set_directory(self):
        self.sink = mendenhall_dialog()
        cfg.data.set_source_path(self.sink)
        cfg.main_window._saveProjectToFile()

    def start_watching(self):
        self.watchmen = QFileSystemWatcher() # files(), directories()
        self.watchmen.addPath(self.sink)
        self.watchmen.directoryChanged.connect(self.watchmen_slot)
        logger.info(f'Watching: {self.sink}')

    def stop_watching(self):
        self.watchmen = None

    def watchmen_slot(self):
        logger.info('watchmen_slot:')
        contents = os.listdir(self.sink)
        print('contents: ' + str(contents))
        print('contents[0]: ' + str(contents[0]))
        if self._empty == True:
            self.first_image(contents[0])
            self._empty = False
        diff = list(set(contents) - set(self._files))
        if len(diff) != 1:
            logger.warning('Watchmen: The difference of set suggests that multiple files have '
                           'have been added or removed simultaneously - Returning')
            return
        img = diff[0]
        logger.info(f'New Image (or possibly removed): {img}')
        self.add_image(os.path.join(self.sink, img))
        cfg.data.nSections = len(cfg.data)
        self._files = contents

    def n_files(self):
        return len(self._files)

    def first_image(self, img):
        logger.critical('first_image:')
        cfg.main_window.hud.post('The First Microscope Image Has Arrived!')
        self._first = os.path.join(self.sink, img)
        self.image_size = ImageSize(self._first)
        cfg.data.set_image_size_directly(size=self.image_size)
        cfg.main_window.hud.post(f'Expecting Images Of Size: {self.image_size}')
        self.preallocate()
        cfg.project_tab.openViewZarr()

    def add_image(self, img):
        # cfg.main_window.hud.post(f"Adding Image\n'{os.path.basename(img)}'...")
        cfg.data.append_image(img)
        cfg.data.link_reference_sections()
        self.img_to_zarr(ID=self._index, fn=img)
        self._index += 1
        # cfg.main_window.initNgServer()
        # cfg.main_window.ng_workers['scale_1'].invalidateAllLayers()
        cfg.project_tab.openViewZarr()

    def img_to_zarr(self, ID, fn):
        cfg.main_window.hud.post(f"Converting Image ID ({ID}) '{os.path.basename(fn)}' To Zarr...")
        tif = TIFF.open(fn)
        img = tif.read_image()[:, ::-1]  # numpy array
        store = zarr.open(self.zarr_path)
        store[ID, :, :] = img
        store.attrs['_ARRAY_DIMENSIONS'] = ["z", "y", "x"]

    def preallocate(self):
        if self.image_size:
            preallocation_size = 10
            cfg.main_window.hud.post(f'Preallocating Zarr, Preallocation Size: {preallocation_size}')
            preallocate_zarr(name=self.zarr_name,
                             group=self.zarr_group,
                             dimx=self.image_size[0],
                             dimy=self.image_size[1],
                             dimz=10,                # arbitrary z-dim for now
                             dtype='uint8',
                             overwrite=False
                             )
            pass
        else:
            logger.warning('Cannot Preallocate Yet, Image Size Is Still Unknown')
ann_shader = '''void main() { setPointMarkerBorderColor(prop_ptColor());
setPointMarkerBorderWidth(prop_ptWidth());
setPointMarkerSize(prop_size());}
'''

shader_default = '''#uicontrol invlerp normalized
void main() {
  emitGrayscale(normalized());
}
'''

shader_default_ = '''#uicontrol vec3 color color(default="white")
#uicontrol float brightness slider(min=-1, max=1, step=0.01)
#uicontrol float contrast slider(min=-1, max=1, step=0.01)
void main() {
  emitRGB(color *
          (toNormalized(getDataValue()) + brightness) *
          exp(contrast));
}
'''

shader_test1 = '''#uicontrol vec3 color color(default="red")
#uicontrol float brightness slider(min=-1, max=1)
#uicontrol float contrast slider(min=-3, max=3, step=0.01)
void main() {
  emitRGB(color *
          (toNormalized(getDataValue()) + brightness) *
          exp(contrast));
}
'''

shader_test2 = '''#uicontrol vec3 color color(default="white")
#uicontrol float min slider(default=0, min=0, max=1, step=0.01)
#uicontrol float max slider(default=1, min=0, max=1, step=0.01)
#uicontrol float brightness slider(default=0, min=-1, max=1, step=0.1)
#uicontrol float contrast slider(default=0, min=-3, max=3, step=0.1)

float s(float x, float min, float max) {
  return (x - min) / (max - min);
}

void main() {
  emitRGB(
    color * vec3(
      s(toNormalized(getDataValue()), min, max) + brightness,
      s(toNormalized(getDataValue()), min, max) + brightness,
      s(toNormalized(getDataValue()), min, max) + brightness
    ) * exp(contrast)
  );

}
'''


colormapJet = '''void main() {
  float v = toNormalized(getDataValue(0));
  vec4 rgba = vec4(0,0,0,0);
  if (v != 0.0) {
    rgba = vec4(colormapJet(v), 1.0);
  }
  emitRGBA(rgba);
}
'''

__all__ = ['Thumbnailer']

logger = logging.getLogger(__name__)

class Thumbnailer:
    def __init__(self):
        logger.info('')
        self.iscale2_c = os.path.join(get_appdir(), 'lib', get_bindir(), 'iscale2')


    def generate_main(self):
        cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
        pbar_text = 'Generating Source Image Thumbnails (%d Cores)...' % cpus
        if cfg.CancelProcesses:
            cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
        else:
            logger.info('Generating Source Thumbnails...')
            coarsest_scale = cfg.data.smallest_scale()
            src = os.path.join(cfg.data.dest(), coarsest_scale, 'img_src')
            od = os.path.join(cfg.data.dest(), 'thumbnails')
            dt = self.generate_thumbnails(
                src=src, od=od, rmdir=True, prefix='', start=0, end=None, pbar_text=pbar_text, cpus=cpus)
            cfg.data.set_t_thumbs(dt)


    def generate_aligned(self, start, end):
        cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
        pbar_text = 'Generating Aligned Image Thumbnails (%d Cores)...' % cpus
        if cfg.CancelProcesses:
            cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
        else:
            src = os.path.join(cfg.data.dest(), cfg.data.scale(), 'img_aligned')
            od = os.path.join(cfg.data.dest(), cfg.data.scale(), 'thumbnails_aligned')
            dt = self.generate_thumbnails(
                src=src, od=od, rmdir=False, prefix='', start=start, end=end, pbar_text=pbar_text, cpus=cpus)
            cfg.data.set_t_thumbs_aligned(dt)


    def generate_corr_spot(self, start, end):
        cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
        pbar_text = 'Generating Correlation Spot Thumbnails (%d Cores)...' % cpus
        if cfg.CancelProcesses:
            cfg.main_window.warn('Canceling Tasks: %s' % pbar_text)
        else:
            src = os.path.join(cfg.data.dest(), cfg.data.scale(), 'corr_spots')
            od = os.path.join(cfg.data.dest(), cfg.data.scale(), 'thumbnails_corr_spots')
            rmdir = True if (start == 0) and (end == None) else False

            baseFileNames = cfg.data.basefilenames()
            if not rmdir:
                #Special handling for corrspot files since they are variable in # and never 1:1 with project files
                for i in range(start,end):
                    old_thumbnails = glob(os.path.join(od, '*' + baseFileNames[i]))
                    for tn in old_thumbnails:
                        try:
                            os.remove(tn)
                        except:
                            logger.warning('Error removing expired thumbnail: %s' % tn)

            filenames = []
            for name in baseFileNames[start:end]:
                filenames.extend(glob(os.path.join(src, '*' + name)))

            dt = self.generate_thumbnails(src=src, od=od,
                                          rmdir=rmdir, prefix='',
                                          start=start, end=end,
                                          pbar_text=pbar_text, cpus=cpus,
                                          filenames=filenames
                                          )
            cfg.data.set_t_thumbs_spot(dt)
            cfg.main_window.tell('Discarding Full Size Correlation Spots...')
            try:
                shutil.rmtree(os.path.join(cfg.data.dest(), cfg.data.scale(), 'corr_spots'), ignore_errors=True)
                shutil.rmtree(os.path.join(cfg.data.dest(), cfg.data.scale(), 'corr_spots'), ignore_errors=True)
            except:
                print_exception()
            else:
                cfg.main_window.hud.done()



    def generate_thumbnails(self,
                            src,
                            od,
                            rmdir=False,
                            prefix='',
                            start=0,
                            end=None,
                            pbar_text='',
                            cpus=None,
                            filenames=None,
                            target_size=cfg.TARGET_THUMBNAIL_SIZE
                            ):
        if cpus == None:
            cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
        caller = inspect.stack()[1].function
        logger.info('Thumbnail Source Directory: %s' % src)

        try:
            siz_x, siz_y = ImageSize(next(absFilePaths(src)))
            scale_factor = int(max(siz_x, siz_y) / cfg.TARGET_THUMBNAIL_SIZE)
            if scale_factor == 0:
                scale_factor = 1
        except:
            print_exception()
            logger.warning('Are there any files in this directory? - Returning')
            cfg.main_window.err('Unable to generate thumbnail(s)')
            return 1

        if rmdir:
            if os.path.exists(od):
                try:    shutil.rmtree(od)
                except: print_exception()
        if not os.path.exists(od):
            os.mkdir(od)

        if filenames == None:
            filenames = natural_sort(glob(os.path.join(src, '*.tif')))[start:end]
        # logger.info(f'Generating thumbnails for:\n{str(filenames)}')
        cpus = min(psutil.cpu_count(logical=False), cfg.TACC_MAX_CPUS) - 2
        task_queue = TaskQueue(n_tasks=len(cfg.data), parent=cfg.main_window, pbar_text=pbar_text)
        task_queue.start(cpus)

        logger.info('Removing up to %d files...' %len(filenames))
        for i, fn in enumerate(filenames):
            ofn = os.path.join(od, os.path.basename(fn))
            if os.path.exists(ofn):
                os.remove(ofn)
            task = (self.iscale2_c, '+%d' % scale_factor, 'of=%s' % ofn, '%s' % fn)
            task_queue.add_task(task)
            if cfg.PRINT_EXAMPLE_ARGS and (i in (0, 1, 2)):
                logger.info('\nTQ Params:\n(1) %s\n(2) %s\n(3) %s\n(4) %s' % task)

        dt = task_queue.collect_results()

        logger.info('<<<< Thumbnail Generation Complete <<<<')
        return dt
__all__ = ['EMViewer']

logger = logging.getLogger(__name__)
# handler = logging.StreamHandler(stream=sys.stdout)
# logger.addHandler(handler)

class WorkerSignals(QObject):
    result = Signal(str)
    stateChanged = Signal(int)
    zoomChanged = Signal(float)
    mpUpdate = Signal()


class EMViewer(neuroglancer.Viewer):
    def __init__(self, name=None, force_xy=False, webengine=None):
        super().__init__()
        if name:
            self.name=name
        self.webengine = webengine
        self.force_xy = force_xy
        self.signals = WorkerSignals()
        self.created = datetime.datetime.now()
        self._layer = None
        self.cs_scale = None
        self._crossSectionScale = 1
        self.shared_state.add_changed_callback(self.on_state_changed)
        # self.shared_state.add_changed_callback(lambda: self.defer_callback(self.on_state_changed))
        logger.info('viewer constructed!')


    def __del__(self):
        try:
            caller = inspect.stack()[1].function
            logger.warning('__del__ called by [%s] on EMViewer (created: %s)'
                           % (caller, self.created))
        except Exception as e:
            logger.warning('Lost Track Of Caller')
            raise e
        pass

    # def __str__(self):
    #     return obj_to_string(self)

    def __repr__(self):
        return copy.deepcopy(self.state)

    def request_layer(self):
        return math.floor(self.state.position[0])

    def invalidateAlignedLayers(self):
        cfg.alLV.invalidate()

    # def set_zmag(self):
    #     if cfg.MP_MODE:
    #         with self.txn() as s:
    #             s.relativeDisplayScales = {"z": 10} # this should work, but does not work. ng bug.


    def set_layer(self, l:int):
        state = copy.deepcopy(self.state)
        state.position[0] = l
        self.set_state(state)

    def initViewerMendenhall(self):
        logger.critical('Initializing Neuroglancer - Mendenhall...')
        path = os.path.join(cfg.data.dest(), 'mendenhall.zarr', 'grp')
        scales = [50, 2, 2]
        coordinate_space = ng.CoordinateSpace(names=['z', 'y', 'x'], units=['nm','nm','nm'], scales=scales, )
        cfg.men_tensor = get_zarr_tensor(path).result()
        self.json_unal_dataset = cfg.men_tensor.spec().to_json()
        logger.debug(self.json_unal_dataset)
        cfg.menLV = ng.LocalVolume(
            data=cfg.men_tensor,
            dimensions=coordinate_space,
            voxel_offset=[0, 0, 0],
        )
        logger.info('Instantiating Viewer...')
        image_size = cfg.data.image_size()
        widget_size = cfg.main_window.globTabs.size()
        logger.critical(f'cfg.main_window.globTabs.size() = {cfg.main_window.globTabs.size()}')
        logger.critical(f'widget_size = {widget_size}')

        widget_height = widget_size[3]
        tissue_h = 2 * image_size[1]  # nm
        scale_h = (tissue_h / widget_height) * 1e-9  # nm/pixel
        tissue_w = 2 * image_size[0]  # nm
        scale_w = (tissue_w / image_size[0]) * 1e-9  # nm/pixel
        cross_section_scale = max(scale_h, scale_w)

        with self.txn() as s:
            s.layers['layer'] = ng.ImageLayer(source=cfg.menLV)
            s.crossSectionBackgroundColor = '#808080'
            s.gpu_memory_limit = -1
            s.system_memory_limit = -1

    def initViewer(self):
        if getData('state,MANUAL_MODE'):
            self.initViewerSbs(requested='xy')
        else:

            if cfg.main_window.rb0.isChecked():
                cfg.data['ui']['ng_layout'] = '4panel'
                self.initViewerSlim()
            elif cfg.main_window.rb1.isChecked():
                cfg.data['ui']['ng_layout'] = 'xy'
                self.initViewerSbs()


    def initViewerSbs(self, requested=None):
        caller = inspect.stack()[1].function
        logger.critical(f'Initializing EMViewer (caller: {caller})....')

        if requested == None:
            requested = cfg.data['ui']['ng_layout']
        mapping = {'xy': 'yz', 'yz': 'xy', 'xz': 'xz', 'xy-3d': 'yz-3d', 'yz-3d': 'xy-3d',
          'xz-3d': 'xz-3d', '4panel': '4panel', '3d': '3d'}
        nglayout = mapping[requested]

        # logger.critical(f'passed arg: {nglayout}')


        if cfg.data.is_mendenhall(): self.initViewerMendenhall(); return

        self.clear_layers()

        self.coordinate_space = ng.CoordinateSpace(
            names=['z', 'y', 'x'],
            units=['nm', 'nm', 'nm'],
            scales=list(cfg.data.resolution(s=cfg.data.curScale)),
        )

        if getData('state,MANUAL_MODE'):
            sf = cfg.data.scale_val(s=cfg.data.scale())
            al_path = os.path.join(cfg.data.dest(), 'img_aligned.zarr', 's' + str(sf))
            self.store = cfg.tensor = cfg.al_tensor =  get_zarr_tensor(al_path).result()
            self.index = cfg.data.layer()
            self.LV = ng.LocalVolume(
                volume_type='image',
                data=self.store[self.index:self.index + 1, :, :],
                dimensions=self.coordinate_space,
                voxel_offset=[0, 0, 0]
            )
        else:
            self.make_local_volumes()


        is_aligned = cfg.data.is_aligned_and_generated()
        if is_aligned:
            tensor_z, tensor_y, tensor_x = cfg.al_tensor.shape
        else:
            tensor_z, tensor_y, tensor_x = cfg.unal_tensor.shape

        self.set_zoom()
        sf = cfg.data.scale_val(s=cfg.data.scale())
        self.ref_l, self.base_l, self.aligned_l = 'ref_%d' % sf, 'base_%d' % sf, 'aligned_%d' % sf


        if getData('state,MANUAL_MODE'):
            self.grps = [ng.LayerGroupViewer(layers=[self.aligned_l], layout=nglayout)]
        else:
            self.grps = []
            self.grps.append(ng.LayerGroupViewer(layers=[self.ref_l], layout=nglayout))
            self.grps.append(ng.LayerGroupViewer(layers=[self.base_l], layout=nglayout))
            if is_aligned:
                self.grps.append(ng.LayerGroupViewer(layers=[self.aligned_l], layout=nglayout))

        with self.txn() as s:
            '''other settings:
            s.displayDimensions = ["z", "y", "x"]
            s.perspective_orientation
            s.concurrent_downloads = 512'''
            s.gpu_memory_limit = -1
            s.system_memory_limit = -1
            s.show_scale_bar = getOpt('neuroglancer,SHOW_SCALE_BAR')
            s.show_axis_lines = getOpt('neuroglancer,SHOW_AXIS_LINES')
            s.show_default_annotations = getOpt('neuroglancer,SHOW_YELLOW_FRAME')
            s.crossSectionBackgroundColor = '#808080'
            s.layout.type = nglayout
            if getData('state,MANUAL_MODE'):
                s.layers[self.aligned_l] = ng.ImageLayer(source=self.LV, shader=cfg.data['rendering']['shader'], )
            else:
                s.layers[self.ref_l] = ng.ImageLayer(source=cfg.refLV, shader=cfg.data['rendering']['shader'], )
                s.layers[self.base_l] = ng.ImageLayer(source=cfg.baseLV, shader=cfg.data['rendering']['shader'],)
                if is_aligned: s.layers[self.aligned_l] = ng.ImageLayer(source=cfg.alLV, shader=cfg.data['rendering']['shader'],)
            s.showSlices=False
            s.layout = ng.row_layout(self.grps)  # col

            if getData('state,MANUAL_MODE'):
                s.position = [0, tensor_y / 2, tensor_x / 2]
            else:
                s.position = [cfg.data.layer(), tensor_y / 2, tensor_x / 2]

        with self.config_state.txn() as s:
            if self.force_xy:
                s.show_ui_controls = False
            else:
                s.show_ui_controls = getOpt('neuroglancer,SHOW_UI_CONTROLS')
            s.show_panel_borders = getOpt('neuroglancer,SHOW_PANEL_BORDERS')

        self._layer = math.floor(self.state.position[0])
        self._crossSectionScale = self.state.cross_section_scale

        if self.webengine:
            self.webengine.setUrl(QUrl(self.get_viewer_url()))
            time.sleep(.25)
            self.webengine.setUrl(QUrl(self.get_viewer_url()))
            time.sleep(.25)
            self.webengine.setUrl(QUrl(self.get_viewer_url()))


    def initViewerSlim(self, nglayout=None):
        caller = inspect.stack()[1].function
        logger.critical(f'Initializing EMViewer Slim (caller: {caller})....')

        if self.force_xy:
            logger.info('Forcing xy...')
            requested = 'xy'
        else:
            requested = cfg.data['ui']['ng_layout']
        mapping = {'xy': 'yz', 'yz': 'xy', 'xz': 'xz', 'xy-3d': 'yz-3d', 'yz-3d': 'xy-3d',
          'xz-3d': 'xz-3d', '4panel': '4panel', '3d': '3d'}
        nglayout = mapping[requested]

        zd = ('img_src.zarr', 'img_aligned.zarr')[cfg.data.is_aligned_and_generated()]
        path = os.path.join(cfg.data.dest(), zd, 's' + str(cfg.data.scale_val()))
        if not os.path.exists(path):
            cfg.main_window.warn('Zarr Not Found: %s' % path)
            return
        try:
            if cfg.USE_TENSORSTORE:
                self.store = cfg.tensor = get_zarr_tensor(path).result()
            else:
                logger.info('Opening Zarr...')
                self.store = zarr.open(path)
        except:
            print_exception()
            cfg.main_window.warn('There was a problem loading tensor at %s' % path)
            cfg.main_window.warn('Trying with regular Zarr datastore...')
            try:
                self.store = zarr.open(path)
            except:
                print_exception()
                cfg.main_window.warn('Unable to load Zarr')
                return
            else:    print('Zarr Loaded Successfully!')
        else:
            print('TensorStore Loaded Successfully!')

        self.coordinate_space = ng.CoordinateSpace(
            names=['z', 'y', 'x'],
            units=['nm', 'nm', 'nm'],
            scales=list(cfg.data.resolution(s=cfg.data.scale())), )

        self.LV = cfg.LV = cfg.LV = ng.LocalVolume(
            volume_type='image',
            data=self.store[:, :, :],
            dimensions=self.coordinate_space,
            voxel_offset=[0, ] * 3,
        )

        with self.txn() as s:
            s.layout.type = nglayout
            s.gpu_memory_limit = -1
            s.system_memory_limit = -1
            s.show_scale_bar = getOpt('neuroglancer,SHOW_SCALE_BAR')
            s.show_axis_lines = getOpt('neuroglancer,SHOW_AXIS_LINES')
            s.position=[cfg.data.layer(), self.store.shape[1]/2, self.store.shape[2]/2]
            s.layers['layer'] = ng.ImageLayer( source=self.LV, shader=cfg.data['rendering']['shader'], )
            s.crossSectionBackgroundColor = '#808080' # 128 grey
            s.show_default_annotations = getOpt('neuroglancer,SHOW_YELLOW_FRAME')


        with self.config_state.txn() as s:
            if self.force_xy:
                s.show_ui_controls = False
            else:
                s.show_ui_controls = getOpt('neuroglancer,SHOW_UI_CONTROLS')
            s.show_panel_borders = getOpt('neuroglancer,SHOW_PANEL_BORDERS')
            # s.viewer_size = [100,100]

        self._layer = self.request_layer()
        self.shared_state.add_changed_callback(self.on_state_changed) #0215+ why was this OFF?
        # self.shared_state.add_changed_callback(lambda: self.defer_callback(self.on_state_changed))

        if self.webengine:
            self.webengine.setUrl(QUrl(self.get_viewer_url()))



    def set_zoom(self):
        logger.info('')

        if self.cs_scale:
            with self.txn() as s:
                s.crossSectionScale = self.cs_scale
        else:

            area = cfg.main_window.globTabs.geometry().getRect()
            if cfg.data.is_aligned_and_generated():
                tensor_z, tensor_y, tensor_x = cfg.al_tensor.shape
            else:
                tensor_z, tensor_y, tensor_x = cfg.unal_tensor.shape

            if cfg.main_window.rb1.isChecked():
                widget_w = (area[2] / 2, area[2] / 3)[cfg.data.is_aligned_and_generated()]
            else:
                widget_w = area[2] / 2
            widget_h = area[3]

            if getData('state,MANUAL_MODE'):
                widget_w = cfg.project_tab.MA_webengine_stage.geometry().width()
                widget_h = cfg.project_tab.MA_webengine_stage.geometry().height()
                logger.info('widget w/h: %d/%d' % (widget_w, widget_h))

            res_z, res_y, res_x = cfg.data.resolution(s=cfg.data.scale()) # nm per imagepixel
            # tissue_h, tissue_w = res_y*frame[0], res_x*frame[1]  # nm of sample

            if getData('state,MANUAL_MODE'):
                scale_h = ((res_y * tensor_y) / widget_h) * 1e-9  # nm/pixel (subtract height of ng toolbar)
                scale_w = ((res_x * tensor_x) / widget_w) * 1e-9  # nm/pixel (subtract width of sliders)
            else:
                scale_h = ((res_y*tensor_y) / (widget_h - 74)) * 1e-9  # nm/pixel (subtract height of ng toolbar)
                scale_w = ((res_x*tensor_x) / (widget_w - 20)) * 1e-9  # nm/pixel (subtract width of sliders)
            cs_scale = max(scale_h, scale_w)

            # logger.info('res_y    = %s' % str(res_y))
            # logger.info('area[3]  = %s' % (str(area[3])))
            # logger.info('nm/pixel (height)    : %.11f' % scale_h)
            # logger.info('nm/pixel (width)     : %.11f' % scale_w)
            # logger.info('zoom factor          : %.11f' % cs_scale)

            with self.txn() as s:
                if getData('state,MANUAL_MODE'):
                    s.crossSectionScale = cs_scale *1.04
                else:
                    s.crossSectionScale = cs_scale * 1.06


    # def set_rds(self):
    #     with self.txn() as s:
    #         s.relative_display_scales = {'z': 14}


    def get_nudge(self):
        if cfg.data.is_aligned_and_generated():
            _, tensor_y, tensor_x = cfg.al_tensor.shape
            return (tensor_x - cfg.al_tensor.shape[2]) / 2, (tensor_y - cfg.al_tensor.shape[1]) / 2
        else:
            return 0, 0
        return (x_nudge, y_nudge)


    def on_state_changed(self):
        if getData('state,MANUAL_MODE'):
            return

        caller = inspect.stack()[1].function
        curframe = inspect.currentframe()
        calframe = inspect.getouterframes(curframe, 2)
        calname = str(calframe[1][3])
        if calname == '<lambda>':
            return
        # logger.info('caller: %s, calname: %s' % (caller, calname))

        if not self.cs_scale:
            if self.state.cross_section_scale:
                if self.state.cross_section_scale > .0001:
                    logger.info('perfect cs_scale captured! - %.3f' % self.state.cross_section_scale)
                    self.cs_scale = self.state.cross_section_scale

        try:
            # print('requested layer: %s' % str(self.state.position[0]))
            # request_layer = floor(self.state.position[0])
            if isinstance(self.state.position, np.ndarray):
                request_layer = int(self.state.position[0])
                if request_layer == self._layer:
                    logger.debug('State Changed, But Layer Is The Same - Suppressing The stateChanged Callback Signal')
                else:
                    self._layer = request_layer
                    logger.info(f'(!) emitting request_layer: {request_layer}')
                    self.signals.stateChanged.emit(request_layer)

            zoom = self.state.cross_section_scale
            # logger.info('self.state.cross_section_scale = %s' % str(zoom))
            if zoom:
                if zoom != self._crossSectionScale:
                    logger.info(f' (!) emitting zoomChanged (state.cross_section_scale): {zoom}...')
                    self.signals.zoomChanged.emit(zoom)
                self._crossSectionScale = zoom
        except:
            print_exception()
            logger.error('ERROR on_state_change')


    def url(self):
        return self.get_viewer_url()


    def get_layout(self):
        mapping = {'xy': 'yz', 'yz': 'xy', 'xz': 'xz', 'xy-3d': 'yz-3d', 'yz-3d': 'xy-3d',
              'xz-3d': 'xz-3d', '4panel': '4panel', '3d': '3d'}
        val = mapping[cfg.main_window.comboboxNgLayout.currentText()]
        return val


    def clear_layers(self):
        if self.state.layers:
            logger.info('Clearing viewer layers...')
            state = copy.deepcopy(self.state)
            state.layers.clear()
            self.set_state(state)


    def set_row_layout(self, nglayout):

        with self.txn() as s:
            if cfg.data.is_aligned_and_generated():
                if getData('state,MANUAL_MODE'):
                    s.layout = ng.row_layout([
                        ng.column_layout([
                            ng.LayerGroupViewer(layers=[self.aligned_l], layout=nglayout),
                        ]),
                    ])
                else:
                    s.layout = ng.row_layout([
                        ng.column_layout([
                            ng.LayerGroupViewer(layers=[self.ref_l], layout=nglayout),
                            ng.LayerGroupViewer(layers=[self.base_l], layout=nglayout),
                        ]),
                        ng.column_layout([
                            ng.LayerGroupViewer(layers=[self.aligned_l], layout=nglayout),
                        ]),
                    ])
            else:
                s.layout = ng.row_layout(self.grps)


    def make_local_volumes(self):
        sf = cfg.data.scale_val(s=cfg.data.scale())
        al_path = os.path.join(cfg.data.dest(), 'img_aligned.zarr', 's' + str(sf))
        unal_path = os.path.join(cfg.data.dest(), 'img_src.zarr', 's' + str(sf))
        cfg.tensor = cfg.unal_tensor = cfg.al_tensor = None
        try:
            cfg.unal_tensor = get_zarr_tensor(unal_path).result()
            if cfg.data.is_aligned_and_generated(): cfg.al_tensor = get_zarr_tensor(al_path).result()
            cfg.tensor = (cfg.unal_tensor, cfg.al_tensor)[cfg.data.is_aligned_and_generated()]
        except Exception as e:
            logger.warning('Failed to acquire Tensorstore view')
            raise e

        x_nudge, y_nudge = self.get_nudge()
        cfg.refLV = ng.LocalVolume(
            volume_type='image',
            data=cfg.unal_tensor[0:len(cfg.data) - 1, :, :],
            dimensions=self.coordinate_space,
            voxel_offset=[1, y_nudge, x_nudge]
        )
        cfg.baseLV = ng.LocalVolume(
            volume_type='image',
            data=cfg.unal_tensor[:, :, :],
            dimensions=self.coordinate_space,
            voxel_offset=[0, y_nudge, x_nudge],
        )
        if cfg.data.is_aligned_and_generated():
            cfg.alLV = ng.LocalVolume(
                volume_type='image',
                data=cfg.al_tensor[:, :, :],
                dimensions=self.coordinate_space,
                voxel_offset=[0, ] * 3,
            )
        if cfg.data.is_aligned_and_generated():
            cfg.LV = ng.LocalVolume(
                volume_type='image',
                data=cfg.al_tensor[:, :, :],
                dimensions=self.coordinate_space,
                voxel_offset=[0, ] * 3,
            )
        else:
            cfg.LV = ng.LocalVolume(
                volume_type='image',
                data=cfg.unal_tensor[:, :, :],
                dimensions=self.coordinate_space,
                voxel_offset=[0, ] * 3,
            )
__all__ = ['MAViewer']

logger = logging.getLogger(__name__)


class WorkerSignals(QObject):
    result = Signal(str)
    stateChanged = Signal()
    zoomChanged = Signal(float)
    mpUpdate = Signal()
    ptsChanged = Signal()


class MAViewer(neuroglancer.Viewer):
    def __init__(self, index, role=None, webengine=None):
        super().__init__()
        self.index = index
        if role:
            self.role = role
        self.webengine = webengine
        self.signals = WorkerSignals()
        self.created = datetime.datetime.now()
        self._layer = None
        self.cs_scale = None
        self.pts = {}
        self.points = {}
        self.mp_colors = ['#f3e375', '#5c4ccc', '#800000', '#aaa672',
                          '#152c74', '#404f74', '#f3e375', '#5c4ccc',
                          '#d6acd6', '#aaa672', '#152c74', '#404f74'
                          ]
        self._crossSectionScale = 1
        self._mpCount = 0
        self.shared_state.add_changed_callback(self.on_state_changed)
        # self.shared_state.add_changed_callback(lambda: self.defer_callback(self.on_state_changed))

        logger.info('viewer constructed!')

        self.coordinate_space = ng.CoordinateSpace(
            names=['z', 'y', 'x'],
            units=['nm', 'nm', 'nm'],
            scales=list(cfg.data.resolution(s=cfg.data.scale())), )

        # self.restoreManAlignPts()


    def __del__(self):
        try:
            caller = inspect.stack()[1].function
            logger.warning('__del__ called by [%s] on EMViewer (created: %s)'
                           % (caller, self.created))
        except Exception as e:
            logger.warning('Lost Track Of Caller')

    # def __str__(self):
    #     return obj_to_string(self)

    def __repr__(self):
        return copy.deepcopy(self.state)


    def invalidateAlignedLayers(self):
        cfg.alLV.invalidate()


    def set_zmag(self):
        with self.txn() as s:
            s.relativeDisplayScales = {"z": 10} # this should work, but does not work. ng bug.


    def initViewer(self):
        # caller = inspect.stack()[1].function
        logger.info(f'Initializing Viewer (Role: %s)....' %self.role)
        sf = cfg.data.scale_val(s=cfg.data.scale())

        self.clear_layers()
        self.restoreManAlignPts()


        if self.role == 'base':
            self.index = cfg.data.layer()
            path = os.path.join(cfg.data.dest(), 'img_src.zarr', 's' + str(sf))
        elif self.role == 'ref':
            path = os.path.join(cfg.data.dest(), 'img_src.zarr', 's' + str(sf))
        elif self.role == 'stage':
            self.index = 0 #placeholder. this will be the index of staging area.
            path = os.path.join(cfg.data.dest(), 'img_stage.zarr', 's' + str(sf))

        if not os.path.exists(path):
            cfg.main_window.warn('Data Store Not Found: %s' % path)
            logger.warning('Data Store Not Found: %s' % path); return

        try:
            self.store = get_zarr_tensor(path).result()
        except Exception as e:
            cfg.main_window.warn('Unable to Load Data Store at %s' % path)
            raise e

        self.LV = ng.LocalVolume(
            volume_type='image',
            data=self.store[self.index:self.index+1, :, :],
            dimensions=self.coordinate_space,
            voxel_offset=[0, 0, 0]
        )

        with self.txn() as s:

            s.layout.type = 'yz'
            s.gpu_memory_limit = -1
            s.system_memory_limit = -1
            s.show_scale_bar = getOpt('neuroglancer,SHOW_SCALE_BAR')
            s.show_axis_lines = getOpt('neuroglancer,SHOW_AXIS_LINES')
            s.show_default_annotations = getOpt('neuroglancer,SHOW_YELLOW_FRAME')
            # s.position=[cfg.data.layer(), store.shape[1]/2, store.shape[2]/2]
            s.layers['layer'] = ng.ImageLayer(source=self.LV)
            s.crossSectionBackgroundColor = '#808080' # 128 grey
            # s.cross_section_scale = 1 #bug # cant do this
            _, y, x = self.store.shape
            # s.position = [0.5, y / 2, x / 2]
            s.position = [0.5, y / 2, x / 2]
            s.layers['ann'].annotations = list(self.pts.values())

        self.actions.add('add_manpoint', self.add_matchpoint)

        with self.config_state.txn() as s:
            s.input_event_bindings.slice_view['shift+click0'] = 'add_manpoint'
            s.show_ui_controls = False
            s.show_panel_borders = False

        with self.config_state.txn() as s:
            s.show_ui_controls = getOpt('neuroglancer,SHOW_UI_CONTROLS')
            s.show_panel_borders = getOpt('neuroglancer,SHOW_PANEL_BORDERS')

        self.update_annotations()

        if self.webengine:
            self.webengine.setUrl(QUrl(self.get_viewer_url()))


    def get_layout(self, requested=None):
        if requested == None:
            requested = cfg.data['ui']['ng_layout']
        mapping = {'xy': 'yz', 'yz': 'xy', 'xz': 'xz', 'xy-3d': 'yz-3d', 'yz-3d': 'xy-3d',
              'xz-3d': 'xz-3d', '4panel': '4panel', '3d': '3d'}
        return mapping[requested]


    def on_state_changed(self):
        # caller = inspect.stack()[1].function
        curframe = inspect.currentframe()
        calframe = inspect.getouterframes(curframe, 2)
        calname = str(calframe[1][3])
        if calname == '<lambda>':
            return
        # logger.info('caller: %s, calname: %s' % (caller, calname))

        self.signals.stateChanged.emit()

        # if not self.cs_scale:
        #     if self.state.cross_section_scale:
        #         if self.state.cross_section_scale > .0001:
        #             logger.info('perfect cs_scale captured! - %.3f' % self.state.cross_section_scale)
        #             self.cs_scale = self.state.cross_section_scale
        #
        # try:
        zoom = self.state.cross_section_scale
        if zoom:
            if zoom != self._crossSectionScale:
                logger.info(f' (!) emitting zoomChanged (state.cross_section_scale): {zoom}...')
                self.signals.zoomChanged.emit(zoom)
            self._crossSectionScale = zoom


    def pt2ann(self, points: list):
        annotations = []
        lineweight = cfg.main_window.mp_marker_lineweight_spinbox.value()
        size = cfg.main_window.mp_marker_size_spinbox.value()
        for i, point in enumerate(points):
            annotations.append(ng.PointAnnotation(id=repr(point),
                                                  point=point,
                                                  props=[self.mp_colors[i % 3],
                                                         size,
                                                         lineweight]))
        self.annotations = annotations
        return annotations


    def addMp(self):

        pass

    def add_matchpoint(self, s):
        coords = np.array(s.mouse_voxel_coordinates)
        logger.info('Coordinates: %s' %str(coords))
        if coords.ndim == 0:
            logger.warning('Coordinates are dimensionless! =%s' % str(coords))
            return

        _, y, x = s.mouse_voxel_coordinates
        z = 0.5


        props = [self.mp_colors[len(self.pts)], getOpt('neuroglancer,MATCHPOINT_MARKER_LINEWEIGHT'), getOpt('neuroglancer,MATCHPOINT_MARKER_SIZE'), ]
        self.pts[self.getNextUnusedColor()] = ng.PointAnnotation(id=repr((z,y,x)), point=(z,y,x), props=props)
        self.update_annotations()
        self.signals.ptsChanged.emit()
        logger.info('%s Match Point Added: %s' % (self.role, str(coords)))



    def update_annotations(self):
        anns = list(self.pts.values())
        if anns:
            with self.txn() as s:
                s.layers['ann'].annotations = anns


    def getNextUnusedColor(self):
        for c in self.mp_colors:
            if c in self.pts:
                continue
            else:
                return c


    def getUsedColors(self):
        return set(self.pts.keys())


    def save_matchpoints(self):
        layer = cfg.data.layer()
        logger.info('Saving Match Points for Section #%d: %s' % (layer, cfg.data.base_image_name(l=layer)))
        p_ = [p.point.tolist() for p in self.pts.values()]
        logger.critical('p_: %s' %str(p_))
        mps = [p_[0][1::], p_[1][1::], p_[2][1::]]
        cfg.data.set_manual_points(role=self.role, matchpoints=mps, l=layer)
        cfg.data.set_selected_method(method="Match Point Align", l=layer)
        cfg.data.print_all_match_points()
        cfg.main_window._saveProjectToFile(silently=True)
        cfg.main_window.hud.post('Match Points Saved!')


    # def clear_matchpoints(self, s):
    #     cfg.main_window.hud.post('Clearing manual correspondence point buffer of %d match points...' % self._mpCount)
    #     logger.warning('Clearing manual correspondence point buffer of %d match points...' % self._mpCount)
    #     self.pts.clear()
    #     with self.txn() as s:
    #         s.layers['ann'].annotations = self.pt2ann(cfg.data.getmpFlat()[self.role])


    def url(self):
        return self.get_viewer_url()


    def clear_layers(self):
        if self.state.layers:
            logger.info('Clearing viewer layers...')
            state = copy.deepcopy(self.state)
            state.layers.clear()
            self.set_state(state)

    def restoreManAlignPts(self):
        logger.info('')

        for i, p in enumerate(cfg.data.getmpFlat()[self.role]):
            props = [self.mp_colors[i],
                     getOpt('neuroglancer,MATCHPOINT_MARKER_LINEWEIGHT'),
                     getOpt('neuroglancer,MATCHPOINT_MARKER_SIZE'), ]
            self.pts[self.getNextUnusedColor()] = ng.PointAnnotation(id=str(p), point=p, props=props)

        with self.txn() as s:
            s.layers['ann'] = ng.LocalAnnotationLayer(
                dimensions=self.coordinate_space,
                annotations=self.pt2ann(points=cfg.data.getmpFlat()[self.role]),
                annotation_properties=[
                    ng.AnnotationPropertySpec(id='ptColor', type='rgb', default='white', ),
                    ng.AnnotationPropertySpec(id='ptWidth', type='float32', default=getOpt('neuroglancer,MATCHPOINT_MARKER_LINEWEIGHT')),
                    ng.AnnotationPropertySpec(id='size', type='float32', default=getOpt('neuroglancer,MATCHPOINT_MARKER_SIZE'))
                ],
                shader=copy.deepcopy(ann_shader),
            )
__all__ = ['ZarrViewer']

ng.server.debug = cfg.DEBUG_NEUROGLANCER
numcodecs.blosc.use_threads = False

log = logging.getLogger(__name__)


class WorkerSignals(QObject):
    stateChanged = Signal(int)
    zoomChanged = Signal(float)

class ZarrViewer(neuroglancer.Viewer):

    def __init__(self, path):
        super().__init__()
        self.path = path
        self.signals = WorkerSignals()
        self.created = datetime.datetime.now()
        self._layer = None
        self.bootstrap()

    def __del__(self):
        caller = inspect.stack()[1].function
        log.warning('__del__ called by [%s], created: %s'% (caller, self.created))

    def __repr__(self):
        return copy.deepcopy(self.state)

    def url(self):
        return self.get_viewer_url()

    def tensorstore(self, path):
        return get_zarr_tensor(path).result()

    def zarrstore(self, path):
        return zarr.open(path)

    def validate_zarr(self, path) -> bool:
        if os.path.isdir(path):
            if '.zarray' in os.listdir(path):
                return True
        return False

    def coordinates(self, res=(50,2,2)):
        return neuroglancer.CoordinateSpace(
            names=['z', 'y', 'x'],
            units=['nm', 'nm', 'nm'],
            scales=res, )

    def local_volume(self, store, coords):
        return neuroglancer.LocalVolume(
            volume_type='image',
            data=store,
            dimensions=coords,
            voxel_offset=[0, 0, 0],
        )

    def get_layout(self):
        sw = {'xy': 'yz', 'yz': 'xy', 'xz': 'xz', 'xy-3d': 'yz-3d', 'yz-3d': 'xy-3d',
              'xz-3d': 'xz-3d', '4panel': '4panel', '3d': '3d'}
        return sw[cfg.main_window.comboboxNgLayout.currentText()]

    def add_callback(self, fn):
        self.shared_state.add_changed_callback(fn)

    def add_deferred_callback(self, fn):
        self.shared_state.add_changed_callback(lambda: self.defer_callback(fn))

    def add_layer(self):
        pass

    def bootstrap(self):
        log.info('Configuring txn...')

        store = self.tensorstore(self.path)
        coords = self.coordinates(res=(50,2,2))
        LV = self.local_volume(store, coords)
        layout = self.get_layout()
        self.add_callback(self.on_state_changed)

        with self.txn() as s:
            s.layout.type = layout
            s.gpu_memory_limit = -1
            s.system_memory_limit = -1
            s.show_scale_bar = getOpt('neuroglancer,SHOW_SCALE_BAR')
            s.show_axis_lines = getOpt('neuroglancer,SHOW_AXIS_LINES')
            s.position=[0, store.shape[1]/2, store.shape[2]/2]
            s.layers['layer'] = neuroglancer.ImageLayer(source=LV, shader=cfg.SHADER)
            s.crossSectionBackgroundColor = '#808080' # 128 grey

        with self.config_state.txn() as s:
            s.show_ui_controls = getOpt('neuroglancer,SHOW_UI_CONTROLS')
            s.show_panel_borders = getOpt('neuroglancer,SHOW_PANEL_BORDERS')
            # s.viewer_size = [100,100]

        self._layer = self.request_layer()
        self.shared_state.add_changed_callback(self.on_state_changed)


    def request_layer(self):
        return math.floor(self.state.position[0])

    def on_state_changed(self):
        pass
log = logging.getLogger(__name__)


class Config():
    def __init__(self, args):
        # HTTP bind address and port, configurable from here
        self.bind = '127.0.0.1'
        self.port = 9000

        # Neuroglancer server settings, configurable from here
        self.gpu_memory_limit = -1
        self.system_memory_limit = -1
        self.concurrent_downloads = 512
        self.neuroglancer_server_debug = True  # verbose neuroglancer

        # TensorStore settings
        self.cache_pool_total_bytes_limit = 250_000_000_000  # Lonestar6: 256 GB (3200 MT/s) DDR4
        self.dtype = 'uint8'
        self.driver = 'zarr'

        # Neuroglancer emViewer options, configurable from here
        self.show_panel_borders = False
        self.show_ui_controls = False
        self.show_scale_bar = True
        self.show_axis_lines = False
        self.background_color = '#808080'  # 128 grey

        # Command line options
        self.PATH = args.path[0]
        self.VOXELSIZE = args.voxelsize
        self.BROWSER = args.browser
        self.HEADLESS = args.headless


def get_zarr_tensor(path, bytes_limit, dtype, driver):
    '''
    Returns an asynchronous TensorStore future object.
    Ref: https://stackoverflow.com/questions/64924224/getting-a-view-of-a-zarr-array-slice
    '''
    arr = ts.open({
        'dtype': dtype,
        'driver': driver,
        'kvstore': {
            'driver': 'file',
            'path': path
        },
        'context': {
            'cache_pool': {'total_bytes_limit': bytes_limit},
            'data_copy_concurrency': {'limit': 128},
            'file_io_concurrency': {'limit': 128},
        },
        'recheck_cached_data': 'open',
    })
    return arr


class NgBootstrap():
    def __init__(self, cfg):
        self.created = datetime.datetime.now()
        self.cfg = cfg
        self.LV = None
        self.url = None
        self.webdriver = None

    def __del__(self):
        log.info('__del__ was called by [%s] on EMViewer, created:%s' % (inspect.stack()[1].function, self.created))

    def __repr__(self):
        return copy.deepcopy(self.viewer.state)

    def request_layer(self):
        return math.floor(self.viewer.state.position[0])

    def show_webdriver_log(self):
        if self.webdriver:
            log.info(f'Webdriver Log:\n{json.dumps(self.webdriver.get_log(), indent=2)}')

    def initViewer(self):
        log.info(f'Initializing Neuroglancer Viewer...')
        ng.server.debug = self.cfg.neuroglancer_server_debug
        self.viewer = ng.Viewer()
        ng.set_server_bind_address(bind_address=self.cfg.bind, bind_port=self.cfg.port)

        with self.viewer.txn() as s:
            s.gpu_memory_limit     = self.cfg.gpu_memory_limit
            s.system_memory_limit  = self.cfg.system_memory_limit
            s.concurrent_downloads = self.cfg.concurrent_downloads
            s.show_scale_bar       = self.cfg.show_scale_bar
            s.show_axis_lines      = self.cfg.show_axis_lines
            s.crossSectionBackgroundColor = self.cfg.background_color
            try:
                self.tensor = get_zarr_tensor(
                    path=self.cfg.PATH,
                    dtype=self.cfg.dtype,
                    driver=self.cfg.driver,
                    bytes_limit=self.cfg.cache_pool_total_bytes_limit
                ).result()
                log.info('TensorStore Object Created Successfully!')
            except Exception as e:
                traceback.print_exception(type(e), e, e.__traceback__)
                log.error('Invalid Zarr. Unable To Create Tensor for Zarr Array')

            self.coordinate_space = ng.CoordinateSpace(
                names=['z', 'y', 'x'],
                units=['nm', 'nm', 'nm'],
                scales=self.cfg.VOXELSIZE,
            )

            json.dumps(self.tensor.spec().to_json(), indent=2)
            self.LV = ng.LocalVolume(
                data=self.tensor,
                volume_type='image',
                dimensions=self.coordinate_space,
                voxel_offset=[0, 0, 0],
            )
            s.layers['layer'] = ng.ImageLayer(source=self.LV)

        with self.viewer.config_state.txn() as s:
            s.show_ui_controls = self.cfg.show_ui_controls
            s.show_panel_borders = self.cfg.show_panel_borders

        self.url = str(self.viewer)
        log.info('url: %s' % self.url)

        self.webdriver = neuroglancer.webdriver.Webdriver(
            self.viewer,
            headless=self.cfg.HEADLESS,
            browser=self.cfg.BROWSER,
        )