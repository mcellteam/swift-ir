# def get_code_mode():
#     print("Getting code mode...")
#     ### All of this code is just trying to find the right menu item for the "Use C Version" check box:
#     code_mode = 'python'
#     menubar = alignem.main_window.menu
#     menubar_items = [menubar.children()[x].title() for x in range(len(menubar.children())) if
#                      'title' in dir(menubar.children()[x])]
#     submenus = [menubar.children()[x] for x in range(len(menubar.children())) if
#                 'title' in dir(menubar.children()[x])]
#     alignem.print_debug(40, "Menubar contains: " + str(menubar_items))
#     setmenu_index = -1
#     for m in menubar_items:
#         if "Set" in m:
#             setmenu_index = menubar_items.index(m)
#     alignem.print_debug(40, "Set menu is item " + str(setmenu_index))
#     if setmenu_index >= 0:
#         set_menu = submenus[setmenu_index]
#         set_menu_actions = set_menu.actions()
#         use_c_version = None
#         for action in set_menu_actions:
#             if "Use C Version" in action.text():
#                 use_c_version = action
#                 break
#         if use_c_version != None:
#             if use_c_version.isChecked():
#                 code_mode = "c"
#     print("get_code_mode is returning: ", code_mode)
#     return (code_mode)


# @Slot()
# def set_current_scale(self, checked):
#     print("@Slot Setting current scale | MainWindow.set_current_scale...")
#     local_cur_scale = get_cur_layer()
#     print_debug ( 30, "Set current Scale to " + str(self.sender().text()) )
#     old_scale = local_cur_scale
#     new_scale = get_scale_key ( str ( self.sender().text() ) )
#     if self.view_change_callback != None:
#       leaving_layer = project_data['data']['current_layer']
#       entering_layer = project_data['data']['current_layer']
#       try:
#         # This guards against errors in "user code"
#         main_window.view_change_callback ( old_scale, new_scale, leaving_layer, entering_layer )
#       except:
#         print_debug ( 0, "Exception in set_current_scale: " + str(sys.exc_info()) )
#     local_cur_scale = new_scale
#     project_data['data']['current_scale'] = local_cur_scale
#     print_debug ( 30, "Set current_scale key to " + str(project_data['data']['current_scale']) )
#
#     image_library.update()
#
#     for p in self.panel_list:
#         p.update_zpa_self()
#     self.update_win_self()
#
#     self.reload_scales_combobox()
#
#     self.center_all_images() #center
#     self.update_win_self()


# @Slot()
# def generate_scales_callback(self):
#     print("@Slot Generating scales callback | MainWindow.generate_scales_callback...")
#     print_debug ( 5, "Generating scales is now handled via control panel buttons in subclass alignem_swift." )



# def set_selected_scale ( self, scale_str ):
#     print("!!! Setting selected scale | MainWindow.set_selected_scale...")
#     print("  scale_str = ", str(scale_str))
#     # Set the Scales menu from this scales_list
#     mb = self.menuBar()
#     if not (mb is None):
#       for m in mb.children():
#         if type(m) == QMenu:
#           text_label = ''.join(m.title().split('&'))
#           if 'Scale' in text_label:
#             print_debug ( 30, "Found Scale Menu" )
#             scale_to_match = int(str(project_data['data']['current_scale'].split('_')[1]))
#             print("  scale_to_match = ", scale_to_match)
#             for a in m.actions():
#               if int(a.text()) == scale_to_match:
#                 a.setChecked ( True )
#                 project_data['data']['current_scale'] = 'scale_' + str(scale_to_match)
#               else:
#                 a.setChecked ( False )
#
#     self.center_all_images() #center
#     self.update_win_self()
#
#     self.update_panels()
#     self.refresh_all()


# def null_bias_changed_callback(state):
#     global ignore_changes
#     print_debug(50, 100 * '+')
#     print_debug(50, "Null Bias changed to " + str(state))
#     print_debug(50, "ignore_changes = " + str(ignore_changes))
#     print_debug(50, 100 * '+')
#     if not ignore_changes:
#         if state:
#             project_data['data']['scales'][project_data['data']['current_scale']]['null_cafm_trends'] = True
#         else:
#             project_data['data']['scales'][project_data['data']['current_scale']]['null_cafm_trends'] = False
#         print_debug(50, "null_bias_changed_callback (" + str(state) + " saved as " + str(
#             project_data['data']['scales'][project_data['data']['current_scale']]['null_cafm_trends']) + ")")


# def bool_changed_callback ( state ):
#     global ignore_changes
#     print_debug ( 50, 100*'+' )
#     print_debug ( 2, "Bool changed to " + str(state) )
#     print_debug ( 2, "ignore_changes = " + str(ignore_changes))
#     print_debug ( 50, 100*'+' )
#     if not ignore_changes:
#         if main_window != None:
#             if main_window.view_change_callback != None:
#                 layer_num = 0
#                 if project_data != None:
#                     if 'data' in project_data:
#                         if 'current_layer' in project_data['data']:
#                             layer_num = project_data['data']['current_layer']
#                 ignore_changes = True
#                 main_window.view_change_callback ( None, None, layer_num, layer_num )
#                 ignore_changes = False


# class ControlPanelWidget(QWidget):
#     """A widget to hold all of the application data for an alignment method."""
#     def __init__(self, control_model=None):
#         super(ControlPanelWidget, self).__init__()
#         self.cm = control_model
#         #self.control_panel = QWidget()
#         self.control_panel_layout = QVBoxLayout()
#         self.setLayout(self.control_panel_layout)
#         #self.control_panel_layout.setContentsMargin(0) #pyside6
#         #self.control_panel_layout.setMargin(0) #pyside2
#         self.control_panel_layout.setSpacing(0)
#
#         if self.cm != None:
#             # Only show the first pane for now
#             rows = control_model[0]
#             print_debug ( 30, "Pane contains " + str(len(rows)) + " rows" )
#
#             for row in rows:
#               row_box = QWidget()
#               row_box_layout = QHBoxLayout()
#               #row_box_layout.setContentsMargin(2) #pyside6
#               #row_box_layout.setMargin(2) #pyside2
#               row_box_layout.setSpacing(2)
#               row_box.setLayout ( row_box_layout )
#               print_debug ( 30, "Row contains " + str(len(row)) + " items" )
#               for item in row:
#                   print_debug ( 30, "  Item is " + str(item) )
#                   if type(item) == type('a'):
#                       item_widget = QLabel ( str(item) )
#                       item_widget.setAlignment(Qt.AlignHCenter)
#                       row_box_layout.addWidget ( item_widget )
#                   elif type(item) == type([]):
#                       item_widget = QPushButton ( str(item[0]) )
#                       row_box_layout.addWidget ( item_widget )
#                   elif isinstance(item, BoolField):
#                       val_widget = ( QCheckBox ( str(item.text) ) )
#                       row_box_layout.addWidget ( val_widget )
#                       # Hard code a few special callbacks ...
#                       if item.text == "Null Bias":
#                           #val_widget.stateChanged.connect(null_bias_changed_callback)
#                           val_widget.clicked.connect(null_bias_changed_callback)
#                       elif item.text == "Bounding Rect":
#                           #val_widget.stateChanged.connect(bounding_rect_changed_callback)
#                           val_widget.clicked.connect(bounding_rect_changed_callback)
#                       elif item.text == "Skip":
#                           #val_widget.stateChanged.connect(skip_changed_callback)
#                           val_widget.clicked.connect(skip_changed_callback)
#                       else:
#                           #val_widget.stateChanged.connect(bool_changed_callback)
#                           val_widget.clicked.connect(bool_changed_callback)
#                       item.widget = val_widget
#                   elif isinstance(item, TextField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, IntField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, FloatField):
#                       if item.text != None:
#                           row_box_layout.addWidget ( QLabel ( str(item.text) ) )
#                       val_widget = ( QLineEdit ( str(item.value) ) )
#                       val_widget.setAlignment(Qt.AlignHCenter)
#                       item.widget = val_widget
#                       row_box_layout.addWidget ( val_widget )
#                   elif isinstance(item, CallbackButton):
#                       item_widget = QPushButton ( str(item.text) )
#                       item_widget.clicked.connect ( item.callback )
#                       item.widget = item_widget
#                       row_box_layout.addWidget ( item_widget )
#                   elif isinstance (item, ComboBoxControl):
#                       item_widget = QComboBox()
#                       item_widget.addItems (item.choices)
#                       #item_widget.clicked.connect ( item.callback )
#                       item.widget = item_widget
#                       row_box_layout.addWidget ( item_widget )
#                   else:
#                       item_widget = QLineEdit ( str(item) )
#                       item_widget.setAlignment(Qt.AlignHCenter)
#                       row_box_layout.addWidget ( item_widget )
#               self.control_panel_layout.addWidget ( row_box )
#
#     def dump ( self ):
#         print_debug ( 1, "Control Panel:" )
#         for p in self.cm:
#           print_debug ( 1, "  Panel:" )
#           for r in p:
#             print_debug ( 1, "    Row:" )
#             for i in r:
#               print_debug ( 1, "      Item: " + str(i) )
#               print_debug ( 1, "          Subclass of GenericWidget: " + str(isinstance(i,GenericWidget)) )
#
#     def copy_self_to_data ( self ):
#         data = []
#         for p in self.cm:
#           new_panel = []
#           for r in p:
#             new_row = []
#             for i in r:
#               if isinstance(i,GenericWidget):
#                 # Store as a list to identify as a widget
#                 new_row.append ( [ i.get_value() ] )
#               else:
#                 # Store as static raw data
#                 # new_row.append ( i )  # This data is useless since it's set by the application
#                 new_row.append ( '' )   # Save an empty string as a place holder for static data
#             new_panel.append ( new_row )
#           data.append ( new_panel )
#         return data
#
#     def copy_data_to_self ( self, data ):
#         ip = 0
#         for p in self.cm:
#           panel = data[ip]
#           ip += 1
#           ir = 0
#           for r in p:
#             row = panel[ir]
#             ir += 1
#             ii = 0
#             for i in r:
#               item = row[ii]
#               ii += 1
#               if type(item) == type([]):
#                 # This was a widget
#                 i.set_value ( item[0] )
#               else:
#                 # Ignore static raw data
#                 pass
#
#     def distribute_all_layer_data ( self, control_panel_layer_list ):
#         # First make a copy of this widget's data
#         this_layers_data = self.copy_self_to_data()
#
#         # Search the widgets for those that should be identical across all layers
#         page_index = 0
#         for p in self.cm:
#           row_index = 0
#           for r in p:
#             item_index = 0
#             for i in r:
#               if isinstance(i,GenericWidget):
#                 if 'all_layers' in dir(i):
#                   if i.all_layers:
#                     # Store this value in all layers
#                     for l in control_panel_layer_list:
#                       if l is None:
#                         # There is no data stored for this layer yet.
#                         # Maybe copy the entire nested list to a new layer?
#                         # But the Widget fields might take care of this anyway.
#                         # Pass for now.
#                         pass
#                       else:
#                         # Just set the values that should be identical
#                         l[page_index][row_index][item_index] = this_layers_data[page_index][row_index][item_index]
#               else:
#                 pass
#               item_index += 1
#             row_index += 1
#           page_index += 1


# class GenericWidget:
#     def __init__ ( self, text ):
#         self.text = text
#         self.widget = None
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class GenericField(GenericWidget):
#     def __init__ ( self, text, value, all_layers=0 ):
#         #super(None,self).__init__(text)
#         #super(GenericField,self).__init__(text)
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class TextField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return str(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class BoolField(GenericField):
#     """
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#         self.callback = callback
#         print_debug ( 20, "BoolField created with callback = " + str(self.callback) )
#     '''
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         super(BoolField,self).__init__( text, value, all_layers )
#         self.callback = callback
#     '''
#     """
#     def __init__ ( self, text, value, all_layers=0, callback=None ):
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.widget = None
#         self.value = value
#         self.all_layers = all_layers
#         self.callback = callback
#         print_debug ( 20, "BoolField created with callback = " + str(self.callback) )
#
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return bool(self.widget.isChecked())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setChecked(value)
#         except:
#           pass


# class IntField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return int(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class FloatField(GenericField):
#     def get_value ( self ):
#       if 'widget' in dir(self):
#         try:
#           return float(self.widget.text())
#         except:
#           return None
#       else:
#         return None
#     def set_value ( self, value ):
#       if 'widget' in dir(self):
#         try:
#           self.widget.setText(str(value))
#         except:
#           pass


# class CallbackButton(GenericWidget):
#     def __init__ ( self, text, callback ):
#         #super(CallbackButton,self).__init__(text)
#         self.text = text  # Should be handled by super, but fails in Python2
#         self.callback = callback
#     def get_value ( self ):
#         return None
#     def set_value ( self, value ):
#         pass


# class ComboBoxControl(GenericWidget):
#     def __init__ ( self, choices ):
#         #super(CallbackButton,self).__init__(text)
#         self.choices = choices
#         self.widget = None
#     def get_value ( self ):
#         return self.widget.currentText()
#         # AttributeError: 'ComboBoxControl' object has no attribute 'widget'
#     def set_value ( self, value ):
#         print("ComboBoxControl.set_value ( " + str(value) + ")")
#         self.widget.setCurrentText(value)
#         #print ( "Setting value")
#         #__import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
#         pass


# def closeEvent(self, event):
#
#     quit_msg = "Are you sure you want to exit the program?"
#     reply = QMessageBox.question(self, 'Message',
#                      quit_msg, QMessageBox.Yes, QMessageBox.No)
#
#     if reply == QMessageBox.Yes:
#         event.accept()
#     else:
#         event.ignore()


# def define_scales_menu(self, scales_list):
#     print("Defining scales menu | MainWindow.define_scales_menu...")
#
#     # Set the Scales menu from this scales_list
#     mb = self.menuBar()
#     if not (mb is None):
#         for m in mb.children():
#             if type(m) == QMenu:
#                 text_label = ''.join(m.title().split('&'))
#                 if 'Scale' in text_label:
#                     print_debug(30, "Found Scale Menu")
#                     # Remove all the old actions:
#                     while len(m.actions()) > 0:
#                         m.removeAction(m.actions()[-1])
#                     # Add the new actions
#                     first = True
#                     for scale in sorted([get_scale_val(s) for s in scales_list]):
#                         item = QAction(str(scale), self)
#                         item.setCheckable(True)
#                         item.setChecked(first)
#                         self.action_groups['Scales'].addAction(item)
#                         item.triggered.connect(self.set_current_scale)
#                         m.addAction(item)
#                         first = False



# @Slot()
# def define_scales_callback(self):
#     print("Displaying define scales dialog...")
#
#     default_scales = ['1']
#
#     cur_scales = [ str(v) for v in sorted ( [ get_scale_val(s) for s in project_data['data']['scales'].keys() ] ) ]
#     if len(cur_s
#         default_scales = cur_scales
#
#     input_val, ok = QInputDialog().getText ( None, "Define Scales", "Current: "+str(' '.join(default_scales)), echo=QLineEdit.Normal, text=' '.join(default_scales) )
#     if ok:
#         self.set_scales_from_string ( input_val ) #scales
#
#     else:
#         print("Cancel: Scales not changed" )
#         return # Want to exit function if no scales are defined



# def generate_scales():
#     print('Generating scales | generate_scales...')
#
#     alignem.print_debug(10, "generate_scales inside alignem_swift called")
#     # main_win.status.showMessage("Generating Scales ...")
#
#     image_scales_to_run = [alignem.get_scale_val(s) for s in sorted(alignem.project_data['data']['scales'].keys())]
#
#     alignem.print_debug(40, "Create images at all scales: " + str(image_scales_to_run))
#
#     if (alignem.project_data['data']['destination_path'] == None) or (
#             len(alignem.project_data['data']['destination_path']) <= 0):
#
#         alignem.show_warning("Note", "Scales can not be generated without a destination (use File/Set Destination)")
#
#     else:
#
#         for scale in sorted(image_scales_to_run):
#
#             alignem.print_debug(70, "Creating images for scale " + str(scale))
#             # main_win.status.showMessage("Generating Scale " + str(scale) + " ...")
#
#             scale_key = str(scale)
#             if not 'scale_' in scale_key:
#                 scale_key = 'scale_' + scale_key
#
#             subdir_path = os.path.join(alignem.project_data['data']['destination_path'], scale_key)
#             scale_1_path = os.path.join(alignem.project_data['data']['destination_path'], 'scale_1')
#
#             create_project_structure_directories(subdir_path)
#
#             alignem.print_debug(70, "Begin creating images at each layer for key: " + str(scale_key))
#
#             for layer in alignem.project_data['data']['scales'][scale_key]['alignment_stack']:
#                 alignem.print_debug(40, "Generating images for layer: \"" + str(
#                     alignem.project_data['data']['scales'][scale_key]['alignment_stack'].index(layer)) + "\"")
#                 # Remove previously aligned images from panel ??
#
#                 # Copy (or link) the source images to the expected scale_key"/img_src" directory
#                 for role in layer['images'].keys():
#
#                     # Only copy files for roles "ref" and "base"
#
#                     if role in ['ref', 'base']:
#                         alignem.print_debug(40, "Generating images for role: \"" + role + "\"")
#                         base_file_name = layer['images'][role]['filename']
#                         if base_file_name != None:
#                             if len(base_file_name) > 0:
#                                 abs_file_name = os.path.abspath(base_file_name)
#                                 bare_file_name = os.path.split(abs_file_name)[1]
#                                 destination_path = os.path.abspath(alignem.project_data['data']['destination_path'])
#                                 outfile_name = os.path.join(destination_path, scale_key, 'img_src', bare_file_name)
#                                 if scale == 1:
#                                     if get_best_path(abs_file_name) != get_best_path(outfile_name):
#                                         # The paths are different so make the link
#                                         try:
#                                             alignem.print_debug(70, "UnLinking " + outfile_name)
#                                             os.unlink(outfile_name)
#                                         except:
#                                             alignem.print_debug(70, "Error UnLinking " + outfile_name)
#                                         try:
#                                             alignem.print_debug(70,
#                                                                 "Linking from " + abs_file_name + " to " + outfile_name)
#                                             os.symlink(abs_file_name, outfile_name)
#                                         except:
#                                             alignem.print_debug(5,
#                                                                 "Unable to link from " + abs_file_name + " to " + outfile_name)
#                                             alignem.print_debug(5, "Copying file instead")
#                                             # Not all operating systems allow linking for all users (Windows 10, for example, requires admin rights)
#                                             try:
#                                                 shutil.copy(abs_file_name, outfile_name)
#                                             except:
#                                                 alignem.print_debug(1,
#                                                                     "Unable to link or copy from " + abs_file_name + " to " + outfile_name)
#                                                 print_exception()
#                                 else:
#                                     try:
#                                         # Do the scaling
#                                         alignem.print_debug(70,
#                                                             "Copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#
#                                         if os.path.split(os.path.split(os.path.split(abs_file_name)[0])[0])[
#                                             1].startswith('scale_'):
#                                             # Convert the source from whatever scale is currently processed to scale_1
#                                             p, f = os.path.split(abs_file_name)
#                                             p, r = os.path.split(p)
#                                             p, s = os.path.split(p)
#                                             abs_file_name = os.path.join(p, 'scale_1', r, f)
#
#                                         img = align_swiftir.swiftir.scaleImage(
#                                             align_swiftir.swiftir.loadImage(abs_file_name), fac=scale)
#                                         align_swiftir.swiftir.saveImage(img, outfile_name)
#                                         # Change the base image for this scale to the new file
#                                         layer['images'][role]['filename'] = outfile_name
#                                     except:
#                                         alignem.print_debug(1,
#                                                             "Error copying and scaling from " + abs_file_name + " to " + outfile_name + " by " + str(
#                                                                 scale))
#                                         print_exception()
#
#                                 # Update the Data Model with the new absolute file name. This replaces the originally opened file names
#                                 alignem.print_debug(40, "Original File Name: " + str(layer['images'][role]['filename']))
#                                 layer['images'][role]['filename'] = outfile_name
#                                 alignem.print_debug(40, "Updated  File Name: " + str(layer['images'][role]['filename']))
#     # main_win.status.showMessage("Done Generating Scales ...")


# # callbackbuttons
# # demo_bool = BoolField("Multiview Demo", False)
# # export_zarr_cb = CallbackButton("Export to Zarr", export_zarr)
# # neuroglancer_view_cb = CallbackButton("Neuroglancer View", neuroglancer_view)
# # #cname_type  = ComboBoxControl(['zstd  ', 'zlib  ', 'blosclz  ', 'lz4hc  ','gzip  '])
# # cname_type  = ComboBoxControl(['zstd  ', 'zlib  ', 'gzip  ',  'none' ])
# # # note - check for string comparison of 'none' later, do not add whitespace fill
# # clevel_val   = IntField("clevel (1-9):",5)
# # n_scales_val = IntField("scales:",4)
#
# link_stack_cb = CallbackButton('Link Stack', link_stack)
# # gen_scales_cb = CallbackButton('Gen Scales Ser', generate_scales)
# gen_scalesq_cb = CallbackButton('Gen Scales', generate_scales_queue)
# # gen_scales_opt_cb = CallbackButton('Gen Scales Opt', generate_scales_optimized)
# align_all_cb = CallbackButton('Align All', align_all_or_some)
# center_cb = CallbackButton('Center', center_all)
# align_fwd_cb = CallbackButton('Align Forward', align_forward)
# init_ref_app = ComboBoxControl(['Init Affine', 'Refine Affine', 'Apply Affine']) #affine
# #view_match_crop = ComboBoxControl(['View', 'Match', 'Crop'])
# #view_match_crop.set_value('View')
#
# # poly_order = IntField("Poly Order:", 0, 1)
#
# regen_aligned_cb = CallbackButton('Regenerate Aligned', regenerate_aligned)
# # num_fwd = IntField("#", 1, 1)
# jump_to_cb = CallbackButton('Jump To:', jump_to_layer)
# # jump_to_val = IntField("#", 0, 1)
# rem_algn_cb = CallbackButton('Remove Aligned', remove_aligned)
# # skip = BoolField("Skip", False) #skip
# # match_pt_mode = BoolField("Match",False)
# clear_match = CallbackButton("Clear Match", clear_match_points)
# progress_cb = CallbackButton('Prog Bar', run_progress)
# gen_scales_thread_cb = CallbackButton('Gen Scales (thread)', gen_scales_with_thread)
# link_stacks_cb = CallbackButton("Link All Stacks", link_all_stacks)
# debug_cb = CallbackButton('Debug', method_debug)
#
# clear_skips_cb = CallbackButton("Clear all Skips", clear_all_skips)
# skips_to_all_cb = CallbackButton('Skips -> All Scales', copy_skips_to_all_scales)
#
# refine_aff_cb = CallbackButton('Refine Affine', notyet) #affine
# apply_aff_cb = CallbackButton('Apply Affine', notyet) #affine
# # whitening_factor = FloatField('Whitening', -0.68)
# # win_scale_factor = FloatField('Initial SWIM Window', 0.8125)  # This was named "Window Scale Factor"
#
# # null_cafm_trends = BoolField("Null Bias", False)
# # use_bounding_rect = BoolField("Bounding Rect", False)


# control_model = [""]
# control_model = [
#     # Panes
#     [  # Begin first pane of rows
#         [
#             " ", gen_scalesq_cb,
#             " ", align_all_cb,
#             " ", poly_order,
#             " ", null_cafm_trends,
#             " ", use_bounding_rect,
#             " ", align_fwd_cb, num_fwd,
#             " ", jump_to_cb, jump_to_val,
#             " ", center_cb,
#             "    ", skip,
#             # "  ", match_pt_mode,
#             " ", view_match_crop,
#             " ", clear_match,
#             " "
#         ],
#         [
#             # "Test: ",
#             # gen_scales_thread_cb,
#             # " ", link_stack_cb,
#             " ", init_ref_app,
#             # " ", do_thing_cb,
#             # " ", refine_aff_cb,
#             # " ", apply_aff_cb,
#             " ", regen_aligned_cb,
#             " ", rem_algn_cb,
#             " ", whitening_factor,
#             " ", win_scale_factor,
#             " ", clear_skips_cb,
#             " ", skips_to_all_cb,
#             # " ", progress_cb,
#             # " ", debug_cb
#             " "
#         ],
#     ]
#


# class OldImageLibrary:
#     """A class containing multiple images keyed by their file name."""
#     def __init__ ( self ):
#         self._images = {}  # { image_key: { "task": task, "loading": bool, "loaded": bool, "image": image }
#         self.threaded_loading_enabled = True
#
#     def pathkey ( self, file_path ):
#         if file_path == None:
#             return None
#         return os.path.abspath(os.path.normpath(file_path))
#
#     def __str__ (self):
#         s = "ImageLibrary contains %d images\n" % len(self._images)
#         for k,v in self._images.items():
#             s += "  " + k + "\n"
#             s += "    loaded:  " + str(v['loaded']) + "\n"
#             s += "    loading: " + str(v['loading']) + "\n"
#             s += "    task:    " + str(v['task']) + "\n"
#             s += "    image:   " + str(v['image']) + "\n"
#
#         print_debug(4, s)
#         __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#         return ( "ImageLibrary contains ...")
#
#     def get_image_reference ( self, file_path ):
#         image_ref = None
#         real_norm_path = self.pathkey(file_path)
#         if real_norm_path != None:
#             # This is an actual path
#             if real_norm_path in self._images:
#                 # This file is already in the library ... it may be complete or still loading
#                 if self._images[real_norm_path]['loaded']:
#                     # The image is already loaded, so return it
#                     image_ref = self._images[real_norm_path]['image']
#                 elif self._images[real_norm_path]['loading']:
#                     # The image is still loading, so wait for it to complete
#                     self._images[real_norm_path]['task'].join()
#                     self._images[real_norm_path]['task'] = None
#                     self._images[real_norm_path]['loaded'] = True
#                     self._images[real_norm_path]['loading'] = False
#                     image_ref = self._images[real_norm_path]['image']
#                 else:
#                     print_debug ( 5, "  Load Warning for: \"" + str(real_norm_path) + "\"" )
#                     image_ref = self._images[real_norm_path]['image']
#             else:
#                 # The image is not in the library at all, so force a load now (and wait)
#                 print_debug ( 25, "  Forced load of image: \"" + str(real_norm_path) + "\"" )
#                 self._images[real_norm_path] = { 'image': QPixmap(real_norm_path), 'loaded': True, 'loading': False, 'task':None }
#                 image_ref = self._images[real_norm_path]['image']
#         return image_ref
#
#     def get_image_reference_if_loaded ( self, file_path ):
#         image_ref = None
#         real_norm_path = self.pathkey(file_path)
#         if real_norm_path != None:
#             # This is an actual path
#             if real_norm_path in self._images:
#                 # This file is already in the library ... it may be complete or still loading
#                 if self._images[real_norm_path]['loaded']:
#                     # The image is already loaded, so return it
#                     image_ref = self._images[real_norm_path]['image']
#                 elif self._images[real_norm_path]['loading']:
#                     # The image is still loading, so wait for it to complete
#                     self._images[real_norm_path]['task'].join()
#                     self._images[real_norm_path]['task'] = None
#                     self._images[real_norm_path]['loaded'] = True
#                     self._images[real_norm_path]['loading'] = False
#                     image_ref = self._images[real_norm_path]['image']
#                 else:
#                     print_debug ( 5, "  Load Warning for: \"" + str(real_norm_path) + "\"" )
#                     image_ref = self._images[real_norm_path]['image']
#         return image_ref
#
#
#     def remove_image_reference ( self, file_path ):
#         image_ref = None
#         if not (file_path is None):
#             real_norm_path = self.pathkey(file_path)
#             if real_norm_path in self._images:
#                 print_debug ( 50, "Unloading image: \"" + real_norm_path + "\"" )
#                 image_ref = self._images.pop(real_norm_path)['image']
#         # This returned value may not be valid when multi-threading is implemented
#         return image_ref
#
#     def queue_image_read ( self, file_path ):
#         real_norm_path = self.pathkey(file_path)
#         self._images[real_norm_path] = { 'image': None, 'loaded': False, 'loading': True, 'task':None }
#         t = threading.Thread ( target = load_image_worker, args = (real_norm_path,self._images[real_norm_path]) )
#         t.start()
#         self._images[real_norm_path]['task'] = t
#
#     def make_available ( self, requested ):
#         """
#         SOMETHING TO LOOK AT:
#
#         Note that the threaded loading sometimes loads the same image multiple
#         times. This may be due to an uncertainty about whether an image has been
#         scheduled for loading or not.
#
#         Right now, the current check is whether it is actually loaded before
#         scheduling it to be loaded. However, a load may be in progress from an
#         earlier request. This may cause images to be loaded multiple times.
#         """
#
#         print_debug ( 25, "make_available: " + str(sorted([str(s[-7:]) for s in requested])) )
#         already_loaded = set(self._images.keys())
#         normalized_requested = set ( [self.pathkey(f) for f in requested] )
#         need_to_load = normalized_requested - already_loaded
#         need_to_unload = already_loaded - normalized_requested
#         for f in need_to_unload:
#             self.remove_image_reference ( f )
#         for f in need_to_load:
#             if self.threaded_loading_enabled:
#                 self.queue_image_read ( f )   # Using this will enable threaded reading behavior
#             else:
#                 self.get_image_reference ( f )   # Using this will force sequential reading behavior
#
#         print_debug ( 25, "Library has " + str(len(self._images.keys())) + " images" )
#         # __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#
#     def remove_all_images ( self ):
#         keys = list(self._images.keys())
#         for k in keys:
#           self.remove_image_reference ( k )
#         self._images = {}
#
#     #tag What is OldImageLibrary?
#     def update ( self ):
#         print("Doing nothing | OldImageLibrary.update...")
#         # Do nothing - needed to be plug replacable with SmartImageLibrary
#         pass


# Using the Python version does not work because the Python 3 code can't
# # even be parsed by Python2. It could be dynamically compiled, or use the
# # alternate syntax, but that's more work than it's worth for now.
# if sys.version_info >= (3, 0):
#     if debug_level > 10: print ( "Python 3: Supports arbitrary arguments via print")
#     #def print_debug ( level, *ds ):
#     #  global debug_level
#     #  if level <= debug_level:
#     #    print ( *ds )
# else:
#     if debug_level > 10: print ("Python 2: Use default parameters for limited support of arbitrary arguments via print")


# def old_load_image_worker ( real_norm_path, image_dict ):
#     # Load the image
#     print_debug ( 50, "  load_image_worker started with: \"" + str(real_norm_path) + "\"" )
#     m = psutil.virtual_memory()
#     print_debug ( 50, "    memory available before loading = " + str(m.available) )
#     image_dict['image'] = QPixmap(real_norm_path)
#     image_dict['loaded'] = True
#     print_debug ( 50, "  load_image_worker finished for: \"" + str(real_norm_path) + "\"" )
#     print_debug ( 50, "    memory available after loading = " + str(m.available) )


    # @Slot()
    # def set_bg_color(self):
    #     c = QColorDialog.getColor()
    #     # print_debug ( 30, " Color = " + str(c) )
    #     self.image_panel.bg_color = c
    #     self.image_panel.update_multi_self()
    #     self.image_panel.repaint()
    #
    #     for p in self.panel_list:
    #         p.update_zpa_self()
    #         p.repaint()


    # @Slot()
    # def set_border_color(self):
    #     c = QColorDialog.getColor()
    #     self.image_panel.border_color = c
    #     self.image_panel.update_multi_self()
    #     self.image_panel.repaint()
    #     for p in self.panel_list:
    #         p.border_color = c
    #         p.update_zpa_self()
    #         p.repaint()






# def mousePressEvent(self, event):
#         global crop_mode_origin
#         global crop_mode_role
#         global crop_mode_disp_rect
#         global crop_mode_callback
#         crop_mode_role = None
#         crop_mode_disp_rect = None
#         crop_mode = False
#         mode = None
#         if crop_mode_callback != None:
#             mode = crop_mode_callback()
#             if mode == 'Crop':
#                 crop_mode = True
#             else:
#                 # Note: since we don't currently have a callback from a mode change,
#                 #  remove the crop box upon any mouse click.
#                 if crop_mode_origin != None:
#                     # Remove the box and force a redraw
#                     crop_mode_origin = None
#                     crop_mode_disp_rect = None
#                     crop_mode_role = None
#                     self.update_zpa_self()
#                     self.update_siblings()
#
#         if crop_mode:
#             crop_mode_role = self.role
#             ### New Rubber Band Code
#             crop_mode_origin = event.pos()
#             ex = event.x()
#             ey = event.y()
#             print_debug ( 60, "Current Mode = " + str(mode) + ", crop_mode_origin is " + str(crop_mode_origin) + ", (x,y) is " + str([ex, ey]) + ", wxy is " + str([self.image_x(ex), self.image_y(ey)]) )
#             if not self.rubberBand:
#                 self.rubberBand = QRubberBand(QRubberBand.Rectangle, self)
#             self.rubberBand.setGeometry(QRect(crop_mode_origin,QSize()))
#             self.rubberBand.show()
#             self.update_siblings()
#             #__import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})
#         else:
#             event_handled = False
#
#             ex = event.x()
#             ey = event.y()
#
#             if main_window.mouse_down_callback != None:
#                 event_handled = main_window.mouse_down_callback ( self.role, (ex,ey), (self.image_x(ex),self.image_y(ey)), int(event.button()) )
#
#             if not event_handled:
#
#                 self.last_button = event.button()
#                 if event.button() == Qt.MouseButton.RightButton:
#                     # Resest the pan and zoom
#                     self.dx = self.mdx = self.ldx = 0
#                     self.dy = self.mdy = self.ldy = 0
#                     self.wheel_index = 0
#                     self.zoom_scale = 1.0
#                 elif event.button() == Qt.MouseButton.MiddleButton:
#                     self.dump()
#                 else:
#                     # Set the Mouse Down position to be the screen location of the mouse
#                     self.mdx = ex
#                     self.mdy = ey
#
#             self.update_zpa_self()
#
#     def mouseMoveEvent(self, event):
#         global crop_mode_origin
#         global crop_mode_role
#         global crop_mode_disp_rect
#         global crop_mode_callback
#         crop_mode = False
#         if crop_mode_callback != None:
#             mode = crop_mode_callback()
#             if mode == 'Crop':
#                 crop_mode = True
#             else:
#                 # Note: since we don't currently have a callback from a mode change,
#                 #  try to remove the crop box upon mouse motion. However, this will
#                 #  require enabling all mouse motion events (not just with buttons).
#                 if crop_mode_origin != None:
#                     # Remove the box and force a redraw
#                     crop_mode_origin = None
#                     crop_mode_disp_rect = None
#                     crop_mode_role = None
#                     self.update_zpa_self()
#                     self.update_siblings()
#
#         if crop_mode:
#             ### New Rubber Band Code
#             print_debug ( 60, "Move: Current Mode = " + str(mode) + ", crop_mode_origin is " + str(crop_mode_origin) + ", mouse is " + str(event.pos()) )
#             if crop_mode_origin != None:
#                 self.rubberBand.setGeometry(QRect(crop_mode_origin,event.pos()).normalized())
#         else:
#             event_handled = False
#
#             if main_window.mouse_move_callback != None:
#                 event_handled = main_window.mouse_move_callback ( self.role, (0,0), (0,0), int(event.button()) )  # These will be ignored anyway for now
#
#             if not event_handled:
#
#                 if self.last_button == Qt.MouseButton.LeftButton:
#                     self.dx = (event.x() - self.mdx) / self.zoom_scale
#                     self.dy = (event.y() - self.mdy) / self.zoom_scale
#                     self.update_zpa_self()
#
#     def mouseReleaseEvent(self, event):
#         global crop_mode_origin
#         global crop_mode_role
#         global crop_mode_disp_rect
#         global crop_mode_corners
#         global crop_mode_callback
#
#         global crop_window_mode  # mouse_rectangle or mouse_square or fixed
#         global crop_window_width
#         global crop_window_height
#
#         crop_mode = False
#         if crop_mode_callback != None:
#             mode = crop_mode_callback()
#             if mode == 'Crop':
#                 crop_mode = True
#         if crop_mode:
#             self.rubberBand.hide()
#             if crop_mode_origin != None:
#
#                 print_debug ( 50, "Mouse drawn from (" + str(crop_mode_origin.x()) + "," + str(crop_mode_origin.y()) + ") to (" + str(event.x()) + "," + str(event.y()) + ")")
#                 print_debug ( 50, "Cropping with mode: " + str(crop_window_mode) )
#
#                 if crop_window_mode == 'mouse_rectangle':
#
#                     # Convert to image coordinates
#                     img_orig_x = self.image_x(crop_mode_origin.x())
#                     img_orig_y = self.image_y(crop_mode_origin.y())
#                     img_rel_x = self.image_x(event.x())
#                     img_rel_y = self.image_y(event.y())
#
#                     # Save the cropping corners for the actual cropping which is done later
#                     crop_mode_corners = [ [ img_orig_x, img_orig_y ], [ img_rel_x, img_rel_y ] ]
#                     print_debug ( 50, "Crop Corners: " + str(crop_mode_corners) ) ### These appear to be correct
#
#                     # Convert the crop_mode_corners from image mode back into screen mode for crop_mode_disp_rect
#                     crop_w = img_orig_x + self.image_x(event.x() - crop_mode_origin.x())
#                     crop_h = img_orig_y + self.image_y(event.y() - crop_mode_origin.y())
#                     crop_mode_disp_rect = [ [ img_orig_x, img_orig_y ], [ crop_w, crop_h ] ]
#
#                 elif crop_window_mode == 'mouse_square':
#
#                     # Convert to image coordinates:
#                     img_orig_x = self.image_x(crop_mode_origin.x())
#                     img_orig_y = self.image_y(crop_mode_origin.y())
#                     img_rel_x = self.image_x(event.x())
#                     img_rel_y = self.image_y(event.y())
#
#                     # Find the center of the selected region in image coordinates (might be a single point)
#                     img_ctr_x = (img_orig_x + img_rel_x) / 2.0
#                     img_ctr_y = (img_orig_y + img_rel_y) / 2.0
#
#                     # Find the width and height and the square root of the equivalent area
#                     img_width = abs(img_rel_x - img_orig_x)
#                     img_height = abs(img_rel_y - img_orig_y)
#                     area = img_width * img_height
#                     img_side = int ( round(math.sqrt ( area )) )
#                     print_debug ( 30, "Cropped image will be " + str(img_side) + "x" + str(img_side) )
#
#                     # Compute the upper left and lower right corners in image coordinates
#                     img_p0_x = img_ctr_x - (img_side/2)
#                     img_p0_y = img_ctr_y - (img_side/2)
#                     img_p1_x = img_p0_x + img_side
#                     img_p1_y = img_p0_y + img_side
#
#                     # Save the cropping corners for the actual cropping which is done later
#                     crop_mode_corners = [ [ img_p0_x, img_p0_y ], [ img_p1_x, img_p1_y ] ]
#                     print_debug ( 50, "Crop Corners: " + str(crop_mode_corners) ) ### These appear to be correct
#
#                     # Convert the crop_mode_corners from image mode back into screen mode for crop_mode_disp_rect
#                     crop_w = img_p0_x + self.image_x(self.win_x(img_p1_x) - self.win_x(img_p0_x))
#                     crop_h = img_p0_y + self.image_y(self.win_y(img_p1_y) - self.win_y(img_p0_y))
#                     crop_mode_disp_rect = [ [ img_p0_x, img_p0_y ], [ crop_w, crop_h ] ]
#
#                 elif crop_window_mode == 'mouse_center_fixed':
#
#                     # Convert to image coordinates:
#                     img_orig_x = self.image_x(crop_mode_origin.x())
#                     img_orig_y = self.image_y(crop_mode_origin.y())
#                     img_rel_x = self.image_x(event.x())
#                     img_rel_y = self.image_y(event.y())
#
#                     # Calculate the center of selection in image coordinates
#                     img_ctr_x = (img_orig_x + img_rel_x) / 2.0
#                     img_ctr_y = (img_orig_y + img_rel_y) / 2.0
#
#                     # Calculate the image width (just the original fixed value)
#                     img_width = float(crop_window_width)
#                     img_height = float(crop_window_height)
#
#                     # Calculate the corners of the rectangle in image coordinates
#                     img_p0_x = img_ctr_x - (img_width/2)
#                     img_p0_y = img_ctr_y - (img_height/2)
#                     img_p1_x = img_p0_x + img_width
#                     img_p1_y = img_p0_y + img_height
#
#                     # Save the cropping corners for the actual cropping which is done later
#                     crop_mode_corners = [ [ img_p0_x, img_p0_y ], [ img_p1_x, img_p1_y ] ]
#                     print_debug ( 50, "Crop Corners: " + str(crop_mode_corners) ) ### These appear to be correct
#
#                     # Convert the crop_mode_corners from image mode back into screen mode for crop_mode_disp_rect
#                     crop_w = img_p0_x + self.image_x(self.win_x(img_p1_x) - self.win_x(img_p0_x))
#                     crop_h = img_p0_y + self.image_y(self.win_y(img_p1_y) - self.win_y(img_p0_y))
#                     crop_mode_disp_rect = [ [ img_p0_x, img_p0_y ], [ crop_w, crop_h ] ]
#
#                 self.update_zpa_self()
#                 self.update_siblings()
#
#         else:
#
#             if event.button() == Qt.MouseButton.LeftButton:
#                 self.ldx = self.ldx + self.dx
#                 self.ldy = self.ldy + self.dy
#                 self.dx = 0
#                 self.dy = 0
#                 self.update_zpa_self()
#
#     def mouseDoubleClickEvent(self, event):
#         print_debug ( 50, "mouseDoubleClickEvent at " + str(event.x()) + ", " + str(event.y()) )
#         self.update_zpa_self()
#
#
#     def zoom_to_wheel_at ( self, mouse_win_x, mouse_win_y ):
#         clear_crop_settings()
#         old_scale = self.zoom_scale
#         new_scale = self.zoom_scale = pow (self.scroll_factor, self.wheel_index)
#
#         self.ldx = self.ldx + (mouse_win_x/new_scale) - (mouse_win_x/old_scale)
#         self.ldy = self.ldy + (mouse_win_y/new_scale) - (mouse_win_y/old_scale)



# def clear_match_points():
#     print('\nCalling clear_match_points() in alignem_swift.py:\n')
#
#     # global match_pt_mode
#     # if not match_pt_mode.get_value():
#     if view_match_crop.get_value() != 'Match':
#         print('"\nMust be in \"Match\" mode to delete all match points."')
#     else:
#         print('Deleting all match points for this layer')
#         scale_key = cfg.project_data['data']['current_scale']
#         layer_num = cfg.project_data['data']['current_layer']
#         stack = cfg.project_data['data']['scales'][scale_key]['alignment_stack']
#         layer = stack[layer_num]
#
#         for role in layer['images'].keys():
#             if 'metadata' in layer['images'][role]:
#                 layer['images'][role]['metadata']['match_points'] = []
#                 layer['images'][role]['metadata']['annotations'] = []
#         cfg.main_window.update_win_self()
#         cfg.main_window.refresh_all_images()



    #
    #
    # @Slot()
    # def save_cropped_as(self):
    #     print('MainWindow.save_cropped_as | saving cropped as...')
    #
    #     crop_parallel = True
    #
    #     if crop_mode_role == None:
    #         show_warning("Warning", "Cannot save cropped images without a cropping region")
    #
    #     elif cfg.project_data['data']['destination_path'] == None:
    #         show_warning("Warning", "Cannot save cropped images without a destination path")
    #
    #     elif len(cfg.project_data['data']['destination_path']) <= 0:
    #         show_warning("Warning", "Cannot save cropped images without a valid destination path")
    #     else:
    #         options = QFileDialog.Options()
    #         options |= QFileDialog.Directory
    #         options |= QFileDialog.DontUseNativeDialog
    #
    #         cropped_path = QFileDialog.getExistingDirectory(parent=None, caption="Select Directory for Cropped Images",
    #                                                         dir=cfg.project_data['data']['destination_path'],
    #                                                         options=options)
    #         print_debug(1, "Cropped Destination is: " + str(cropped_path))
    #
    #         if cropped_path != None:
    #             if len(cropped_path) > 0:
    #                 print("Crop and save images from role " + str(crop_mode_role) + " to " + str(cropped_path))
    #                 scale_key = cfg.project_data['data']['current_scale']
    #                 cropping_queue = None
    #                 if crop_parallel:
    #                     print("Before: cropping_queue = task_queue.TaskQueue ( sys.executable )")
    #                     # __import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
    #                     # cropping_queue = task_queue.TaskQueue ( sys.executable )
    #                     cropping_queue = task_queue.TaskQueue()
    #                     cpus = psutil.cpu_count(logical=False)
    #                     if cpus > 48:
    #                         cpus = 48
    #                     cropping_queue.start(cpus)
    #                     cropping_queue.notify = False
    #                     cropping_queue.passthrough_stdout = False
    #                     cropping_queue.passthrough_stderr = False
    #
    #                 for layer in cfg.project_data['data']['scales'][scale_key]['alignment_stack']:
    #                     infile_name = layer['images'][crop_mode_role]['filename']
    #                     name_part = os.path.split(infile_name)[1]
    #                     if '.' in name_part:
    #                         npp = name_part.rsplit('.')
    #                         name_part = npp[0] + "_crop." + npp[1]
    #                     else:
    #                         name_part = name_part + "_crop"
    #                     outfile_name = os.path.join(cropped_path, name_part)
    #                     print("Cropping image " + infile_name)
    #                     print("Saving cropped " + outfile_name)
    #
    #                     # Use the "extractStraightWindow" function which takes a center and a rectangle
    #                     crop_cx = int((crop_mode_corners[0][0] + crop_mode_corners[1][0]) / 2)
    #                     crop_cy = int((crop_mode_corners[0][1] + crop_mode_corners[1][1]) / 2)
    #                     crop_w = abs(int(crop_mode_corners[1][0] - crop_mode_corners[0][0]))
    #                     crop_h = abs(int(crop_mode_corners[1][1] - crop_mode_corners[0][1]))
    #                     print("x,y = " + str((crop_cx, crop_cy)) + ", w,h = " + str((crop_w, crop_h)))
    #
    #                     if crop_parallel:
    #                         my_path = os.path.split(os.path.realpath(__file__))[0]
    #                         crop_job = os.path.join(my_path, 'single_crop_job.py')
    #                         print(
    #                             "cropping_queue.add_task ( [sys.executable, crop_job, str(crop_cx), str(crop_cy), str(crop_w), str(crop_h), infile_name, outfile_name] )")
    #                         # __import__ ('code').interact (local={ k: v for ns in (globals (), locals ()) for k, v in ns.items () })
    #                         cropping_queue.add_task(
    #                             [sys.executable, crop_job, str(crop_cx), str(crop_cy), str(crop_w), str(crop_h),
    #                              infile_name, outfile_name])
    #
    #                     else:
    #                         img = align_swiftir.swiftir.extractStraightWindow(
    #                             align_swiftir.swiftir.loadImage(infile_name), xy=(crop_cx, crop_cy),
    #                             siz=(crop_w, crop_h))
    #                         align_swiftir.swiftir.saveImage(img, outfile_name)
    #
    #                 if crop_parallel:
    #                     cropping_queue.collect_results()  # It might be good to have an explicit "join" function, but this seems to do so internally.

    # @Slot()
    # def toggle_full_paths(self, checked):
    #     print('MainWindow.toggle_full_paths:')
    #     self.draw_full_paths = checked
    #     self.image_panel.draw_full_paths = self.draw_full_paths
    #     self.image_panel.update_multi_self()
    #     for p in self.panel_list:
    #         p.draw_full_paths = self.draw_full_paths
    #         p.update_zpa_self()
    #
    #     if self.draw_full_paths:
    #         self.setWindowTitle("Project: " + self.project_filename)
    #     else:
    #         self.setWindowTitle("Project: " + os.path.split(self.project_filename)[-1])


    # @Slot()
    # def save_project_as(self):
    #     print("MainWindow is showing the save project as dialog...")
    #     cfg.main_window.status.showMessage("Saving...")
    #     # options = QFileDialog.Options()
    #     # options |= QFileDialog.DontUseNativeDialog
    #     file_name, filter = QFileDialog.getSaveFileName(parent=None,  # None was self
    #                                                     caption="Save Project",
    #                                                     filter="Projects (*.json);;All Files (*)",
    #                                                     selectedFilter="")
    #     if file_name != None:
    #         if len(file_name) > 0:
    #             self.project_filename = file_name
    #
    #             # Attempt to hide the file dialog before opening ...
    #             for p in self.panel_list:
    #                 p.update_zpa_self()
    #             # self.update_win_self()
    #             try:
    #                 self.save_project_to_file()
    #             except:
    #                 print("save_project_as | WARNING | Project not saved.")
    #                 self.set_idle()
    #                 return
    #
    #             try:
    #                 self.setWindowTitle("Project: " + self.project_filename)
    #             except:
    #                 self.set_idle()
    #                 return
    #
    #             self.set_def_proj_dest()
    #     self.set_idle()




        # This could be used to optionally simplify menus:
        '''
        if simple_mode:
            ml[0] = [ '&File',
                [
                  [ '&New Project', 'Ctrl+N', self.new_project, None, None, None ],
                  [ '&Open Project', 'Ctrl+O', self.open_project, None, None, None ],
                  [ '&Save Project', 'Ctrl+S', self.save_project, None, None, None ],
                  [ 'Save Project &As...', 'Ctrl+A', self.save_project_as, None, None, None ],
                  [ '-', None, None, None, None, None ],
                  [ 'Save &Cropped As...', None, self.save_cropped_as, None, None, None ],
                  [ '-', None, None, None, None, None ],
                  [ 'E&xit', 'Ctrl+Q', self.exit_app, None, None, None ]
                ]
              ]

        '''

        # This could be used to optionally simplify menus:
        '''
        if simple_mode:
            ml[0] = [ '&File',
                [
                  [ '&New Project', 'Ctrl+N', self.new_project, None, None, None ],
                  [ '&Open Project', 'Ctrl+O', self.open_project, None, None, None ],
                  [ '&Save Project', 'Ctrl+S', self.save_project, None, None, None ],
                  [ 'Save Project &As...', 'Ctrl+A', self.save_project_as, None, None, None ],
                  [ '-', None, None, None, None, None ],
                  [ 'Save &Cropped As...', None, self.save_cropped_as, None, None, None ],
                  [ '-', None, None, None, None, None ],
                  [ 'E&xit', 'Ctrl+Q', self.exit_app, None, None, None ]
                ]
              ]

        '''

            # @Slot()
    # def set_crop_square(self):
    #     global crop_window_mode
    #     crop_window_mode = 'mouse_square'
    #     print_debug(10, "Crop window will be square")
    #
    # @Slot()
    # def set_crop_rect(self):
    #     global crop_window_mode
    #     crop_window_mode = 'mouse_rectangle'
    #     print_debug(10, "Crop window will be rectangular")
    #
    # @Slot()
    # def set_crop_fixed(self):
    #     global crop_window_mode
    #     global crop_window_width
    #     global crop_window_height
    #
    #     crop_window_mode = 'mouse_center_fixed'
    #     current = str(crop_window_width) + 'x' + str(crop_window_height)
    #     input_str, ok = QInputDialog().getText(None, "Set Crop Window Size", "Current: " + current,
    #                                            echo=QLineEdit.Normal, text=current)
    #     if ok:
    #         wh = input_str.strip()
    #         if len(wh) > 0:
    #             w_h = []
    #             if 'x' in wh:
    #                 w_h = [f.strip() for f in wh.split('x')]
    #             elif ' ' in wh:
    #                 w_h = [f.strip() for f in wh.split(' ')]
    #             if len(w_h) > 0:
    #                 if len(w_h) >= 2:
    #                     # Set independently
    #                     crop_window_width = w_h[0]
    #                     crop_window_height = w_h[1]
    #                 else:
    #                     # Set together
    #                     crop_window_width = w_h[0]
    #                     crop_window_height = w_h[0]
    #                 print_debug(10, "Crop Window will be " + str(crop_window_width) + "x" + str(crop_window_height))



    # if self.role == crop_mode_role:
    #     if crop_mode_disp_rect != None:
    #         painter.setPen(QPen(QColor(255, 100, 100, 255), 3))
    #         rect_to_draw = QRectF(self.win_x(crop_mode_disp_rect[0][0]), self.win_y(crop_mode_disp_rect[0][1]),
    #                               self.win_x(crop_mode_disp_rect[1][0] - crop_mode_disp_rect[0][0]),
    #                               self.win_y(crop_mode_disp_rect[1][1] - crop_mode_disp_rect[0][1]))
    #         painter.drawRect(rect_to_draw)

    # Note: It's difficult to use this on a Mac because of the focus policy combined with the shared single menu.
    # __import__('code').interact(local={k: v for ns in (globals(), locals()) for k, v in ns.items()})

    # print("standalone function exiting paintEvent")


                 # ['Define Waves', None, self.not_yet, None, None, None],
                 # ['Make Waves', None, self.not_yet, None, None, None],
                 # ['-', None, None, None, None, None],
                 # ['Define Grid', None, self.not_yet, None, None, None],
                 # ['Grid Align', None, self.not_yet, None, None, None],
                 # ['-', None, None, None, None, None],
                 # ['Show Waves', None, self.not_yet, False, "GridMode", None],
                 # ['Show Grid Align', None, self.not_yet, False, "GridMode", None],
                 # ['Show Aligned', None, self.not_yet, True, "GridMode", None],
                 # ['-', None, None, None, None, None],
                 # ['&Python Console', 'Ctrl+P', self.py_console, None, None, None], #orig
                 # ['&Python Console', 'Ctrl+P', console, None, None, None],
                 # ['-', None, None, None, None, None],